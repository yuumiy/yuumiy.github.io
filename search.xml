<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>100天微笑训练打卡</title>
    <url>/posts/b45e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="100天微笑训练打卡"><a href="#100天微笑训练打卡" class="headerlink" title="100天微笑训练打卡"></a>100天微笑训练打卡</h1><p>每天对着镜子练习100遍“引”字；舌头转圈，左转40圈，右转40圈</p>
<span id="more"></span>

<h3 id="day1-2024-2-7"><a href="#day1-2024-2-7" class="headerlink" title="day1 2024.2.7"></a>day1 2024.2.7</h3><p>finish</p>
<h3 id="day2-2024-2-8"><a href="#day2-2024-2-8" class="headerlink" title="day2 2024.2.8"></a>day2 2024.2.8</h3><p>finish</p>
<h3 id="day3-2024-2-9"><a href="#day3-2024-2-9" class="headerlink" title="day3 2024.2.9"></a>day3 2024.2.9</h3><p>finish</p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>180天学习计划打卡</title>
    <url>/posts/1b4c.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="180天学习计划打卡"><a href="#180天学习计划打卡" class="headerlink" title="180天学习计划打卡"></a>180天学习计划打卡</h1><p>加油冲冲冲！！记录每天的学习时长</p>
<span id="more"></span>

<h3 id="day1-2024-1-13"><a href="#day1-2024-1-13" class="headerlink" title="day1 2024.1.13"></a>day1 2024.1.13</h3><p>学习时长：8h</p>
<h3 id="day2-2024-1-14"><a href="#day2-2024-1-14" class="headerlink" title="day2 2024.1.14"></a>day2 2024.1.14</h3><p>学习时长：5h</p>
<h3 id="day3-2024-1-15"><a href="#day3-2024-1-15" class="headerlink" title="day3 2024.1.15"></a>day3 2024.1.15</h3><p>学习时长：2.5h</p>
<h3 id="day4-2024-1-16"><a href="#day4-2024-1-16" class="headerlink" title="day4 2024.1.16"></a>day4 2024.1.16</h3><p>学习时长：2.5h</p>
<h3 id="day5-2024-1-17"><a href="#day5-2024-1-17" class="headerlink" title="day5 2024.1.17"></a>day5 2024.1.17</h3><p>学习时长：3.5h</p>
<h3 id="day6-2024-1-18"><a href="#day6-2024-1-18" class="headerlink" title="day6 2024.1.18"></a>day6 2024.1.18</h3><p>学习时长：2.5h</p>
<h3 id="day7-2024-1-19"><a href="#day7-2024-1-19" class="headerlink" title="day7 2024.1.19"></a>day7 2024.1.19</h3><p>学习时长：5h</p>
<h3 id="day8-2024-1-20"><a href="#day8-2024-1-20" class="headerlink" title="day8 2024.1.20"></a>day8 2024.1.20</h3><p>学习时长：5h</p>
<h3 id="day9-2024-1-21"><a href="#day9-2024-1-21" class="headerlink" title="day9 2024.1.21"></a>day9 2024.1.21</h3><p>学习时长：2h</p>
<h3 id="day10-2024-1-22"><a href="#day10-2024-1-22" class="headerlink" title="day10 2024.1.22"></a>day10 2024.1.22</h3><p>学习时长：3h</p>
<h3 id="day11-2024-1-23"><a href="#day11-2024-1-23" class="headerlink" title="day11 2024.1.23"></a>day11 2024.1.23</h3><p>学习时长：3h</p>
<h3 id="day12-2024-1-24"><a href="#day12-2024-1-24" class="headerlink" title="day12 2024.1.24"></a>day12 2024.1.24</h3><p>学习时长：2.5h</p>
<h3 id="day13-2024-1-25"><a href="#day13-2024-1-25" class="headerlink" title="day13 2024.1.25"></a>day13 2024.1.25</h3><p>学习时长：1h</p>
<h3 id="day14-2024-1-26"><a href="#day14-2024-1-26" class="headerlink" title="day14 2024.1.26"></a>day14 2024.1.26</h3><p>学习时长：1h</p>
<h3 id="day15-2024-1-27"><a href="#day15-2024-1-27" class="headerlink" title="day15 2024.1.27"></a>day15 2024.1.27</h3><p>学习时长：2h</p>
<h3 id="day16-2024-1-28"><a href="#day16-2024-1-28" class="headerlink" title="day16 2024.1.28"></a>day16 2024.1.28</h3><p>学习时长：5h</p>
<h3 id="day17-2024-1-29"><a href="#day17-2024-1-29" class="headerlink" title="day17 2024.1.29"></a>day17 2024.1.29</h3><p>学习时长：1h</p>
<h3 id="day18-2024-1-30"><a href="#day18-2024-1-30" class="headerlink" title="day18 2024.1.30"></a>day18 2024.1.30</h3><p>学习时长：45min</p>
<h3 id="day19-2024-1-31"><a href="#day19-2024-1-31" class="headerlink" title="day19 2024.1.31"></a>day19 2024.1.31</h3><p>学习时长：1.5h</p>
<h3 id="day20-2024-2-1"><a href="#day20-2024-2-1" class="headerlink" title="day20 2024.2.1"></a>day20 2024.2.1</h3><p>学习时长：2.5h</p>
<h3 id="day21-2024-2-2"><a href="#day21-2024-2-2" class="headerlink" title="day21 2024.2.2"></a>day21 2024.2.2</h3><p>学习时长：1h</p>
<h3 id="day22-2024-2-3"><a href="#day22-2024-2-3" class="headerlink" title="day22 2024.2.3"></a>day22 2024.2.3</h3><p>学习时长：4h</p>
<h3 id="day23-2024-2-4"><a href="#day23-2024-2-4" class="headerlink" title="day23 2024.2.4"></a>day23 2024.2.4</h3><p>学习时长：1.5h</p>
<h3 id="day24-2024-2-5"><a href="#day24-2024-2-5" class="headerlink" title="day24 2024.2.5"></a>day24 2024.2.5</h3><p>学习时长：1h</p>
<h3 id="day25-2024-2-6"><a href="#day25-2024-2-6" class="headerlink" title="day25 2024.2.6"></a>day25 2024.2.6</h3><p>学习时长：30min</p>
<h3 id="day26-2024-2-7"><a href="#day26-2024-2-7" class="headerlink" title="day26 2024.2.7"></a>day26 2024.2.7</h3><p>学习时长：3h</p>
<h3 id="day27-2024-2-8"><a href="#day27-2024-2-8" class="headerlink" title="day27 2024.2.8"></a>day27 2024.2.8</h3><p>学习时长：4h</p>
<h3 id="day28-2024-2-9"><a href="#day28-2024-2-9" class="headerlink" title="day28 2024.2.9"></a>day28 2024.2.9</h3><p>学习时长：4h</p>
<h3 id="day29-2024-2-10"><a href="#day29-2024-2-10" class="headerlink" title="day29 2024.2.10"></a>day29 2024.2.10</h3><p>学习时长：4.5h</p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>由Hexo Next搭建的博客网站，这是第一篇博客！</p>
<p>文章将有以下分类：工具、技术、笔记、思考、生活、阅读</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>100天提升口才计划打卡</title>
    <url>/posts/9399.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="100天提升口才计划打卡"><a href="#100天提升口才计划打卡" class="headerlink" title="100天提升口才计划打卡"></a>100天提升口才计划打卡</h1><p>努力锻炼自己的说话水平，口才能力，口语能力，变得能说会道，我也要变得优秀起来。这100天练习的都是名人演讲、人民日报的内容</p>
<span id="more"></span>

<h3 id="day1-2024-1-20"><a href="#day1-2024-1-20" class="headerlink" title="day1 2024.1.20"></a>day1 2024.1.20</h3><p>安妮海瑟薇联合国为女权发声：男女平等，呼吁带薪产假</p>
<h3 id="day2-2024-1-21"><a href="#day2-2024-1-21" class="headerlink" title="day2 2024.1.21"></a>day2 2024.1.21</h3><p>快递哥窦逗演讲：用心赚钱</p>
<h3 id="day3-2024-1-22"><a href="#day3-2024-1-22" class="headerlink" title="day3 2024.1.22"></a>day3 2024.1.22</h3><p>清华施一公演讲稿：知足常乐是创新的大敌</p>
<h3 id="day4-2024-1-23"><a href="#day4-2024-1-23" class="headerlink" title="day4 2024.1.23"></a>day4 2024.1.23</h3><p>演员邓超：给生活找点快乐</p>
<h3 id="day5-2024-1-24"><a href="#day5-2024-1-24" class="headerlink" title="day5 2024.1.24"></a>day5 2024.1.24</h3><p>开讲啦濮存昕演讲稿：人生不是只有第一起跑线</p>
<h3 id="day6-2024-1-25"><a href="#day6-2024-1-25" class="headerlink" title="day6 2024.1.25"></a>day6 2024.1.25</h3><p>东京大学入学祝辞：”努力也未必成功”的社会在等你！</p>
<h3 id="day7-2024-1-26"><a href="#day7-2024-1-26" class="headerlink" title="day7 2024.1.26"></a>day7 2024.1.26</h3><p>你的努力，时间会记得</p>
<h3 id="day8-2024-1-27"><a href="#day8-2024-1-27" class="headerlink" title="day8 2024.1.27"></a>day8 2024.1.27</h3><p>开讲啦崔新琴演讲稿：没有人会一夜成名</p>
<h3 id="day9-2024-1-28"><a href="#day9-2024-1-28" class="headerlink" title="day9 2024.1.28"></a>day9 2024.1.28</h3><p>清华大学李稻葵：消灭选择，找准圈子，做自己人生的CEO</p>
<h3 id="day10-2024-1-29"><a href="#day10-2024-1-29" class="headerlink" title="day10 2024.1.29"></a>day10 2024.1.29</h3><p>人民日报：走上坡路的人，都有这样的思维方式</p>
<h3 id="day11-2024-1-30"><a href="#day11-2024-1-30" class="headerlink" title="day11 2024.1.30"></a>day11 2024.1.30</h3><p>2017年北大校长毕业典礼致辞：吃亏就是占便宜</p>
<h3 id="day12-2024-1-31"><a href="#day12-2024-1-31" class="headerlink" title="day12 2024.1.31"></a>day12 2024.1.31</h3><p>抵抗天赋的诱惑：贝索斯在普林斯顿大学2010年学士毕业典礼上的演讲</p>
<h3 id="day13-2024-2-1"><a href="#day13-2024-2-1" class="headerlink" title="day13 2024.2.1"></a>day13 2024.2.1</h3><p>马云清华大学演讲：30年来我只坚持三件事</p>
<h3 id="day14-2024-2-2"><a href="#day14-2024-2-2" class="headerlink" title="day14 2024.2.2"></a>day14 2024.2.2</h3><p>人民日报夜读：让人受益一生的6件小事</p>
<h3 id="day15-2024-2-3"><a href="#day15-2024-2-3" class="headerlink" title="day15 2024.2.3"></a>day15 2024.2.3</h3><p>黄怀宁励志演讲节选：做一个主动的人</p>
<h3 id="day16-2024-2-4"><a href="#day16-2024-2-4" class="headerlink" title="day16 2024.2.4"></a>day16 2024.2.4</h3><p>李嘉诚：没有人愿意贫穷，但出路在哪里</p>
<h3 id="day17-2024-2-5"><a href="#day17-2024-2-5" class="headerlink" title="day17 2024.2.5"></a>day17 2024.2.5</h3><p>理想是保健品，不是速效救心丸</p>
<h3 id="day18-2024-2-6"><a href="#day18-2024-2-6" class="headerlink" title="day18 2024.2.6"></a>day18 2024.2.6</h3><p>男性要肯主内，女强人会更多</p>
<h3 id="day19-2024-2-7"><a href="#day19-2024-2-7" class="headerlink" title="day19 2024.2.7"></a>day19 2024.2.7</h3><p>李嘉诚：做自己命运的行动英雄——在长江商学院十周年庆典的影响</p>
<h3 id="day20-2024-2-8"><a href="#day20-2024-2-8" class="headerlink" title="day20 2024.2.8"></a>day20 2024.2.8</h3><p>香港中文大学校长毕业典礼讲话：不流俗不盲从，不负此生</p>
<h3 id="day21-2024-2-9"><a href="#day21-2024-2-9" class="headerlink" title="day21 2024.2.9"></a>day21 2024.2.9</h3><p>没有人可以永远年轻，但我可以做一个热爱自己的”大妈”</p>
<h3 id="day22-2024-2-10"><a href="#day22-2024-2-10" class="headerlink" title="day22 2024.2.10"></a>day22 2024.2.10</h3><p>活得通透的人，都有这3种思维</p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows和IDEA的常用快捷键</title>
    <url>/posts/bde9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>博主作为一个Java后端攻城狮，开发过程中不免要使用许多的快捷键。合理使用快捷键能极大提高工作效率，那么这么多的快捷键又该记住哪些呢，把所有快捷键都记下显然是不太现实的。因此我根据平时的使用习惯，总结了自己在Windows和IDEA中常用的快捷键。</p>
</blockquote>
<span id="more"></span>

<h1 id="Windows快捷键"><a href="#Windows快捷键" class="headerlink" title="Windows快捷键"></a>Windows快捷键</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>win</td>
<td>打开开始菜单</td>
</tr>
<tr>
<td>win + d</td>
<td>缩小所有窗口</td>
</tr>
<tr>
<td>win + a</td>
<td>打开右侧通知栏(可连wifi、蓝牙等)</td>
</tr>
<tr>
<td>win + e</td>
<td>打开我的电脑</td>
</tr>
<tr>
<td>win + r</td>
<td>cmd进入命令行，regedit进入注册表</td>
</tr>
<tr>
<td>win + q</td>
<td>打开搜索栏</td>
</tr>
<tr>
<td>win + l</td>
<td>快速锁屏</td>
</tr>
<tr>
<td>win + i</td>
<td>打开windows设置</td>
</tr>
<tr>
<td>win + x + u + s</td>
<td>使电脑进入睡眠状态</td>
</tr>
<tr>
<td>win + p</td>
<td>多屏管理</td>
</tr>
<tr>
<td>win + .</td>
<td>输入表情符号</td>
</tr>
<tr>
<td>alt + tab</td>
<td>切换窗口</td>
</tr>
<tr>
<td>ctrl + shift + esc</td>
<td>打开任务管理器</td>
</tr>
<tr>
<td>ctrl + tab</td>
<td>切换chrome网页窗口</td>
</tr>
<tr>
<td>ctrl + j</td>
<td>进入下载内容</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>收藏网页</td>
</tr>
<tr>
<td>F5</td>
<td>chrome刷新网页</td>
</tr>
<tr>
<td>F12</td>
<td>chrome进入开发者工具</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>开发者工具下刷新页面请求</td>
</tr>
<tr>
<td>F2</td>
<td>重命名</td>
</tr>
<tr>
<td>ctrl + alt + a</td>
<td>【个人习惯】截屏</td>
</tr>
<tr>
<td>F3</td>
<td>【个人习惯】贴图</td>
</tr>
<tr>
<td>鼠标左侧按键</td>
<td>【个人习惯】网页前进后退</td>
</tr>
<tr>
<td>ctrl + 选中文字</td>
<td>【个人习惯】沙拉查词翻译</td>
</tr>
<tr>
<td>ctrl + /</td>
<td>【个人习惯】语雀插入代码块</td>
</tr>
<tr>
<td>ctrl + `</td>
<td>打开Ditto，双击即复制</td>
</tr>
</tbody></table>
<h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>选中项目 + →</td>
<td>展开项目</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>撤销</td>
</tr>
<tr>
<td>ctrl + shift + z</td>
<td>反撤销</td>
</tr>
<tr>
<td>ctrl + y</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>复制当前行</td>
</tr>
<tr>
<td>鼠标快速点三下</td>
<td>选中当前行</td>
</tr>
<tr>
<td>ctrl + alt + t</td>
<td>快速try…catch/if</td>
</tr>
<tr>
<td>ctrl + /</td>
<td>单行注释</td>
</tr>
<tr>
<td>ctrl + shift + /</td>
<td>多行注释</td>
</tr>
<tr>
<td>alt + enter</td>
<td>导包、修正代码</td>
</tr>
<tr>
<td>alt + insert</td>
<td>pojo类生成方法</td>
</tr>
<tr>
<td>ctrl + tab</td>
<td>切换代码窗口(按上下键选择文件)</td>
</tr>
<tr>
<td>ctrl + f</td>
<td>当前文件搜索关键字</td>
</tr>
<tr>
<td>ctrl + shift + f</td>
<td>全局搜索关键字</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>当前文件替换关键字</td>
</tr>
<tr>
<td>ctrl + shift + r</td>
<td>全局替换关键字</td>
</tr>
<tr>
<td>ctrl + n</td>
<td>通过类名查找文件</td>
</tr>
<tr>
<td>ctrl + shift + n</td>
<td>通过文件名定位</td>
</tr>
<tr>
<td>ctrl + alt + l</td>
<td>调整代码格式</td>
</tr>
<tr>
<td>ctrl + F12</td>
<td>查看类结构(字段和方法)</td>
</tr>
<tr>
<td>ctrl + h</td>
<td>查看类继承关系</td>
</tr>
<tr>
<td>shift + F6</td>
<td>重命名文件</td>
</tr>
<tr>
<td>shift + F9</td>
<td>Debug启动项目</td>
</tr>
<tr>
<td>ctrl + t</td>
<td>【个人习惯】CodeIf命名插件</td>
</tr>
<tr>
<td>F8</td>
<td>代码向下执行一行</td>
</tr>
<tr>
<td>F7</td>
<td>进入到某个方法内部，F8向下执行可跳出</td>
</tr>
<tr>
<td>F9</td>
<td>执行到下一个断点或执行到底</td>
</tr>
<tr>
<td>alt + F8</td>
<td>断点调试时查看某行代码数据</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Windows</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>尚医通学习总结</title>
    <url>/posts/943f.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="尚医通学习总结"><a href="#尚医通学习总结" class="headerlink" title="尚医通学习总结"></a>尚医通学习总结</h1><p>尚医通完结撒花！</p>
<p>视频来自<a href="https://www.bilibili.com/video/BV1V5411K7rT">Java微服务+分布式+全栈项目【尚医通】</a></p>
<span id="more"></span>

<h2 id="1-项目总结"><a href="#1-项目总结" class="headerlink" title="1 项目总结"></a>1 项目总结</h2><h3 id="1-1-项目功能总结-后台管理系统"><a href="#1-1-项目功能总结-后台管理系统" class="headerlink" title="1.1 项目功能总结(后台管理系统)"></a>1.1 项目功能总结(后台管理系统)</h3><p>1、医院设置管理</p>
<ul>
<li><p>医院设置列表、添加、锁定、删除  </p>
</li>
<li><p>医院列表、详情、排班、下线     </p>
</li>
</ul>
<p>2、数据管理</p>
<ul>
<li>数据字典树形显示、导入、导出 </li>
</ul>
<p>3、用户管理  </p>
<ul>
<li><p>用户列表、查看、锁定  </p>
</li>
<li><p>认证用户审批 </p>
</li>
</ul>
<p>4、订单管理  </p>
<ul>
<li>订单列表、详情     </li>
</ul>
<p>5、统计管理  </p>
<ul>
<li>预约统计  </li>
</ul>
<h3 id="1-2-项目功能总结-前台用户系统"><a href="#1-2-项目功能总结-前台用户系统" class="headerlink" title="1.2 项目功能总结(前台用户系统)"></a>1.2 项目功能总结(前台用户系统)</h3><p>1、首页数据显示</p>
<ul>
<li>医院列表</li>
</ul>
<p> 2、医院详情显示</p>
<ul>
<li>医院科室显示</li>
</ul>
<p> 3、用户登录功能</p>
<ul>
<li><p>手机号登录（短信验证码发送）</p>
</li>
<li><p>微信扫描登录</p>
</li>
</ul>
<p>4、用户实名认证</p>
<p>5、就诊人管理</p>
<ul>
<li>列表、添加、详情、删除</li>
</ul>
<p> 6、预约挂号功能</p>
<ul>
<li><p>排班和挂号详情信息</p>
</li>
<li><p>确认挂号信息</p>
</li>
<li><p>生成预约挂号订单</p>
</li>
<li><p>挂号订单支付（微信）</p>
</li>
<li><p>取消预约订单</p>
</li>
</ul>
<p>7、就医提醒功能</p>
<h3 id="1-3-项目技术点总结-后端技术"><a href="#1-3-项目技术点总结-后端技术" class="headerlink" title="1.3 项目技术点总结(后端技术)"></a>1.3 项目技术点总结(后端技术)</h3><p>1、SpringBoot</p>
<p>2、SpringCloud</p>
<ul>
<li><p>Nacos注册中心</p>
</li>
<li><p>Feign</p>
</li>
<li><p>GateWay</p>
</li>
</ul>
<p>3、Redis</p>
<ul>
<li><p>使用Redis作为缓存</p>
</li>
<li><p>验证码有效时间、支付二维码有效时间</p>
</li>
</ul>
<p>4、MongoDB</p>
<ul>
<li>使用MongoDB存储 医院相关数据</li>
</ul>
<p>5、EasyExcel</p>
<ul>
<li>操作excel表格，进行读和写操作</li>
</ul>
<p>6、MyBatisPlus</p>
<p>7、RabbitMQ</p>
<ul>
<li>订单相关操作，发送mq消息</li>
</ul>
<p>8、Docker</p>
<ul>
<li><p>下载镜像 docker pull </p>
</li>
<li><p>创建容器 docker run</p>
</li>
</ul>
<p>9、阿里云OSS</p>
<p>10、阿里云短信服务</p>
<p>11、微信登录/支付</p>
<p>12、定时任务</p>
<h3 id="1-4-项目技术点总结-前端技术"><a href="#1-4-项目技术点总结-前端技术" class="headerlink" title="1.4 项目技术点总结(前端技术)"></a>1.4 项目技术点总结(前端技术)</h3><p>1、vue</p>
<ul>
<li>指令</li>
</ul>
<p>2、Element-ui</p>
<p>3、nuxt</p>
<p>4、npm </p>
<p>5、ECharts</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>尚医通</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/posts/437.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>开始操作系统的学习吧！</p>
<span id="more"></span>

<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-操作系统的历史"><a href="#1-操作系统的历史" class="headerlink" title="1.操作系统的历史"></a>1.操作系统的历史</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631762042600-e2d49f67-00b1-43b3-b6cd-0b44b6abfcd3.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=112&id=u6bbe1cc7&originHeight=223&originWidth=997&originalType=binary&ratio=1&size=116765&status=done&style=none&taskId=uee526110-6923-4fb9-821f-f6216031d3b&width=499" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631762148041-391b239d-5fa4-46be-a550-4797be4a9a07.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=138&id=ubc28b705&originHeight=275&originWidth=1002&originalType=binary&ratio=1&size=111350&status=done&style=none&taskId=u804df73a-e1d0-4eac-861b-90ed1fa9e82&width=501" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631762466208-4416576f-79b4-4011-83dd-80ea6c11980f.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=222&id=u313ed5ae&originHeight=443&originWidth=855&originalType=binary&ratio=1&size=241734&status=done&style=none&taskId=u8c6ec8e3-4131-4cd6-a545-25036476039&width=428" alt="image.png"></p>
<h2 id="2-应用眼中的操作系统"><a href="#2-应用眼中的操作系统" class="headerlink" title="2.应用眼中的操作系统"></a>2.应用眼中的操作系统</h2><p>什么是程序？<br>可执行的二进制文件</p>
<p>什么是软件？<br>按照特定顺序组织的计算机数据和指令的集合</p>
<p>线程崩溃不会导致进程崩溃。一个进程可以有多个线程<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631763096878-c87f48d3-7373-4d5a-9efd-53130ad898bb.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=268&id=ue3e8b29e&originHeight=536&originWidth=996&originalType=binary&ratio=1&size=168570&status=done&style=none&taskId=ud61b0e7f-d421-43c0-b7ba-c098d001225&width=498" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631771650693-fc5af4b2-c672-4525-945c-d1859458140a.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=328&id=u106f1694&originHeight=655&originWidth=978&originalType=binary&ratio=1&size=369803&status=done&style=none&taskId=u8bbf06f3-1a3c-4359-868d-eb855b23296&width=489" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631772179790-7d68bdd3-41bc-4904-8898-dc27e8e9c448.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=201&id=u0535f9d1&originHeight=402&originWidth=1000&originalType=binary&ratio=1&size=150185&status=done&style=none&taskId=uda816a36-940b-4f0a-8ca3-6e74f9931f2&width=500" alt="image.png"><br>gcc  将源代码程序编译成二进制程序</p>
<p>strace命令是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631772946401-c27460cc-2d64-4bb8-bf25-45fd6a7af47e.png#clientId=u9d6e65e6-f1f8-4&from=paste&id=u6b0837c5&originHeight=240&originWidth=570&originalType=binary&ratio=1&size=159266&status=done&style=none&taskId=ucbf080fb-7d69-405f-a3e8-5879bf8262d" alt="image.png"></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1.并发与并行"></a>1.并发与并行</h2><p>并发(Concurrency)：有些事情可以同时发生，这个事情就是并发的<br>每隔一定时间，就切换到另一个进程执行(看起来进程好像是同时执行的)<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631774208483-d770848b-b372-4161-9e63-d94f5969aed6.png#clientId=u9d6e65e6-f1f8-4&from=paste&height=293&id=ue2a70221&originHeight=390&originWidth=950&originalType=binary&ratio=1&size=192528&status=done&style=none&taskId=ua842a16a-1403-428c-84a3-f48ddc97e08&width=713" alt="image.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构打卡</title>
    <url>/posts/518a.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><p>算法与数据结构需要日常积累</p>
<p><strong>刷题小技巧：</strong></p>
<p>数据结构 + 算法，以类型去leetcode刷题</p>
<p>推荐github算法教程：代码随想录</p>
<span id="more"></span>

<h2 id="一、leetcode刷题"><a href="#一、leetcode刷题" class="headerlink" title="一、leetcode刷题"></a>一、leetcode刷题</h2><h3 id="2023-12-15"><a href="#2023-12-15" class="headerlink" title="2023.12.15"></a>2023.12.15</h3><p>时间复杂度O(n)指的是最坏的情况</p>
<p>算法的logn，忽略底数</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776240-d8b6d71e-99b0-4ede-b5bf-8ae897d793b1.png"></p>
<h3 id="2023-12-16"><a href="#2023-12-16" class="headerlink" title="2023.12.16"></a>2023.12.16</h3><p>空间复杂度O(n)，当消耗空间随着输入参数n随线性增长</p>
<p>计算机一般会有内存对齐的策略，提高效率</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776176-0851acef-7705-4a77-899a-eea6d7b277c1.png"></p>
<h3 id="2023-12-17"><a href="#2023-12-17" class="headerlink" title="2023.12.17"></a>2023.12.17</h3><p>二分查找：左闭右闭 注意边界</p>
<p>移除元素：快慢指针</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776169-f3d43a35-91bd-4cce-a3a1-f68bc6764015.png"></p>
<h3 id="2023-12-19"><a href="#2023-12-19" class="headerlink" title="2023.12.19"></a>2023.12.19</h3><p>有序数组的平方：左右指针</p>
<p>长度最小的子数组：滑动窗口，也是两个指针</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776396-ef82a965-0635-4ca6-af30-1cf5bcccf046.png"></p>
<h3 id="2023-12-20"><a href="#2023-12-20" class="headerlink" title="2023.12.20"></a>2023.12.20</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776411-c6952616-3fa0-4ab2-bbe4-53be64b898fa.png"></p>
<h3 id="2023-12-21"><a href="#2023-12-21" class="headerlink" title="2023.12.21"></a>2023.12.21</h3><p>快速判断一个元素是否出现在集合里，使用哈希法</p>
<h3 id="2023-12-24"><a href="#2023-12-24" class="headerlink" title="2023.12.24"></a>2023.12.24</h3><p>两个字符char，ASCII值相加减</p>
<img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776433-23a7d485-8b9a-462e-8b23-0334a605d81e.png" style="zoom: 67%;" />



<p>链表  统一的逻辑 虚拟头节点</p>
<p>链表最后指向null</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776435-990f8acb-0d28-49df-8e67-81e5119caa65.png"></p>
<h3 id="2023-12-25"><a href="#2023-12-25" class="headerlink" title="2023.12.25"></a>2023.12.25</h3><p>设计链表</p>
<h3 id="2023-12-26"><a href="#2023-12-26" class="headerlink" title="2023.12.26"></a>2023.12.26</h3><p>设计链表</p>
<p>类里面有成员变量，构造函数</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776454-86c89063-5723-4a5c-b833-3b80c6c26d6e.png"></p>
<p>dummy 虚拟的</p>
<p>pre cur temp  变量取名</p>
<p>链表的最后一个节点指向空节点</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776645-6e30cccc-7eb4-4774-a06d-dbe3274901da.png"></p>
<h3 id="2023-12-29"><a href="#2023-12-29" class="headerlink" title="2023.12.29"></a>2023.12.29</h3><p>虚拟头节点的使用 ListNode dummy = new ListNode(-1);</p>
<p>链表反转使用双指针法</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776664-fdfd4d81-c016-4d9f-bbe4-bb10d9e2cd11.png"></p>
<p>找环的入口：快慢指针相遇点和head的相遇点，就是环的入口</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776688-aab63601-b896-4a38-affb-fa9b9fa9e7ed.png"></p>
<h3 id="2023-12-31"><a href="#2023-12-31" class="headerlink" title="2023.12.31"></a>2023.12.31</h3><p>数组 length</p>
<p>字符串 length()</p>
<p>for循环内还有for，就要用j，按i、j、k顺序使用</p>
<p>首先是对数组循环，然后是对字符串循环</p>
<p>list set 是contains</p>
<p>map是containsKey</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776693-16e28ab3-ce57-4f3b-a7d3-7e886f05f842.png"></p>
<h3 id="2024-1-2"><a href="#2024-1-2" class="headerlink" title="2024.1.2"></a>2024.1.2</h3><p>字符串的方法都是加()的，数组的length没有()</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776702-bbcc52ad-f6be-4a2e-8812-3b8f97324c58.png"></p>
<h3 id="2024-1-3"><a href="#2024-1-3" class="headerlink" title="2024.1.3"></a>2024.1.3</h3><p>反转字符串(双指针法)</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776877-02a2c358-7fb0-4138-b96b-5010bcdb0b90.png"></p>
<h3 id="2024-1-4"><a href="#2024-1-4" class="headerlink" title="2024.1.4"></a>2024.1.4</h3><p>KMP算法 字符串匹配</p>
<h3 id="2024-1-6"><a href="#2024-1-6" class="headerlink" title="2024.1.6"></a>2024.1.6</h3><p>文本串和模式串</p>
<p>KMP 适用于字符串查找</p>
<p><strong>双指针法的复习</strong></p>
<p>l  r   fast  slow</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776883-2695eab4-feec-4c86-b112-703768cd07b4.png"></p>
<h3 id="2024-1-7"><a href="#2024-1-7" class="headerlink" title="2024.1.7"></a>2024.1.7</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776924-612c736e-679d-4a75-b43c-5f272a0ebe99.png"></p>
<h3 id="2024-1-8"><a href="#2024-1-8" class="headerlink" title="2024.1.8"></a>2024.1.8</h3><p>双指针 l  r    slow   fast</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776926-67c8449b-db5a-49fe-b6d8-8a7bac00a5e6.png"></p>
<h3 id="2024-1-9"><a href="#2024-1-9" class="headerlink" title="2024.1.9"></a>2024.1.9</h3><p>栈与队列</p>
<p>队列  先进先出</p>
<p>栈  后进先出</p>
<p>构造函数：初始化类中的成员变量</p>
<p>栈  push  把值压入栈   pop移除栈顶元素并返回     peek返回栈顶元素</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198776946-662c4329-7c6b-4fdd-824c-ae7307378c14.png"></p>
<h3 id="2024-1-10"><a href="#2024-1-10" class="headerlink" title="2024.1.10"></a>2024.1.10</h3><p>deque  双向队列   Deque deque = new LinkedList();   push()   pop()</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198777117-b0efabfd-7d42-4fae-8af7-ed390a13d66c.png"></p>
<h3 id="2024-1-12"><a href="#2024-1-12" class="headerlink" title="2024.1.12"></a>2024.1.12</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198777154-f10e2dd5-591d-4078-aee0-20bf18d47efc.png"></p>
<h3 id="2024-1-13"><a href="#2024-1-13" class="headerlink" title="2024.1.13"></a>2024.1.13</h3><p>二叉树的遍历  前序  中序   后序</p>
<p>二叉树的递归遍历(简单一些)</p>
<p><strong>二叉树的迭代遍历</strong> 用栈实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历，也可以使用递归的方式</p>
<p>翻转二叉树</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705198777163-94ba6149-05f5-42e7-978c-ed19a13da90f.png"></p>
<h3 id="2024-1-14"><a href="#2024-1-14" class="headerlink" title="2024.1.14"></a>2024.1.14</h3><p>二叉树的递归和回溯</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705233742180-57623daa-5cc8-451f-aa5e-096aac74053a.png"></p>
<h3 id="2024-1-15"><a href="#2024-1-15" class="headerlink" title="2024.1.15"></a>2024.1.15</h3><p>相同的树-递归代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  public boolean compare(TreeNode tree1, TreeNode tree2) &#123;</span><br><span class="line">     </span><br><span class="line">      if(tree1==null &amp;&amp; tree2==null)return true;</span><br><span class="line">      if(tree1==null || tree2==null)return false;</span><br><span class="line">      if(tree1.val!=tree2.val)return false;</span><br><span class="line">      // 此时就是：左右节点都不为空，且数值相同的情况</span><br><span class="line">      // 此时才做递归，做下一层的判断</span><br><span class="line">      boolean compareLeft = compare(tree1.left, tree2.left);       // 左子树：左、 右子树：左</span><br><span class="line">      boolean compareRight = compare(tree1.right, tree2.right);    // 左子树：右、 右子树：右</span><br><span class="line">      boolean isSame = compareLeft &amp;&amp; compareRight;                  // 左子树：中、 右子树：中（逻辑处理）</span><br><span class="line">      return isSame;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">      return compare(p, q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树题目大部分使用递归法可以解决</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705330484104-65946514-bd27-4933-8573-359faa23bc3b.png"></p>
<h3 id="2024-1-16"><a href="#2024-1-16" class="headerlink" title="2024.1.16"></a>2024.1.16</h3><p>二叉树 递归</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705417956007-324f23ab-79b1-4572-9d37-b899700460bc.png"></p>
<h3 id="2024-1-17"><a href="#2024-1-17" class="headerlink" title="2024.1.17"></a>2024.1.17</h3><p>二叉搜索树 左边节点比根节点小  右边节点比根节点大</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705502015294-0d1a2c28-8d51-4bcb-ad9d-3f3070f61159.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705502816201-53dcfa5a-77ee-4ea9-8f7e-6f98fee285bb.png"></p>
<h3 id="2024-1-18"><a href="#2024-1-18" class="headerlink" title="2024.1.18"></a>2024.1.18</h3><p>回溯算法</p>
<p>回溯是递归的副产品，只要有递归就会有回溯</p>
<p><strong>如何理解回溯法？</strong></p>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模板：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705588552399-010cb2d2-a541-494b-959d-3b9044f9aecc.png"></p>
<p><img data-src="C:\Users\zhongdawei\AppData\Roaming\Typora\typora-user-images\image-20240118223658556.png"></p>
<h3 id="2024-1-19"><a href="#2024-1-19" class="headerlink" title="2024.1.19"></a>2024.1.19</h3><p>回溯集合一般用的是LinkedList   removeLast()方法移除集合最后的元素</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705672841590-b4db2aa8-937b-4f49-8e3d-0ca2dbae225a.png"></p>
<h3 id="2024-1-20"><a href="#2024-1-20" class="headerlink" title="2024.1.20"></a>2024.1.20</h3><p><img data-src="C:\Users\zhongdawei\AppData\Roaming\Typora\typora-user-images\image-20240120155920746.png" alt="image-20240120155920746"></p>
<h3 id="2024-1-21"><a href="#2024-1-21" class="headerlink" title="2024.1.21"></a>2024.1.21</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705923933776-0e60e118-a0be-405b-a740-93e9df5ebc96.png"></p>
<p>void backTracking(){</p>
<p>​    横向 for</p>
<p>​    纵向 递归</p>
<p>}</p>
<h3 id="2024-1-22"><a href="#2024-1-22" class="headerlink" title="2024.1.22"></a>2024.1.22</h3><p>贪心算法：局部最优推出全局最优   大部分使用for循环比较最优解</p>
<p><img data-src="C:\Users\zhongdawei\AppData\Roaming\Typora\typora-user-images\image-20240122220801541.png"></p>
<h3 id="2024-1-23"><a href="#2024-1-23" class="headerlink" title="2024.1.23"></a>2024.1.23</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706018013044-9a5e5944-5eef-4ff1-8f90-832dcf01444c.png"></p>
<h3 id="2024-1-24"><a href="#2024-1-24" class="headerlink" title="2024.1.24"></a>2024.1.24</h3><p>贪心算法：寻找最优解</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706104149852-68642ff5-203a-42e5-86a1-27c433dd09a5.png"></p>
<h3 id="2024-1-25"><a href="#2024-1-25" class="headerlink" title="2024.1.25"></a>2024.1.25</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706198138298-f1347e21-f4af-40a6-84d6-be2986acb63c.png"></p>
<h3 id="2024-1-26"><a href="#2024-1-26" class="headerlink" title="2024.1.26"></a>2024.1.26</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706275083056-45e90e48-fa10-4ba9-a44a-1574cae16663.png"></p>
<h3 id="2024-1-27"><a href="#2024-1-27" class="headerlink" title="2024.1.27"></a>2024.1.27</h3><p>动态规划从上一个状态推导而来，贪心局部直接选最优的</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706410570096-ee03217c-2b9d-4b04-a257-b390a2edbef9.png"></p>
<h3 id="2024-1-28"><a href="#2024-1-28" class="headerlink" title="2024.1.28"></a>2024.1.28</h3><p>动态规划：</p>
<p>第三层楼梯的状态可以由第二层和第一层楼梯推导出来，可以想到动态规划</p>
<p><strong>动态规划数组为dp</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706429570522-3c8eed02-a66b-4e02-9976-47926067c52e.png"></p>
<h3 id="2024-1-29"><a href="#2024-1-29" class="headerlink" title="2024.1.29"></a>2024.1.29</h3><p>背包问题：01背包和完全背包</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706543709015-f058533b-2627-4053-808d-1f4119729b61.png"></p>
<h3 id="2024-1-30"><a href="#2024-1-30" class="headerlink" title="2024.1.30"></a>2024.1.30</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706629902835-c2c70b41-1e9d-4de5-a4d7-b12324d86eda.png"></p>
<h3 id="2024-1-31"><a href="#2024-1-31" class="headerlink" title="2024.1.31"></a>2024.1.31</h3><p>背包问题：两层for循环</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706714625754-dbd5a045-e029-4bd6-b50a-48cf8e67a363.png"></p>
<h3 id="2024-2-1"><a href="#2024-2-1" class="headerlink" title="2024.2.1"></a>2024.2.1</h3><p>背包问题：两个for循环</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706798394204-10fbcbd1-b9ca-4020-a7aa-0648c83a634d.png"></p>
<p><img data-src="C:\Users\zhongdawei\AppData\Roaming\Typora\typora-user-images\image-20240201224024975.png"></p>
<h3 id="2024-2-3"><a href="#2024-2-3" class="headerlink" title="2024.2.3"></a>2024.2.3</h3><p>动态规划：dp数组</p>
<p><strong>当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706933384034-f50cbf0a-2ee7-4a6f-a626-0897965c47d7.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706934108985-b20ddf4a-93c1-45c1-89b5-35ba72334533.png"></p>
<h3 id="2024-2-4"><a href="#2024-2-4" class="headerlink" title="2024.2.4"></a>2024.2.4</h3><p>股票系列</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707048979666-2999dda9-2b37-4e93-9f94-ccf9ff48a6d5.png"></p>
<h3 id="2024-2-5"><a href="#2024-2-5" class="headerlink" title="2024.2.5"></a>2024.2.5</h3><p>股票系列</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707148260679-644ae789-e65a-4eb4-820d-68258f1f9996.png"></p>
<h3 id="2024-2-7"><a href="#2024-2-7" class="headerlink" title="2024.2.7"></a>2024.2.7</h3><p>子序列系列</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707313568114-794b50c7-5311-4c27-b254-5337ee4eb35f.png?x-oss-process=image/resize,w_633,limit_0"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707315093507-56042e8f-9e2d-48b1-b28e-cf95a3855753.png"></p>
<h3 id="2024-2-8"><a href="#2024-2-8" class="headerlink" title="2024.2.8"></a>2024.2.8</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707366419324-d0b15c07-037a-44d6-a385-f279348aa05f.png"></p>
<h3 id="2024-2-9"><a href="#2024-2-9" class="headerlink" title="2024.2.9"></a>2024.2.9</h3><p>动规5部曲</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707478366046-4be43788-94a9-493a-ab08-a5cac7a57c88.png"></p>
<h3 id="2024-2-10"><a href="#2024-2-10" class="headerlink" title="2024.2.10"></a>2024.2.10</h3><p>单调栈</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1707567611824-ee46e681-4c5d-4643-8e5a-a340a362dc89.png"></p>
<h2 id="二、内功修炼：图解数据结构-小傅哥"><a href="#二、内功修炼：图解数据结构-小傅哥" class="headerlink" title="二、内功修炼：图解数据结构(小傅哥)"></a>二、内功修炼：图解数据结构(小傅哥)</h2><h3 id="第一章-链表"><a href="#第一章-链表" class="headerlink" title="第一章 链表"></a>第一章 链表</h3><p>链表、双向链表、循环链表</p>
<p>prev  next</p>
<p>LinkedList  底层是双向链表  查询慢增删快</p>
<h3 id="第二章-数组"><a href="#第二章-数组" class="headerlink" title="第二章 数组"></a>第二章 数组</h3><p>内存地址连续</p>
<p>ArrayList 底层是数组   初始值是10，每次1.5倍扩容</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705242442524-8da12caa-02f3-4fd3-8b3d-c5655fc1298e.png?x-oss-process=image/resize,w_937,limit_0"></p>
<p>扩容完成后，将旧的空间数组迁移到新的空间数组</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705243772991-965a5f40-d5ef-4469-8b72-11bec2d5d938.png"></p>
<h3 id="第三章-队列"><a href="#第三章-队列" class="headerlink" title="第三章 队列"></a>第三章 队列</h3><p>单端队列queue   双端队列deque</p>
<p>队列没有特定的容量，deque双端队列可以是LinkedList</p>
<p>PriorityQueue  优先队列</p>
<p>单端队列的实现类：</p>
<ul>
<li>PriorityQueue：非阻塞、非线程安全、无边界，支持优先级队列实现类。</li>
<li>ConcurrentLinkedQueue：非阻塞、线程安全、无边界，基于链接节点的队列实现类。</li>
<li>ArrayBlockingQueue：阻塞、线程安全、有边界，创建的时候指定大小，一旦创建容量不可改变实现类，默认是不保证线程的公平性，不允许向队列中插入null元素。</li>
<li>LinkedBlockingQueue：阻塞、线程安全、可选有边界，一个由链表结构组成的可选有界阻塞队列实现类，如果未指定容量，那么容量将等于Integer.MAX_VALUE。</li>
<li>PriorityBlockingQueue：阻塞、线程安全、无边界，支持优先级排序的无边界阻塞队列实现类。</li>
<li>DelayQueue：阻塞、线程安全、无边界，使用优先级队列实现的无界阻塞队列实现类，只有在延迟期满时才能从中提取元素。</li>
<li>SynchronousQueue：阻塞、线程安全、无数据队列，不存储元素、没有内部容量的阻塞队列实现类。</li>
</ul>
<h3 id="第四章-栈"><a href="#第四章-栈" class="headerlink" title="第四章 栈"></a>第四章 栈</h3><p>栈   push添加  pop弹出</p>
<p>后进先出</p>
<p>栈使用 ArrayDeque</p>
<h3 id="第五章-哈希表"><a href="#第五章-哈希表" class="headerlink" title="第五章 哈希表"></a>第五章 哈希表</h3><p>哈希散列 即HashMap</p>
<h3 id="第六章-堆"><a href="#第六章-堆" class="headerlink" title="第六章 堆"></a>第六章 堆</h3><p>小堆（根节点最小）  大堆（根节点最大）</p>
<p>MaxHeap heap = new MaxHeap()  堆</p>
<h3 id="第七章-字典树"><a href="#第七章-字典树" class="headerlink" title="第七章 字典树"></a>第七章 字典树</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705418031510-80bf0c09-0595-467f-b7e8-d23a09816512.png?x-oss-process=image/resize,w_750,limit_0"></p>
<p><strong>字典树的核心功能：</strong>把所有以ba开头的单词全部检索出来了</p>
<h3 id="第八章-二分搜索树"><a href="#第八章-二分搜索树" class="headerlink" title="第八章 二分搜索树"></a>第八章 二分搜索树</h3><p>二叉搜索树：右边的值比根节点大，左边的值比根节点小</p>
<h3 id="第九章-平衡二叉树-AVL-Tree"><a href="#第九章-平衡二叉树-AVL-Tree" class="headerlink" title="第九章 平衡二叉树 AVL Tree"></a>第九章 平衡二叉树 AVL Tree</h3><p>左旋、右旋、左旋+右旋、右旋+左旋</p>
<h3 id="第十章-2-3树"><a href="#第十章-2-3树" class="headerlink" title="第十章 2-3树"></a>第十章 2-3树</h3><p>2-3树靠旋转调整树高</p>
<h3 id="第十一章-红黑树"><a href="#第十一章-红黑树" class="headerlink" title="第十一章 红黑树"></a>第十一章 红黑树</h3><p>红黑树是一种自平衡二叉查找树</p>
<p> 红黑树和2-3树的关系：</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705504775671-4c46de32-bbd5-464f-b0f0-9a75bb2d292f.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705504849386-4c62b68e-1ce4-43d7-bb87-43d609995cc2.png?x-oss-process=image/resize,w_937,limit_0"></p>
<h3 id="第十二章-并查集-Disjoint-Set"><a href="#第十二章-并查集-Disjoint-Set" class="headerlink" title="第十二章 并查集 Disjoint-Set"></a>第十二章 并查集 Disjoint-Set</h3><p>什么是并查集？</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705505890247-491b4ced-3522-43fa-8e32-ec9a40a1f669.png?x-oss-process=image/resize,w_937,limit_0"></p>
<h3 id="第十三章-图"><a href="#第十三章-图" class="headerlink" title="第十三章 图"></a>第十三章 图</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705505984831-7ff5a897-f1db-497e-8b2a-76c7c30b4b56.png?x-oss-process=image/resize,w_937,limit_0"></p>
<h3 id="第十四章-布隆过滤器"><a href="#第十四章-布隆过滤器" class="headerlink" title="第十四章 布隆过滤器"></a>第十四章 布隆过滤器</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705506064056-d1f25f14-2dc6-4097-b5e6-f5d838d29e9d.png?x-oss-process=image/resize,w_937,limit_0"></p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>算法与数据结构打卡</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/posts/cacd.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>开始计算机组成原理的学习吧！！</p>
<span id="more"></span>

<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="1-计算机系统简介"><a href="#1-计算机系统简介" class="headerlink" title="1.计算机系统简介"></a>1.计算机系统简介</h2><p>HPC：高性能计算机群<br>计算机由硬件和软件组成<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631781628372-040630b2-a641-409c-9ac0-21e83445b5e3.png#clientId=ud9f9782b-2e4f-4&from=paste&height=177&id=ua543fe92&originHeight=706&originWidth=1264&originalType=binary&ratio=1&size=269372&status=done&style=none&taskId=u069bf526-87fd-4c29-b9f9-40b1aea24dd&width=316"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631782127621-346f7342-cffe-4baa-a4f1-ed7a6532735d.png#clientId=ud9f9782b-2e4f-4&from=paste&height=218&id=u1ddcb29d&originHeight=872&originWidth=1201&originalType=binary&ratio=1&size=415716&status=done&style=none&taskId=uab33536c-a790-43db-8e94-25f012dc442&width=300" alt="image.png"></p>
<h2 id="2-计算机的基本组成"><a href="#2-计算机的基本组成" class="headerlink" title="2.计算机的基本组成"></a>2.计算机的基本组成</h2><h3 id="2-1-冯·诺依曼计算机"><a href="#2-1-冯·诺依曼计算机" class="headerlink" title="2.1 冯·诺依曼计算机"></a>2.1 冯·诺依曼计算机</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631782474528-7b067055-ac71-4b99-a5f0-21978425f5e6.png#clientId=ud9f9782b-2e4f-4&from=paste&height=199&id=uf4f391db&originHeight=795&originWidth=1020&originalType=binary&ratio=1&size=285921&status=done&style=none&taskId=u6cc4de53-a395-480c-b91b-2ec16aa8cdc&width=255"><br>五大组成部件是控制器、运算器、存储器、输入设备、输出设备<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631784125782-e2de40cd-c269-44c2-9932-b7d23f20d536.png#clientId=ud9f9782b-2e4f-4&from=paste&height=156&id=u6d9b2355&originHeight=624&originWidth=1245&originalType=binary&ratio=1&size=254712&status=done&style=none&taskId=ueaa803a8-0bef-4bc3-84ee-784dcb22b95&width=311"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631784248047-44113d2b-60f3-419a-ba62-32eff68c9581.png#clientId=ud9f9782b-2e4f-4&from=paste&height=123&id=ue8843a6f&originHeight=492&originWidth=1001&originalType=binary&ratio=1&size=151418&status=done&style=none&taskId=ue6e61c89-8a60-44aa-ae27-2af221bdf2e&width=250" alt="image.png"></p>
<h3 id="2-2-计算机的基本组成"><a href="#2-2-计算机的基本组成" class="headerlink" title="2.2 计算机的基本组成"></a>2.2 计算机的基本组成</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631871272938-04d4e94f-99f8-4bfe-9d20-5168bc751628.png#clientId=ub55dff59-a647-4&from=paste&height=208&id=u6423c1c2&originHeight=834&originWidth=1089&originalType=binary&ratio=1&size=342974&status=done&style=none&taskId=u8596467e-3e1d-4886-910f-a148bb23bbe&width=272"><br>第二种方式运算速度更快<br>指令和数据都是存在存储器中的</p>
<h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存储体由许多存储单元组成，每个存储单元又包含若干个存储元件，每个存储元件可以寄存一位二进制代码0/1。</p>
<p>对于其组成我们可以这样来记忆：<br>存储体呢，相当于一栋大楼，大楼内有很多房间（存储单元），每个房间内又有很多床位（存储元件），那么0代表床上无人，1代表床上有人。</p>
<p>存储单元<br>以8位二进制作为一个存储单元，也就是一个字节。<br>一个存储单元可以存储一串二进制代码，称这串二进制代码为一个存储字，代码位数位存储字长。<br>存储单元有编号，这些编号称为存储单元的地址号。存储单元按地址寻访。这些地址都是二进制的形式。</p>
<h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>计算机中执行各种算术和逻辑运算操作的部件。运算器的基本操作包括加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部件</p>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>功能：解释指令、保证指令的按序执行<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631878090710-3fe8ff89-e17d-497a-a57a-7d9a88428b37.png#clientId=ub55dff59-a647-4&from=paste&height=316&id=ucd75eed1&originHeight=631&originWidth=813&originalType=binary&ratio=1&size=218782&status=done&style=none&taskId=u551584be-ac2e-4be1-965c-1985d2030de&width=407"><br>取指令：把指令的地址从存储体中取出来<br>分析指令：存放当前欲执行的指令<br>执行指令CU</p>
<h2 id="3-计算机硬件的主要技术指标"><a href="#3-计算机硬件的主要技术指标" class="headerlink" title="3.计算机硬件的主要技术指标"></a>3.计算机硬件的主要技术指标</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631879170915-27e38dcc-1aaa-4855-97a9-8d6ffad2a087.png#clientId=ub55dff59-a647-4&from=paste&height=198&id=u0fc65788&originHeight=791&originWidth=1315&originalType=binary&ratio=1&size=378781&status=done&style=none&taskId=ue72b0dbb-58fb-4b09-bf92-76f7ac6b39a&width=329"></p>
<h2 id="4-计算机的发展史"><a href="#4-计算机的发展史" class="headerlink" title="4.计算机的发展史"></a>4.计算机的发展史</h2><p> 现在计算机产生的驱动力是需求<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631879767178-f904c1c3-33e4-4b47-9ccb-46306e9f2b76.png#clientId=ub55dff59-a647-4&from=paste&height=230&id=uf64b0a6f&originHeight=918&originWidth=1270&originalType=binary&ratio=1&size=396766&status=done&style=none&taskId=udea35bad-07ad-44d0-8518-267a9e9a29e&width=318"><br>64位系统处理数据的效率比32位高</p>
<p>处理器的性能每隔两年翻一倍</p>
<p>机器语言–&gt;汇编语言–&gt;高级语言</p>
<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><p>总线是连接各个部件的信息传输线，是各个部件<strong>共享的传输介质</strong></p>
<h2 id="1-总线的结构"><a href="#1-总线的结构" class="headerlink" title="1.总线的结构"></a>1.总线的结构</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632711055263-ab6a534b-4fb5-4a51-b757-71c0e7ba763c.png#clientId=ue76f7e77-16dc-4&from=paste&height=199&id=ufd7e11ef&originHeight=795&originWidth=1311&originalType=binary&ratio=1&size=432548&status=done&style=none&taskId=ue55022b3-5d18-4dab-8ed0-ae8649e2307&width=328"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632711077133-65b357d8-8ee9-4363-83d8-be0bb8b7cd4d.png#clientId=ue76f7e77-16dc-4&from=paste&height=203&id=ud7acb09a&originHeight=810&originWidth=1222&originalType=binary&ratio=1&size=398435&status=done&style=none&taskId=u60b486a6-2d4c-462e-b87a-411c80f2e23&width=306"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632711138932-7465ae7b-805c-4952-b845-13fe82ef7ba3.png#clientId=ue76f7e77-16dc-4&from=paste&height=223&id=uae8f5c90&originHeight=893&originWidth=1367&originalType=binary&ratio=1&size=450614&status=done&style=none&taskId=u9e14de44-b9ed-4af2-9cff-ae27bb508ab&width=342"><br>双总线结构也可以是主存总线和I/O总线，两个总线进行分离</p>
<h2 id="2-总线的分类"><a href="#2-总线的分类" class="headerlink" title="2.总线的分类"></a>2.总线的分类</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632711315052-eb11dc4e-3bf6-454e-8157-bc842ca14ec5.png#clientId=ue76f7e77-16dc-4&from=paste&height=154&id=uc61c11d7&originHeight=615&originWidth=1260&originalType=binary&ratio=1&size=371277&status=done&style=none&taskId=u6d1f6935-89fc-4311-a2c8-c32088f07af&width=315"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632711326251-cd47f6cc-f007-4ed7-9e88-3ad9050bfe1e.png#clientId=ue76f7e77-16dc-4&from=paste&height=112&id=u7f011754&originHeight=450&originWidth=1145&originalType=binary&ratio=1&size=246611&status=done&style=none&taskId=u55a91a98-d053-47ae-9745-eb9104101c9&width=286"></p>
<h2 id="3-总线的性能指标"><a href="#3-总线的性能指标" class="headerlink" title="3.总线的性能指标"></a>3.总线的性能指标</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632712294289-ca079b1b-65e7-4a36-b7cb-43cbc043be27.png#clientId=ue76f7e77-16dc-4&from=paste&height=229&id=u65fc0a7c&originHeight=914&originWidth=1239&originalType=binary&ratio=1&size=459354&status=done&style=none&taskId=ua704759e-30d0-435a-9740-19c463b3bf4&width=310"></p>
<h2 id="4-总线标准"><a href="#4-总线标准" class="headerlink" title="4.总线标准"></a>4.总线标准</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632712356115-6744648f-4706-453f-850a-d375fc936544.png#clientId=ue76f7e77-16dc-4&from=paste&height=216&id=u2b60aae9&originHeight=862&originWidth=1290&originalType=binary&ratio=1&size=391398&status=done&style=none&taskId=u7dd6e294-731b-4283-9874-3fbe4fcc5e4&width=323"></p>
<h2 id="5-总线控制"><a href="#5-总线控制" class="headerlink" title="5.总线控制"></a>5.总线控制</h2><h3 id="5-1-总线判优控制"><a href="#5-1-总线判优控制" class="headerlink" title="5.1 总线判优控制"></a>5.1 总线判优控制</h3><p>主设备  对总线有控制权<br>从设备  响应从主设备发来的总线命令<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632712889062-e54908c5-11e3-4def-9618-9b2d1057a462.png#clientId=ue76f7e77-16dc-4&from=paste&height=164&id=u3d4d7918&originHeight=328&originWidth=1060&originalType=binary&ratio=1&size=102475&status=done&style=none&taskId=ubec23bf7-b9a5-4a8b-a505-16761dc572b&width=530"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632712915997-d312af1c-479f-4869-a1f8-92520a226192.png#clientId=ue76f7e77-16dc-4&from=paste&height=226&id=ud027ba07&originHeight=904&originWidth=1336&originalType=binary&ratio=1&size=339982&status=done&style=none&taskId=ue0eb66c4-bff5-4fb4-925b-16474df5486&width=334"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632726635511-d797dda8-c790-4195-8a41-baba879bc9f1.png#clientId=u2678fa93-e947-4&from=paste&height=197&id=u7be49d8e&originHeight=789&originWidth=1332&originalType=binary&ratio=1&size=425984&status=done&style=none&taskId=u986c044d-e339-41f0-89d8-db2db5b4999&width=333"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632737579318-6f145ad3-b616-4c25-937c-99a672853345.png#clientId=u2678fa93-e947-4&from=paste&height=226&id=u6ed9efa1&originHeight=905&originWidth=1216&originalType=binary&ratio=1&size=514309&status=done&style=none&taskId=u13450b1c-7c79-44d9-a9ab-372bc8bb853&width=304"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632737618221-1e28d638-2088-4e7a-b98c-2f4f6cf932e3.png#clientId=u2678fa93-e947-4&from=paste&height=172&id=u79340067&originHeight=687&originWidth=1120&originalType=binary&ratio=1&size=210945&status=done&style=none&taskId=u8fa9a04d-2950-4d29-9e04-35b62e7be92&width=280"></p>
<h1 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-存储器分类"><a href="#1-1-存储器分类" class="headerlink" title="1.1 存储器分类"></a>1.1 存储器分类</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632738447925-99db606f-4be2-4fdb-989e-2d11e88a9a0c.png#clientId=u2678fa93-e947-4&from=paste&height=203&id=uf0bb2ea0&originHeight=813&originWidth=1099&originalType=binary&ratio=1&size=217313&status=done&style=none&taskId=ue2480d2a-ebeb-4b86-9ee6-bd20cdf1199&width=275"></p>
<h3 id="1-2-存储器的层次结构"><a href="#1-2-存储器的层次结构" class="headerlink" title="1.2 存储器的层次结构"></a>1.2 存储器的层次结构</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632738401115-21f6ca51-0f83-4ffa-9b5e-00b5c6bb23b8.png#clientId=u2678fa93-e947-4&from=paste&height=186&id=uf16992d2&originHeight=743&originWidth=1353&originalType=binary&ratio=1&size=331943&status=done&style=none&taskId=ucb7623b0-7cb6-433f-9e81-11d9c5cbf73&width=338"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632797639839-2ee08861-acbc-42b3-a3c1-7d93d5e7948d.png#clientId=u3b5ad4b7-21d2-4&from=paste&height=239&id=u8f5d58ae&originHeight=957&originWidth=1353&originalType=binary&ratio=1&size=445559&status=done&style=none&taskId=u4b6de69e-899f-413f-8426-4b9006201bd&width=338"><br>缓存和主存之间的区别通常情况下，高速缓存均是依托于静态随机访问存储器（SRAM），而主存一般是依托于动态随机访问存储器（DRAM）</p>
<h2 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2.主存储器"></a>2.主存储器</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632823553558-e9fc6dac-7620-4651-93f9-268ffcbc5046.png#clientId=u2173fce3-fd34-4&from=paste&height=113&id=u3c32272e&originHeight=452&originWidth=800&originalType=binary&ratio=1&size=107642&status=done&style=none&taskId=ufb904efe-7bc3-4168-ac36-3541fed4664&width=200"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632823619887-2102d53d-7400-4a6c-8e97-b549abb252b5.png#clientId=u2173fce3-fd34-4&from=paste&height=196&id=u8a7bee1c&originHeight=782&originWidth=1195&originalType=binary&ratio=1&size=198840&status=done&style=none&taskId=uec3f8809-fd23-4ed1-926b-827c77cd00e&width=299"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632825435197-330630c7-0fb7-402f-bc4a-d412d4088ca1.png#clientId=u3b5ad4b7-21d2-4&from=paste&height=190&id=u925d63ee&originHeight=759&originWidth=1354&originalType=binary&ratio=1&size=350513&status=done&style=none&taskId=u993886fa-b085-4b7b-97ab-d720e2ac444&width=339"><br>12345678H   12代表高位，78代表低位</p>
<h2 id="3-半导体芯片"><a href="#3-半导体芯片" class="headerlink" title="3.半导体芯片"></a>3.半导体芯片</h2><p>2的十次方 = 1 k    k代表的是1024<br>1K有10条地址线，1M有20条地址线<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632826748753-5480df6f-e980-4291-b635-16e06bb904e9.png#clientId=u3b5ad4b7-21d2-4&from=paste&height=250&id=ueaae7f39&originHeight=999&originWidth=1106&originalType=binary&ratio=1&size=247202&status=done&style=none&taskId=u377ff34b-5fd4-4e2a-b8f5-306785e625c&width=277"></p>
<h3 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h3><p>动态RAM会周期性的刷新，静态RAM不进行刷新<br>1、静态RAM，指SRAM：只要有供电，它保存的数据就不会丢失，且为高速存储器，如<strong>CPU中的高速缓存</strong>（cache）<br>2、动态RAM，指DRAM：有供电，还要根据它要求的刷新时间参数，才能保持存储的数据不丢失，如<strong>电脑中的内存条</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632828037967-647d62ed-4c50-45be-a905-e79f58e5c5d5.png#clientId=u3b5ad4b7-21d2-4&from=paste&height=252&id=u40ae86e5&originHeight=1007&originWidth=1384&originalType=binary&ratio=1&size=479381&status=done&style=none&taskId=u94b0f280-64fd-4cdc-a3ea-c3afe50e5a5&width=346"><br>分为64行，64列，64列被分为4组，如图所示<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632989882476-04cab272-e994-46a7-901a-79a7f90cb0bc.png#clientId=uf5d5275e-3279-4&from=paste&height=243&id=u650c8f83&originHeight=970&originWidth=1306&originalType=binary&ratio=1&size=366437&status=done&style=none&taskId=ub121fdd6-a49b-4970-aa1c-a37979e079c&width=327"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1632991300733-2013a8a1-781b-445e-9532-532c861f8821.png#clientId=uf5d5275e-3279-4&from=paste&height=184&id=ufd6be6e3&originHeight=733&originWidth=810&originalType=binary&ratio=1&size=277552&status=done&style=none&taskId=u87658f23-fd83-4deb-a3da-ab6d8c47117&width=203"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>读书计划打卡</title>
    <url>/posts/602.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="读书计划打卡"><a href="#读书计划打卡" class="headerlink" title="读书计划打卡"></a>读书计划打卡</h1><p>记录一些自己读过的书~</p>
<span id="more"></span>

<h3 id="1、《奔跑吧程序员》"><a href="#1、《奔跑吧程序员》" class="headerlink" title="1、《奔跑吧程序员》"></a>1、《奔跑吧程序员》</h3><p>P1-113</p>
<h3 id="2、《练好口才的第一本书》"><a href="#2、《练好口才的第一本书》" class="headerlink" title="2、《练好口才的第一本书》"></a>2、《练好口才的第一本书》</h3><p>P1-5</p>
<p>P5-9</p>
<p>P9-11</p>
<p>P11-16</p>
<p>P16-31</p>
<p>P31-45</p>
<p>P45-51</p>
]]></content>
      <categories>
        <category>打卡</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城学习总结</title>
    <url>/posts/7f37.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="谷粒商城学习总结"><a href="#谷粒商城学习总结" class="headerlink" title="谷粒商城学习总结"></a>谷粒商城学习总结</h1><p>第一遍学习完结撒花，第一遍主要是熟悉整个项目背景。</p>
<p>第二遍打算结合视频独立完成，熟悉项目的整体设计、优秀业务代码的编写，并输出学习笔记。</p>
<p>​<span id="more"></span></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>谷粒商城</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/posts/251e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>关于SpringBoot的学习笔记，视频来自<a href="https://www.bilibili.com/video/BV19K4y1L7MT">雷丰阳SpringBoot2021</a><br>​<span id="more"></span></p>
<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><h2 id="1-SpringBoot概述"><a href="#1-SpringBoot概述" class="headerlink" title="1.SpringBoot概述"></a>1.SpringBoot概述</h2><p>SpringBoot的底层是SpringFramework<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722254166-192baa58-942d-41b5-92e3-cc7acf733dd5.png?x-oss-process=image%2Fresize%2Cw_944%2Climit_0" /></p>
<p>什么是适配器模式？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630053630809-2d294113-d2e1-40cf-884b-a2b16b9260f2.png#clientId=u8f909344-f80e-4&from=paste&id=u6b36a10c&margin=%5Bobject%20Object%5D&name=&originHeight=435&originWidth=1232&originalType=binary&ratio=1&size=72081&status=done&style=none&taskId=ue9520550-6872-489a-b200-5943e2f77d4"></p>
<h3 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722198135-24ff3779-1baa-4579-ad00-b4ccecf08354.png"></p>
<p>微服务将一大应用拆分成小模块，每个小模块都可以独立部署到服务器上<br>微服务拆分后会出现分布式问题，这时候就使用<strong>SpringBoot + SpringCloud</strong>的解决方案<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722217507-9393c5ce-c52f-4a69-a1cb-1d827dafccfe.png" /></p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>场景启动器的基础是<strong>spring-boot-starter</strong>，它包含许多其他依赖，这些依赖定义了版本，因此你要引入这些依赖可以不用定义版本信息。如果是非其他依赖，需要定义版本信息<br>​</p>
<p>springboot的application启动类就是一个IOC，配置好了许多组件，如支持Spring MVC的多个组件等</p>
<p>包扫描：application所在的包自动扫描容器<br>想要改变扫描路径，@SpringBootApplication(scanBasePackages=”com.atguigu”)<br>​</p>
<h3 id="组件添加【底层注解】"><a href="#组件添加【底层注解】" class="headerlink" title="组件添加【底层注解】"></a>组件添加【底层注解】</h3><p>@proxyBeanMethods：代理bean的方法<br>Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】<br>Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】<br>​</p>
<p>@Import({User.class, DBHelper.class})<br>给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名<br>条件装配：满足@Conditional指定的条件，则进行组件注入<br>​</p>
<p>@ImportResource支持导入Spring的配置文件<br>​</p>
<p>JavaBean和配置文件中的属性绑定<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630064355478-850a8ddc-fb35-4e7e-a105-204476fc0805.png#clientId=u8f909344-f80e-4&from=paste&height=51&id=u66b02441&margin=%5Bobject%20Object%5D&name=&originHeight=102&originWidth=573&originalType=binary&ratio=1&size=55574&status=done&style=none&taskId=uf0111ee4-cb85-49b3-ba03-485639cd997&width=286.5"><br>@Component注解表示该类是一个组件类<br>​</p>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>SpringBoot启动默认加载所有的自动配置项，按照条件装配最终会被按需加载<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630132928220-0f42cc99-ab93-48f2-a013-7dfb7d6951c4.png#clientId=uc2d51021-934b-4&from=paste&height=159&id=u525869c2&margin=%5Bobject%20Object%5D&name=&originHeight=318&originWidth=1079&originalType=binary&ratio=1&size=189217&status=done&style=none&taskId=u7a1a2575-3299-40b7-b167-ccadc0aa133&width=539.5"></p>
<h2 id="2-开发小技巧"><a href="#2-开发小技巧" class="headerlink" title="2.开发小技巧"></a>2.开发小技巧</h2><h3 id="1-Lombok"><a href="#1-Lombok" class="headerlink" title="1 Lombok"></a>1 Lombok</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NoArgsConstructor   //无参构造器</span><br><span class="line">@AllArgsConstructor  //所有成员变量的有参构造器，如需定制，可以自己手动编写代码</span><br><span class="line">@Data    //get、set方法</span><br><span class="line">@ToString   //toString方法</span><br><span class="line">@EqualsAndHashCode   //重写equals和hashcode</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private Pet pet;</span><br><span class="line"></span><br><span class="line">    public User(String name,Integer age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lombok还提供@Slf4j注解，用于日志打印。如果需要使用lombok，需要引入依赖</strong></p>
<h3 id="2-dev-tools"><a href="#2-dev-tools" class="headerlink" title="2 dev-tools"></a>2 dev-tools</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>项目或者页面修改以后：Ctrl+F9；  跟shift+F9效果差不多，它的功能也是重启项目</p>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>yaml配置文件，k v格式，k v之间必须要有空格<br>properties的优先级比yml高<br>\n    双引号会换行，单引号不会换行<br>maven的clean+package导出jar包，jar包是项目可执行的文件，java -jar启动</p>
<h2 id="2-Web开发"><a href="#2-Web开发" class="headerlink" title="2.Web开发"></a>2.Web开发</h2><p>SpringBoot几乎提供了所有的自动配置</p>
<h3 id="2-1-静态资源目录"><a href="#2-1-静态资源目录" class="headerlink" title="2.1 静态资源目录"></a>2.1 静态资源目录</h3><p>只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources<br>访问 ： 当前项目根路径/ + 静态资源名<br>​</p>
<p>原理： 静态映射/**。<br>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面<br>​</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /res/**</span><br><span class="line">    </span><br><span class="line">	resources:</span><br><span class="line">    static-locations: [classpath:/haha/]</span><br></pre></td></tr></table></figure>


<p>静态资源前缀的设置，会导致静态资源中index和favicon的失效</p>
<h3 id="2-2-请求映射"><a href="#2-2-请求映射" class="headerlink" title="2.2 请求映射"></a>2.2 请求映射</h3><p>所有的请求映射都在HandlerMapping中。</p>
<ul>
<li>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</li>
<li>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</li>
<li>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。<ul>
<li>如果有就找到这个请求对应的handler</li>
<li>如果没有就是下一个 HandlerMapping</li>
</ul>
</li>
<li>我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></li>
</ul>
<h3 id="2-3-请求处理"><a href="#2-3-请求处理" class="headerlink" title="2.3 请求处理"></a>2.3 请求处理</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631162277931-5807f1fe-3526-4d8a-b8a0-f6a31cfded35.png#clientId=ub5bbc323-b3fc-4&from=paste&height=446&id=ue9d44191&margin=%5Bobject%20Object%5D&name=&originHeight=446&originWidth=763&originalType=binary&ratio=1&size=47923&status=done&style=none&taskId=u45f79ebb-3158-4804-9e40-64ce100efb7&width=763"></p>
<p>矩阵变量必须有url路径变量才能被解析<br>​</p>
<p><strong>参数解析器的理解</strong></p>
<h3 id="2-4-POJO的封装过程"><a href="#2-4-POJO的封装过程" class="headerlink" title="2.4 POJO的封装过程"></a>2.4 POJO的封装过程</h3><p><strong>数据绑定</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631264667583-91f324de-f04e-420e-b0b4-39a85959146e.png#clientId=ue844cd9e-3703-4&from=paste&height=287&id=uac93d380&margin=%5Bobject%20Object%5D&name=&originHeight=287&originWidth=828&originalType=binary&ratio=1&size=158755&status=done&style=none&taskId=u8760807b-21c9-45aa-b622-e413838c849&width=828"></p>
<h3 id="2-5-数据响应与内容协商"><a href="#2-5-数据响应与内容协商" class="headerlink" title="2.5 数据响应与内容协商"></a>2.5 数据响应与内容协商</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631265908773-3cb29740-fc3a-4fc4-b737-eed4d36ade88.png#clientId=ue844cd9e-3703-4&from=paste&height=274&id=ufb225947&margin=%5Bobject%20Object%5D&name=&originHeight=274&originWidth=432&originalType=binary&ratio=1&size=12612&status=done&style=none&taskId=uf802e7c9-5678-476f-b915-05303cd4193&width=432"></p>
<h2 id="3-Thymeleaf"><a href="#3-Thymeleaf" class="headerlink" title="3.Thymeleaf"></a>3.Thymeleaf</h2><p>前端模板引擎，用于springboot的前后端不分离项目<br>​</p>
<p>后端向前端html传递数据，可以把数据放在HttpSession和Model对象中<br>session存在服务器，cookie存在客户端<br>​</p>
<p>用户是否登录使用拦截器的解决方案<br>​</p>
<p>创建list的user对象的方法：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631503799043-5a49aaf3-29ac-49e2-8cd3-d52090fc2630.png#clientId=uc718f90e-1fb8-4&from=paste&height=316&id=ud1608871&margin=%5Bobject%20Object%5D&name=&originHeight=316&originWidth=1137&originalType=binary&ratio=1&size=291163&status=done&style=none&taskId=u8d28f38e-d4d1-4c62-83d6-096d7396a28&width=1137"></p>
<h2 id="4-拦截器"><a href="#4-拦截器" class="headerlink" title="4.拦截器"></a>4.拦截器</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631669770552-88c6e8c3-ffc2-4ef1-869e-c9f3b27d3e34.png#clientId=udec2cb0c-a3fa-4&from=paste&height=91&id=u8335d798&margin=%5Bobject%20Object%5D&name=&originHeight=91&originWidth=778&originalType=binary&ratio=1&size=121894&status=done&style=none&taskId=u2d8340c1-6352-4b96-bba1-22131b6c82b&width=778"></p>
<p>写完拦截器后，还要写一个配置类<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631669639670-27b30153-6108-44ff-88e4-705ffce27db2.png#clientId=udec2cb0c-a3fa-4&from=paste&height=290&id=u3147febf&margin=%5Bobject%20Object%5D&name=&originHeight=290&originWidth=1345&originalType=binary&ratio=1&size=272546&status=done&style=none&taskId=ua1e4fbb4-b598-494e-b092-f952529268a&width=1345"></p>
<p>log日志打印用大括号{}，后面可以传参数到大括号中<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631670617684-71515619-2885-4226-acca-297093ae490d.png#clientId=udec2cb0c-a3fa-4&from=paste&height=529&id=uad28c216&margin=%5Bobject%20Object%5D&name=&originHeight=529&originWidth=1167&originalType=binary&ratio=1&size=257366&status=done&style=none&taskId=u030bcad3-af47-4dc4-9a23-3dd7b17b0a9&width=1167"><br>​</p>
<h2 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5.文件上传"></a>5.文件上传</h2><p>使用@RequestPart注解<br>文件上传API <strong>Multipart</strong>接口可以在配置文件中设置单个文件上传大小、整体文件上传大小<br>一般设置单个文件上传大小为10M<br>​</p>
<h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><p>前端需要设置404、5xx错误跳转页面。后端编写全局异常处理跳转代码</p>
<p>异常处理自动配置ErrorMvcAutoConfiguration<br>​</p>
<h2 id="7-Web原生组件注入-Servlet、Filter、Listener"><a href="#7-Web原生组件注入-Servlet、Filter、Listener" class="headerlink" title="7.Web原生组件注入(Servlet、Filter、Listener)"></a>7.Web原生组件注入(Servlet、Filter、Listener)</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631685881305-ea779be7-bfba-4d63-bb09-a2dda5780519.png#clientId=udec2cb0c-a3fa-4&from=paste&height=402&id=udfbefec0&margin=%5Bobject%20Object%5D&name=&originHeight=402&originWidth=706&originalType=binary&ratio=1&size=40933&status=done&style=none&taskId=ud35374ff-ab7f-420c-a6d6-fa4a35da2eb&width=706"></p>
<p>SpringBoot场景的正常运行得益于底层的自动配置</p>
<p><strong>定制化原理</strong><br>如果接管SpringMVC，就要全面定义它底层的行为<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631686881524-49dbfa3a-481d-4e8c-a674-76442dbbda13.png#clientId=udec2cb0c-a3fa-4&from=paste&height=44&id=u597e4fbe&margin=%5Bobject%20Object%5D&name=&originHeight=44&originWidth=928&originalType=binary&ratio=1&size=64808&status=done&style=none&taskId=u868ed1bd-d40d-4762-9aa4-802c711b827&width=928"></p>
<h2 id="8-数据访问"><a href="#8-数据访问" class="headerlink" title="8.数据访问"></a>8.数据访问</h2><h3 id="8-1-JDBCTempalte"><a href="#8-1-JDBCTempalte" class="headerlink" title="8.1 JDBCTempalte"></a>8.1 JDBCTempalte</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631687365008-3f821da9-ae1a-4bcc-9d18-b8a2741cdc4f.png#clientId=udec2cb0c-a3fa-4&from=paste&height=205&id=uc02ee31e&margin=%5Bobject%20Object%5D&name=&originHeight=205&originWidth=770&originalType=binary&ratio=1&size=14431&status=done&style=none&taskId=u4cbc34bb-c3bc-4603-84e0-b863eb15568&width=770"><br>数据库驱动？<br>为什么导入JDBC场景，官方不导入驱动？官方不知道我们接下要操作什么数据库。<br>数据库版本和驱动版本对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<p>SpringBoot默认使用的是Hikari数据源，配置文件配置数据源的时候不用去配置，因为底层已经指定帮我们配好了。如果需要更换数据源，也可以进行配置<br>​</p>
<p>使用JdbcTemplate模板引擎，就可以操作数据库了<br>​</p>
<p><strong>使用某个中间件：首先要找starter，starter会把需要用到的组件都注入到容器中，我们只需要进行一些配置，就可以使用这些中间件了</strong></p>
<p>目前比较流行的数据源是Hikari和Druid<br>​</p>
<p><strong>​</strong></p>
<p><strong>自定义整合Druid数据源：</strong><br>Druid提供内置监控页的功能，在配置文件中配置即可查看页面<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631691102372-6a7dbc49-3d11-4a20-b2a8-c2f23e60a638.png#clientId=udec2cb0c-a3fa-4&from=paste&height=331&id=u07649a35&margin=%5Bobject%20Object%5D&name=&originHeight=331&originWidth=1059&originalType=binary&ratio=1&size=230828&status=done&style=none&taskId=ubaf7fad5-1403-42ee-8789-ff915cedeb5&width=1059"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631691580980-9f05619d-cc27-4321-9b09-e3c6daebab1c.png#clientId=udec2cb0c-a3fa-4&from=paste&height=361&id=u793f1485&margin=%5Bobject%20Object%5D&name=&originHeight=361&originWidth=1032&originalType=binary&ratio=1&size=358430&status=done&style=none&taskId=uf4099a81-7596-4c60-a4ce-2dfc7e5e6a4&width=1032"><br>Arrays.asList()  创建一个集合<br>​</p>
<p><strong>如果某个中间有starter启动类，就不用自己创建配置类进行配置了。所以用中间件之前，先引入starter，比如druid就有starter</strong><br><strong>​</strong></p>
<p>druid的监控页可以配置账号密码<br>​</p>
<h3 id="8-2-MyBatis"><a href="#8-2-MyBatis" class="headerlink" title="8.2 MyBatis"></a>8.2 MyBatis</h3><p>引入MyBatis的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>MyBatis开启驼峰命名规则，否则数据库带_的字段无法正常读取<br>mybatis-config.xml可以不写，配置直接写在application.properties中即可<br>mapper接口标注@Mapper注解<br>​</p>
<p>sql语句可以用xml的方式，也可以用注解的方式<br>​</p>
<h3 id="8-3-MyBatis-Plus"><a href="#8-3-MyBatis-Plus" class="headerlink" title="8.3 MyBatis Plus"></a>8.3 MyBatis Plus</h3><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>mapper接口继承BaseMapper<T>，不用自己编写xml文件<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631696711988-4a74fe71-7e66-49b7-8c74-45fd449ad08f.png#clientId=udec2cb0c-a3fa-4&from=paste&height=243&id=ucaea7a0a&margin=%5Bobject%20Object%5D&name=&originHeight=243&originWidth=835&originalType=binary&ratio=1&size=172997&status=done&style=none&taskId=ue53d6fe1-1c7e-4a99-bb67-6a7956dd654&width=835"></p>
<p>MyBatis Plus的pojo类示例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631696858682-0b336734-0072-40cf-b0cf-90deed01d10c.png#clientId=udec2cb0c-a3fa-4&from=paste&height=620&id=ub3a30d4c&margin=%5Bobject%20Object%5D&name=&originHeight=620&originWidth=460&originalType=binary&ratio=1&size=251786&status=done&style=none&taskId=ua6af1bb7-6373-4d80-8da6-5c04b519af1&width=460"><br>@TableField表示该字段不在数据库中<br>Service的实现类需要加@Service注解<br>​</p>
<p>MyBatis Plus在mapper层和service层都进行了简化，提供了基础的方法，并且自己不用写xml文件<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631697133197-a037115e-9738-4162-8585-7c63a8b71859.png#clientId=udec2cb0c-a3fa-4&from=paste&height=68&id=u421fd858&margin=%5Bobject%20Object%5D&name=&originHeight=68&originWidth=757&originalType=binary&ratio=1&size=61403&status=done&style=none&taskId=u646ae702-5dea-4b36-80a4-2d52958cb00&width=757"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631697190080-6b3fbac1-090b-4a4c-b505-63e1d80fa741.png#clientId=udec2cb0c-a3fa-4&from=paste&height=174&id=ub6d32822&margin=%5Bobject%20Object%5D&name=&originHeight=174&originWidth=1211&originalType=binary&ratio=1&size=108140&status=done&style=none&taskId=u6872e4dc-ed52-41fc-90bf-5a401fc04f7&width=1211"><br>ctrl + F12可以查看类结构，由于继承了ServiceImpl，可以看到由MyBatis Plus已经实现的方法<br>​</p>
<p>实现分页查询，创建Page对象，然后使用提供的分页查询方法。想要分页完成，需要整合分页插件<br>​</p>
<p>MyBatis Plus结合Thymeleaf完成分页查询<br>​</p>
<h3 id="8-4-Redis"><a href="#8-4-Redis" class="headerlink" title="8.4 Redis"></a>8.4 Redis</h3><p>redis-starter由官方整合，由官方整合的starter自动配置都在统一的一个包中可以进行查看<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631710788203-58f4a7e7-32b6-4059-8af5-1752f205cbfc.png#clientId=ubcae3f69-ac75-4&from=paste&id=u43acbe15&margin=%5Bobject%20Object%5D&name=&originHeight=245&originWidth=908&originalType=binary&ratio=1&size=84771&status=done&style=none&taskId=ube5b7741-3a62-47a2-a979-253605613f1"></p>
<p>使用RedisTemplate即可操作Redis,对Redis中的数据进行增加、修改、删除等操作<br>​</p>
<h2 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9.单元测试"></a>9.单元测试</h2><p><strong>当前主要是JUnit5</strong>，相比于JUnit4使用起来更方便。SpringBoot2.4之后就不允许使用JUnit4了<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631715257345-0a10ee8a-15ae-45f8-b80c-02c288814b34.png#clientId=ubcae3f69-ac75-4&from=paste&id=u3959f422&margin=%5Bobject%20Object%5D&name=&originHeight=199&originWidth=1047&originalType=binary&ratio=1&size=60953&status=done&style=none&taskId=ubba0656b-70b3-4ff9-ab29-aaacd8355cb"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631715345279-36880286-2501-46b5-822b-4954248134d2.png#clientId=ubcae3f69-ac75-4&from=paste&id=ue162f8f3&margin=%5Bobject%20Object%5D&name=&originHeight=204&originWidth=398&originalType=binary&ratio=1&size=34006&status=done&style=none&taskId=uc234bfe2-656c-4e10-98d9-3afe4d03de7"><br>以上这种单元测试使用起来非常方便<br>​</p>
<p>JUnit5的相关注解：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631716028871-cbc169cb-f865-4f22-99be-acd33b3969f7.png#clientId=ubcae3f69-ac75-4&from=paste&id=u71dff98b&margin=%5Bobject%20Object%5D&name=&originHeight=446&originWidth=1060&originalType=binary&ratio=1&size=189236&status=done&style=none&taskId=ue8e5a17e-158a-4d3d-9060-c7d6ba8cbbd"></p>
<p><strong>断言机制</strong><br>不满足的断言会使测试条件失败</p>
<p><strong>前制条件</strong><br>​</p>
<p><strong>嵌套测试</strong><br>​</p>
<p><strong>参数化测试</strong><br>使用不同的参数多次运行某个测试  @ValueSource<br>​</p>
<h2 id="10-指标监控"><a href="#10-指标监控" class="headerlink" title="10.指标监控"></a>10.指标监控</h2><p>SpringBoot Actuator<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631718011444-e1dab13b-0d5b-4b56-8c18-dacf671f5e57.png#clientId=ubcae3f69-ac75-4&from=paste&id=u3954f3b5&margin=%5Bobject%20Object%5D&name=&originHeight=137&originWidth=762&originalType=binary&ratio=1&size=91721&status=done&style=none&taskId=u0737ed26-320c-4881-a68c-155f1d69c2c"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631718497581-94c74683-4b65-4bdc-99f3-66d94c872e91.png#clientId=ubcae3f69-ac75-4&from=paste&id=ubda37100&margin=%5Bobject%20Object%5D&name=&originHeight=163&originWidth=218&originalType=binary&ratio=1&size=15123&status=done&style=none&taskId=u43ee0b45-926b-4b66-8924-60ab4c0a165"><br><strong>整合SpringBoot Admin Server：开源的应用监控可视化项目</strong><br>可以用来查看应用的启动状态、内存占用、cpu使用率等</p>
<h2 id="11-原理解析"><a href="#11-原理解析" class="headerlink" title="11.原理解析"></a>11.原理解析</h2><h3 id="11-1-Profile配置环境切换"><a href="#11-1-Profile配置环境切换" class="headerlink" title="11.1 Profile配置环境切换"></a>11.1 Profile配置环境切换</h3><p>从配置文件取值，@Value加冒号，冒号后面表示如果不到值，赋予一个默认值<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631719367531-9ef7fd53-47ab-46cf-a718-034e3c293842.png#clientId=ubcae3f69-ac75-4&from=paste&height=73&id=u86b1f00e&margin=%5Bobject%20Object%5D&name=&originHeight=145&originWidth=663&originalType=binary&ratio=1&size=57104&status=done&style=none&taskId=ud78e0e88-4291-4f29-a6c8-da731bf1ae5&width=331.5"><br>如果两个配置文件中有相同的配置，以指定环境的配置为主<br>​</p>
<p>打包一般使用clean  install，install包含了package的功能<br>​</p>
<h3 id="11-2-自定义starter"><a href="#11-2-自定义starter" class="headerlink" title="11.2 自定义starter"></a>11.2 自定义starter</h3><p>SpringBoot也可以自定义starter<br>​</p>
<h3 id="11-3-SpringBoot启动过程"><a href="#11-3-SpringBoot启动过程" class="headerlink" title="11.3 SpringBoot启动过程"></a>11.3 SpringBoot启动过程</h3><ul>
<li>创建 <strong>SpringApplication</strong><ul>
<li>保存一些信息。</li>
<li>判定当前应用的类型。ClassUtils。Servlet</li>
<li><strong>bootstrappers：初始启动引导器（</strong>List<Bootstrapper>**）：去spring.factories文件中找 **org.springframework.boot.<strong>Bootstrapper</strong></li>
<li>找 <strong>ApplicationContextInitializer</strong>；去<strong>spring.factories找 ApplicationContextInitializer</strong><ul>
<li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li>
</ul>
</li>
<li><strong>找 ApplicationListener  ；应用监听器。</strong>去<strong>spring.factories找 ApplicationListener</strong><ul>
<li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li>
</ul>
</li>
</ul>
</li>
<li>运行 <strong>SpringApplication</strong><ul>
<li><strong>StopWatch</strong></li>
<li><strong>记录应用的启动时间</strong></li>
<li><strong>创建引导上下文（Context环境）createBootstrapContext()</strong><ul>
<li>获取到所有之前的 **bootstrappers 挨个执行 **intitialize() 来完成对引导启动器上下文环境设置</li>
</ul>
</li>
<li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li>
<li><strong>获取所有 RunListener（运行监听器）【为了方便所有Listener进行事件感知】</strong><ul>
<li>getSpringFactoriesInstances 去<strong>spring.factories找 SpringApplicationRunListener</strong>. </li>
</ul>
</li>
<li>遍历 <strong>SpringApplicationRunListener 调用 starting 方法；</strong><ul>
<li><strong>相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</strong></li>
</ul>
</li>
<li>保存命令行参数；ApplicationArguments</li>
<li>准备环境 prepareEnvironment（）;<ul>
<li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li>
<li><strong>配置环境信息对象。</strong><ul>
<li><strong>读取所有的配置源的配置属性值。</strong></li>
</ul>
</li>
<li>绑定环境信息</li>
<li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li>
</ul>
</li>
<li>创建IOC容器（createApplicationContext（））<ul>
<li>根据项目类型（Servlet）创建容器，</li>
<li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li>
</ul>
</li>
<li>**准备ApplicationContext IOC容器的基本信息 **  <strong>prepareContext()</strong><ul>
<li>保存环境信息</li>
<li>IOC容器的后置处理流程。</li>
<li>应用初始化器；applyInitializers；<ul>
<li>遍历所有的 <strong>ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能</strong></li>
<li>遍历所有的 listener 调用 <strong>contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared</strong></li>
</ul>
</li>
<li><strong>所有的监听器 调用 contextLoaded。通知所有的监听器 contextLoaded；</strong></li>
</ul>
</li>
<li><strong>刷新IOC容器。</strong>refreshContext<ul>
<li>创建容器中的所有组件（Spring注解）</li>
</ul>
</li>
<li>容器刷新完成后工作？afterRefresh</li>
<li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器 started</strong></li>
<li><strong>调用所有runners；</strong>callRunners()<ul>
<li><strong>获取容器中的</strong> **ApplicationRunner **</li>
<li><strong>获取容器中的  CommandLineRunner</strong></li>
<li><strong>合并所有runner并且按照@Order进行排序</strong></li>
<li><strong>遍历所有的runner。调用 run 方法</strong></li>
</ul>
</li>
<li><strong>如果以上有异常，</strong><ul>
<li><strong>调用Listener 的 failed</strong></li>
</ul>
</li>
<li>**调用所有监听器的 running 方法  **listeners.running(context); **通知所有的监听器 running **</li>
<li><strong>running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/2789.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>从大二开始就一直很想有一个属于自己的博客网站，可一拖再拖，直到最近才下了决心去搭建一个网站。在网上了解到基于Hexo的博客搭建比较简单并且美观，在查阅了许多教程，走过无数坑后，写下了这篇文章。本文主要讲解个人博客网站的搭建，内容比较详细，适合小白食用。</p>
</blockquote>
<p>网页预览：<a href="https://yuumiy.github.io/">https://yuumiy.github.io</a></p>
<span id="more"></span>

<h1 id="第一部分-搭建与发布"><a href="#第一部分-搭建与发布" class="headerlink" title="第一部分 搭建与发布"></a>第一部分 搭建与发布</h1><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><p>windows10<br>Github<br>Visual Studio Code<br>Hexo 5.4.0 + Next 7.8.0<br>Git 2.32.0<br>Node.js 14.17.4</p>
<h2 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h2><h3 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h3><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<br>可以到<a href="https://git-scm.com/download/win">Git官网</a>进行下载，Git详细安装教程可以查看<a href="https://blog.csdn.net/qq_43715354/article/details/108638061">Git安装</a>。</p>
<h3 id="2、安装VSCode"><a href="#2、安装VSCode" class="headerlink" title="2、安装VSCode"></a>2、安装VSCode</h3><p>VSCode 全称 Visual Studio Code，是微软出的一款轻量级代码编辑器，免费、开源而且功能强大，一般为前端代码开发IDE。<br>可以到<a href="https://code.visualstudio.com/Download">VSCode官网</a>进行下载，VSCode详细安装教程可以查看<a href="https://zhuanlan.zhihu.com/p/264785441">VSCode安装</a>。</p>
<h3 id="3、安装Node-js"><a href="#3、安装Node-js" class="headerlink" title="3、安装Node.js"></a>3、安装Node.js</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。<br>可以到<a href="http://nodejs.cn/download/">Node官网</a>进行下载，Node详细安装教程可以查看<a href="https://www.bilibili.com/video/BV1VK4y1v7TK">Node.js安装</a>。需要注意配置环境变量，便于npm包管理和使用全局组件。</p>
<h3 id="4、安装Hexo"><a href="#4、安装Hexo" class="headerlink" title="4、安装Hexo"></a>4、安装Hexo</h3><p>Hexo是一个快速、简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。<br>安装完Node.js后，就可以使用软件内自带的npm包管理器下载Hexo。<br>在任意文件夹下，右键<code>Git Bash Here</code>，<code>npm install -g hexo-cli</code>安装Hexo，然后使用<code>hexo init hexo-blog</code>初始化一个hexo项目。右键通过Code打开项目，在集成终端打开文件夹，执行<code>hexo server</code>，能够通过localhost:4000访问到项目，hexo就安装成功了。</p>
<h3 id="5、注册Github账号创建个人仓库"><a href="#5、注册Github账号创建个人仓库" class="headerlink" title="5、注册Github账号创建个人仓库"></a>5、注册Github账号创建个人仓库</h3><p>Github是世界上最大的代码托管平台，怎么注册账号相信不必我多说。<br>注册登录好之后，进去新建一个仓库，仓库名字有一定的规范要求。例如我的Github名字叫yuumiy，那么在填写仓库名的时候就是jorsoe.github.io。这样就完成了个人仓库的创建。</p>
<h3 id="6、生成ssh密钥添加到Github"><a href="#6、生成ssh密钥添加到Github" class="headerlink" title="6、生成ssh密钥添加到Github"></a>6、生成ssh密钥添加到Github</h3><p>这一步的目的是可以使用Github的ssh地址pull、push仓库。设置使用ssh密钥的好处是可以使用ssh连接，提交代码的时候可以不用输入密码，免密提交。<br>Github下载代码有三种方式，http下载、ssh下载、zip下载，到个人仓库页面就可以看到这三种下载方式。<br>​</p>
<p>在本地博客文件夹中右键选择Git Bash Here调出命令行，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;YourGithubName&quot;</span>		//双引号内填写你的GitHub用户名</span><br><span class="line">git config --global user.email <span class="string">&quot;YourGithubEmail&quot;</span>	//双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure>
<p> 用户名和邮箱根据你Github自己的信息自行更改。</p>
<p> 然后输入以下命令生成SSH密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;YourGithubEmail&quot;</span>		//双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure>
<p> 此时你个人的SSH密钥就已经生成，输入以下命令将其 Copy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub		//在Git命令提示符中显示出SSH密钥</span><br></pre></td></tr></table></figure>
<p>接下来打开Github，点击头像在选项卡中找到Setting设置选项，再点击SSH and GPG keys，新建一个SSH，命名随意，将刚才再Git输入框中复制的密钥粘贴在此处，点击保存。</p>
<p> 然后回到Git命令行，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com		//查看本地是否与Github连接成功</span><br></pre></td></tr></table></figure>
<p> 如果出现自己的用户名，那就已经将本地环境与Github连接成功，以后就可以通过ssh的方式提交代码，一劳永逸。</p>
<h3 id="7、修改Hexo配置文件"><a href="#7、修改Hexo配置文件" class="headerlink" title="7、修改Hexo配置文件"></a>7、修改Hexo配置文件</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的站点配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。​<br>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hexo/_config.yml</span><br><span class="line"></span><br><span class="line">/hexo/themes/landscape/_config.yml</span><br></pre></td></tr></table></figure>
<p>打开站点配置文件，修改配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: ssh仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>在repository仓库中填上刚才申请的个人仓库的ssh地址，branch分支填上主分支，保存即可。<br>建议将在VSCode中配置自动保存文件，自行百度进行相关设置。</p>
<h3 id="8、Hexo项目映射到Github仓库"><a href="#8、Hexo项目映射到Github仓库" class="headerlink" title="8、Hexo项目映射到Github仓库"></a>8、Hexo项目映射到Github仓库</h3><p>完成Hexo配置后，就可以在当前项目的集成终端执行<code>git init</code>，初始化一个git项目。<code>git remote add origin ssh地址</code>，ssh地址即为刚才申请的个人仓库的ssh地址。<br>在使用Hexo部署博客之前，需要先安装一个依赖，这个依赖会将我们生成好的代码部署到一个具体的分支，执行命令<code>npm install hexo-deployer-git</code>安装依赖。然后<code>hexo deploy</code>，即完成Hexo部署到Github。yuumiy.github.io即为博客项目的访问地址。</p>
<h3 id="9、Markdown学习与工具"><a href="#9、Markdown学习与工具" class="headerlink" title="9、Markdown学习与工具"></a>9、Markdown学习与工具</h3><p>所有的框架与工具配置好之后，就可以在/source/_post文件夹里面的.md文件进行博客的编撰，而编撰过程使用Markdown语法进行编写，点击<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdow</a>学习相应语法，教程比较全面而且讲述清晰，很容易理解。<br>工具使用<a href="https://typora.io/">Typora</a>，一个轻量级的Markdown文本编辑器，界面极简并且功能强大。</p>
<h1 id="第二部分-Next主题配置美化"><a href="#第二部分-Next主题配置美化" class="headerlink" title="第二部分 Next主题配置美化"></a>第二部分 Next主题配置美化</h1><blockquote>
<p>在Github开源了许多关于Hexo的博客主题，因为个人比较喜欢简约风格，在进行多番对比后，最终选择Next作为个人博客网站的主题。</p>
</blockquote>
<h2 id="Hexo相关介绍"><a href="#Hexo相关介绍" class="headerlink" title="Hexo相关介绍"></a>Hexo相关介绍</h2><h3 id="1、Hexo目录构成"><a href="#1、Hexo目录构成" class="headerlink" title="1、Hexo目录构成"></a>1、Hexo目录构成</h3><blockquote>
<p>node_modules：里面存放Node.js各种库的目录</p>
<p>public：生成网页的文件目录</p>
<p>scaffolds：存放新文章和新页面的初始设置</p>
<p>source：存放文章，各类页面，图像等文件</p>
<p>themes：存放着主题文件</p>
<p>_config.yml：站点配置文件</p>
</blockquote>
<h3 id="2、更换主题"><a href="#2、更换主题" class="headerlink" title="2、更换主题"></a>2、更换主题</h3><p>Hexo有着自己的开源主题库，我们需要去下载Next主题。</p>
<p>在集成终端，也就是博客根目录，执行<code>git clone git@github.com:theme-next/hexo-theme-next.git themes/next</code>，下载完成后，删除next文件夹中的.git和.gitigore文件，因为博客文件夹不能有两个git管理。<br>修改站点配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>执行<code>hexo server</code>，本地的个人博客网站已经更换为Next主题。</p>
<h3 id="3、Next目录构成"><a href="#3、Next目录构成" class="headerlink" title="3、Next目录构成"></a>3、Next目录构成</h3><blockquote>
<p>languages：语言 [通常保存本网站支持的语言设置和支持]</p>
<p>layout：布局文件[通常此文件中添加或者删除一些小功能]</p>
<p>pages：页面文件</p>
<p>scripts：脚本文件 [存放一些JavaScript脚本文件]</p>
<p>sources：资源文件 [存放一些图片,特效之类的文件]</p>
<p><em>config.yml：主题配置文件</em></p>
<p>static_prefix.yml：静态网页参数</p>
</blockquote>
<h2 id="主题配置美化"><a href="#主题配置美化" class="headerlink" title="主题配置美化"></a>主题配置美化</h2><blockquote>
<p>网上Next主题的配置大多为next5.+或next6.+，在Next 7.8.0中对之前的版本进行了高度的插件化，许多功能都集成在主题配置文件中，同时之前自定义样式配置文件的路径也有所改变，针对于此写下自己的配置记录。</p>
</blockquote>
<h3 id="1、设置博主文字描述和中文语言"><a href="#1、设置博主文字描述和中文语言" class="headerlink" title="1、设置博主文字描述和中文语言"></a>1、设置博主文字描述和中文语言</h3><p>站点配置文件修改Site：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 岛田悠米</span><br><span class="line">subtitle: &#x27;心中有梦 不负韶华&#x27;</span><br><span class="line">description: &#x27;coding就是生产力&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: Yuumiy</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2、设置Next主题样式"><a href="#2、设置Next主题样式" class="headerlink" title="2、设置Next主题样式"></a>2、设置Next主题样式</h3><p>Next提供了四种主题样式，根据个人的喜好选择即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<h3 id="3、设置博客文章持久化链接"><a href="#3、设置博客文章持久化链接" class="headerlink" title="3、设置博客文章持久化链接"></a>3、设置博客文章持久化链接</h3><p>发布博客后，它的默认url地址是带中文的，并且进行了多层分级，非常复杂，因此需要安装这个插件简化url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>站点配置文件修改permalink添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://yuumiy.github.io/</span><br><span class="line">permalink: posts/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16</span><br><span class="line">    rep: hex</span><br></pre></td></tr></table></figure>
<h3 id="4、Menu添加关于、标签、分类页面"><a href="#4、Menu添加关于、标签、分类页面" class="headerlink" title="4、Menu添加关于、标签、分类页面"></a>4、Menu添加关于、标签、分类页面</h3><p>站点配置文件修改menu，将about、tags、categories前的#号去掉，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br></pre></td></tr></table></figure>
<p>新建相关页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>修改生成页面的配置<br>source/about/index.md<br>source/tags/index.md<br>source/categories/index.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="5、添加搜索功能"><a href="#5、添加搜索功能" class="headerlink" title="5、添加搜索功能"></a>5、添加搜索功能</h3><p>安装exo-generator-searchdb这个插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>站点配置文件添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Search</span><br><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
<h3 id="6、对于网站样式的自定义"><a href="#6、对于网站样式的自定义" class="headerlink" title="6、对于网站样式的自定义"></a>6、对于网站样式的自定义</h3><p>在博客根目录下的source文件夹下新建_data文件夹并添加styles.styl文件，就可以对网站样式进行自定义<br>以我的个人博客为例，我做了如下自定义样式：修改链接样式、去掉顶部黑线、修改选中字符的颜色、修改代码块选中的颜色、修改引用样式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改链接样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff106c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, span.exturl &#123;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff106c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //去掉顶部黑线：</span><br><span class="line">.headband &#123;display:none;&#125;</span><br><span class="line"></span><br><span class="line">// 修改选中字符的颜色</span><br><span class="line">/* webkit, opera, IE9 */</span><br><span class="line">::selection &#123; </span><br><span class="line">    background: #00c4b6;</span><br><span class="line">    color: #f7f7f7; </span><br><span class="line">&#125;</span><br><span class="line">/* firefox */</span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    background: #00c4b6;</span><br><span class="line">    color: #f7f7f7;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码块选中颜色</span><br><span class="line">.highlight *::selection &#123;</span><br><span class="line">    background: #00c4b6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修改引用样式</span><br><span class="line">blockquote &#123;</span><br><span class="line">    border-left: 4px solid #f27c8d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、设置侧栏阅读进度百分比"><a href="#7、设置侧栏阅读进度百分比" class="headerlink" title="7、设置侧栏阅读进度百分比"></a>7、设置侧栏阅读进度百分比</h3><p>编辑站点配置文件，修改 back2top 部分如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  sidebar: true</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="8、设置字数统计和预计阅读时间"><a href="#8、设置字数统计和预计阅读时间" class="headerlink" title="8、设置字数统计和预计阅读时间"></a>8、设置字数统计和预计阅读时间</h3><p>在博客根目录下安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#文章、站点字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4                   # Average Word Length</span><br><span class="line">  wpm: 275                 # Words Per Minute（每分钟阅读词数）</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure>
<h3 id="9、网站底部添加网站运行时间"><a href="#9、网站底部添加网站运行时间" class="headerlink" title="9、网站底部添加网站运行时间"></a>9、网站底部添加网站运行时间</h3><p>修改主题下layout/_partials/footer.swig，在{ {- next_inject(‘footer’) } }上方添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(&quot;08/10/2021 12:00:00&quot;);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;</span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="10、添加自定义404页面"><a href="#10、添加自定义404页面" class="headerlink" title="10、添加自定义404页面"></a>10、添加自定义404页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>
<p>编辑新建的页面文件，默认在站点根目录下 /source/404/index.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">comments: false</span><br><span class="line">permalink: /404</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;center&gt;对不起，您所访问的页面不存在或者已删除&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">* [click here](https://yuumiy.github.io/) 返回首页</span><br><span class="line">* 我的Github：[https://github.com/yuumiy](https://github.com/yuumiy)</span><br></pre></td></tr></table></figure>
<h3 id="11、添加图片放大预览功能"><a href="#11、添加图片放大预览功能" class="headerlink" title="11、添加图片放大预览功能"></a>11、添加图片放大预览功能</h3><p>在主题配置文件，启用 fancybox，修改配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>
<h3 id="12、隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#12、隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="12、隐藏网页底部 powered By Hexo / 强力驱动"></a>12、隐藏网页底部 powered By Hexo / 强力驱动</h3><p>修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powered: false</span><br></pre></td></tr></table></figure>
<h3 id="13、网页底部添加动态桃心"><a href="#13、网页底部添加动态桃心" class="headerlink" title="13、网页底部添加动态桃心"></a>13、网页底部添加动态桃心</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">icon:</span><br><span class="line">    animated: true</span><br></pre></td></tr></table></figure>
<h3 id="14、图片懒加载设置"><a href="#14、图片懒加载设置" class="headerlink" title="14、图片懒加载设置"></a>14、图片懒加载设置</h3><p>在主题配置文件中启用lazyload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazyload: true</span><br></pre></td></tr></table></figure>
<h3 id="15、设置标题栏背景图片"><a href="#15、设置标题栏背景图片" class="headerlink" title="15、设置标题栏背景图片"></a>15、设置标题栏背景图片</h3><p>博客根目录下的source/_data/styles.styl文件，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 标题栏背景图片</span><br><span class="line">.site-brand-container &#123; </span><br><span class="line">  background-image: url(/images/bg.png);</span><br><span class="line">  background-size: 100% 100%;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/images/bg.png指的是根目录下public/images/下的图片</p>
<h3 id="16、修改文章底部tag标签"><a href="#16、修改文章底部tag标签" class="headerlink" title="16、修改文章底部tag标签"></a>16、修改文章底部tag标签</h3><p>把文章底部#标签改为图标，在主题配置文件中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>
<h3 id="17、设置头像"><a href="#17、设置头像" class="headerlink" title="17、设置头像"></a>17、设置头像</h3><p>在主题配置文件中修改avatar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>
<p>/images/avatar.png指的是根目录下public/images/下的图片</p>
<h3 id="18、网站底部加上访问量"><a href="#18、网站底部加上访问量" class="headerlink" title="18、网站底部加上访问量"></a>18、网站底部加上访问量</h3><p>修改主题下layout/_partials/footer.swig，在{ {- next_inject(‘footer’) } }上方添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;span&gt;&lt;br&gt;&lt;/span&gt;	</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span&gt;总访客&amp;nbsp&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&amp;nbsp人&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;总访问量&amp;nbsp&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&amp;nbsp次&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="19、顶部阅读进度条"><a href="#19、顶部阅读进度条" class="headerlink" title="19、顶部阅读进度条"></a>19、顶部阅读进度条</h3><p>主题配置文件中修改 reading_progress 选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # 显示在顶部</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#06d633&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>
<h3 id="20、设置网站图标"><a href="#20、设置网站图标" class="headerlink" title="20、设置网站图标"></a>20、设置网站图标</h3><p>在主题配置文件中修改favicon</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 填写自己的图片</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon.png</span><br><span class="line">  medium: /images/favicon.png</span><br><span class="line">  apple_touch_icon: /images/favicon.png</span><br><span class="line">  safari_pinned_tab: /images/favicon.png</span><br></pre></td></tr></table></figure>
<p>/images/favicon.png指的是根目录下public/images/下的图片</p>
<h3 id="21、侧边栏社交链接"><a href="#21、侧边栏社交链接" class="headerlink" title="21、侧边栏社交链接"></a>21、侧边栏社交链接</h3><p>修改主题配置文件中socail选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yuumiy || fab fa-github</span><br><span class="line">  E-Mail: mailto:115274737@qq.com || fa fa-envelope</span><br><span class="line">  CSDN: https://blog.csdn.net/qq_44752641 || fab fa-telegram</span><br><span class="line">  RSS: /atom.xml || fas fa-rss</span><br></pre></td></tr></table></figure>
<h3 id="22、阅读全文按钮样式"><a href="#22、阅读全文按钮样式" class="headerlink" title="22、阅读全文按钮样式"></a>22、阅读全文按钮样式</h3><p>在博客需要显示摘要的地方加上 more标签，就不会显示全文。</p>
<h3 id="23、更改新建文章的模板"><a href="#23、更改新建文章的模板" class="headerlink" title="23、更改新建文章的模板"></a>23、更改新建文章的模板</h3><p>默认新建文章没有分类这个选项，需要自己填写，现在修改 hexo/scaffolds/post.md 文件 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="24、设定代码高亮格式"><a href="#24、设定代码高亮格式" class="headerlink" title="24、设定代码高亮格式"></a>24、设定代码高亮格式</h3><p>在站点的配置文件中，搜索highlight</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>
<p>主题配置有关于代码高亮样式的选择，搜索highlight，一般选择normal即可</p>
<h3 id="25、代码块复制选项"><a href="#25、代码块复制选项" class="headerlink" title="25、代码块复制选项"></a>25、代码块复制选项</h3><p>主题配置文件搜索copy_button：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_button:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<h3 id="26、添加萌萌哒Live2D模型"><a href="#26、添加萌萌哒Live2D模型" class="headerlink" title="26、添加萌萌哒Live2D模型"></a>26、添加萌萌哒Live2D模型</h3><p>安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure>
<p>我使用的是喵咪的模型，使用以下命令下载组件，如需使用别的看板娘，请自行百度搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure>

<ul>
<li>在Hexo根目录中新建文件夹live2d_models</li>
<li>在 node_modules 文件夹中找到刚刚下载的 live2d 模型，将其复制到 live2d_models 中。live2d 模型是一个类似于这样的文件夹：live2d-widget-model-hijiki</li>
<li>更新站点配置文件中model.use项，将其修改为 live2d_models 文件夹中的模型文件夹的名称<h3 id="27、开启Valine评论系统"><a href="#27、开启Valine评论系统" class="headerlink" title="27、开启Valine评论系统"></a>27、开启Valine评论系统</h3>注册 Leancloud 账号，注册完成后进入app控制面板-&gt;创建应用-&gt;创建开发版应用。</li>
</ul>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932563266-a353398b-e96b-4b96-b3a6-8f31ec7d6823.png"></p>
<p>接下来我们配置一下我们的leancloud。点击设置-&gt;安全中心-&gt;Web 安全域名，输入你的博客网址来保证其他人就算获取了你的appid也没办法操作你的数据库。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932611676-e5f17d12-271d-4f85-87a8-e547cf7fc427.png"></p>
<p>接下来点击应用凭证获取你的appid和appkey。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932681681-3f87d5db-34fc-4b73-ae9d-7690800a4811.png"></p>
<hr>
<p>打开主题配置文件，找到comments栏目并开启valine。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure>
<p>往下滑动进入valine设置栏，开启valine并填入你的appid和appkey。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: # Your leancloud application appid</span><br><span class="line">  appkey: # Your leancloud application appkey</span><br><span class="line">  notify: false # Mail notifier</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 作者看到就会及时反馈，欢迎评论哦(๑•̀ㅂ•́)و✧ # Comment box placeholder</span><br><span class="line">  avatar: retro # Gravatar style</span><br><span class="line">  guest_info: nick,mail # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: # Language, available values: en, zh-cn</span><br><span class="line">  visitor: true # Article reading statistic</span><br><span class="line">  comment_count: true # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line">  recordIP: true # Whether to record the commenter IP</span><br><span class="line">  serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span><br><span class="line">  #post_meta_order: 0</span><br></pre></td></tr></table></figure>
<p>这里稍微解释一下各个参数的用途。<br>placeholder是在用户未输入任何参数时默认显示的值；avatar是默认用户头像，参考<a href="https://valine.js.org/avatar.html">link</a>；meta是可以选择的用户信息栏。</p>
<p>为了让Valine更加简洁，我们可以自定义Valine的显示，我是去除了Valine的power by、svg标签、下方的评论提示。具体做法是修改source/_data/styles.styl:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 隐藏 valine 的 powered by</span><br><span class="line">.vpower.txt-right &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// 隐藏 valine 的 svg标签</span><br><span class="line">.markdown &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// 隐藏 valine 的 下方评论提示</span><br><span class="line">.vempty &#123;</span><br><span class="line">  display: none!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>至此你的评论系统已经开启。</p>
</blockquote>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>花了大概3个小时，终于把这篇『搭建自己的个人博客网站』完成。这篇文章是我第一篇真正意义上的博客，首先是用心去写，花了大量时间去思考内容和排版；其次，希望自己能保持写博客的好习惯，从今天起，能保持每个月4篇高质量博客的输出，毕竟好记性不如烂笔头，多去总结多去思考。<br>​</p>
<p><strong>最后以维克托·雨果的话作为结束：</strong><br><strong>人的智慧掌握着三把钥匙，一把开启数字，一把开启字母，一把开启音符。知识、想象、幻想就在其中。</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性</title>
    <url>/posts/f6d8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>jdk8新特性学习，视频来自<a href="https://www.bilibili.com/video/BV1HV411W78K">2021最新版JDK8新特性详解</a></p>
</blockquote>
<p>​<span id="more"></span></p>
<h3 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h3><p><strong>lambda表达式的优点：</strong><br>1、简化匿名内部类的使用<br>lambda表达式：匿名内部类是传入接口，而且该接口只能有一个抽象方法<br>一个方法传入接口，就是匿名内部类的写法，因为必须实现接口的抽象方法，否则会报错</p>
<p>2、lambda表达式的省略写法<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971379624-91528a05-8669-44d0-8b50-f0109cf828e9.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u30bd8d35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132597&status=done&style=none&taskId=u3c5875ac-2bb2-480e-8cb0-6b333b1ee8a&title=&width=836" alt="image.png"></p>
<p>3、lambda表达式的使用前提<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971844159-19b8f263-3870-4d46-b7c5-80d920b1251b.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=112&id=u1ff72433&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50173&status=done&style=none&taskId=u123a68ed-b89f-4aef-93f5-1ce1e5035fc&title=&width=603" alt="image.png"><br>4、lambda表达式和匿名内部类的对比<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971974322-471b00a0-f497-486e-970f-f7df0727e1ed.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u8d96d1d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=421&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160037&status=done&style=none&taskId=u88c4ae96-0c18-4976-ba33-2a55940580a&title=&width=608" alt="image.png"></p>
<p>Lambda表达式使用时不关心接口名，抽象方法名。只关心抽象方法的参数列表和返回值类型 </p>
<h3 id="二、接口新特性"><a href="#二、接口新特性" class="headerlink" title="二、接口新特性"></a>二、接口新特性</h3><p>1、默认方法 default void test()<br>接口中的抽象方法一定要重写，如果有默认方法存在。多个实现了接口的类，可以不重写默认方法<br>2、静态方法<br>直接通过接口类名调用</p>
<p>3、两者的区别介绍<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647052456697-afd744e7-a8b6-45fa-a18f-1e93530a9166.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=103&id=u38de11f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=129&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95759&status=done&style=none&taskId=u515021a3-9317-4647-9937-89f30430d3e&title=&width=638.4" alt="image.png"> </p>
<h3 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h3><p>1、函数式接口的由来<br>lambda表达式只关心入参和返回值类型，重写接口中的方法，lambda表达式相当于一个实现类<br>2、函数式接口介绍<br>String.valueOf   将其他类型转为String<br>Double.valueOf  将字符串转为Double<br>Arrays.sort()  对数组进行排序<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647055257602-a0197426-9c17-4a99-add2-ebfccc91d7d8.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=82&id=u5a076924&margin=%5Bobject%20Object%5D&name=image.png&originHeight=103&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42217&status=done&style=none&taskId=u75cbf198-88ef-4ec1-ab7b-975b6d25e89&title=&width=580" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647055306127-809a0863-58d9-4d67-8b50-08a4ff242434.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=113&id=u36c4a84a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75678&status=done&style=none&taskId=uab77bf00-9f5d-4e85-9117-3af37cca920&title=&width=940.8" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647056563032-83df341e-e443-4516-a18c-1e8f9933e31a.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=553&id=ua57197a8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=691&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139462&status=done&style=none&taskId=uf41cd682-b9f2-4f57-9aad-2269042a232&title=&width=472" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647056708846-37275818-55bc-4ef6-abdc-e3af6a33b73a.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u2ac6c9a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68238&status=done&style=none&taskId=uc5a8dbd3-6bef-4f08-9532-226b7c61b32&title=&width=971.2" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647062445281-051a04ab-63bd-44d6-9914-8101ae1656da.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=83&id=u93609191&margin=%5Bobject%20Object%5D&name=image.png&originHeight=104&originWidth=311&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14571&status=done&style=none&taskId=u7de84a6c-a3a0-4007-b451-9ab5fa307a4&title=&width=248.8" alt="image.png"></p>
<p>jdk提供了以上四种函数式接口，我们就不用自己再去写接口了</p>
<h3 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647068201968-98703cab-447c-45d0-890f-1655f13c5733.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=724&id=u53dde557&margin=%5Bobject%20Object%5D&name=image.png&originHeight=905&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281748&status=done&style=none&taskId=ucfbe09bc-3cc5-49f2-aad8-2594d8fd6c3&title=&width=964" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647077532053-eb2ec73a-5ebd-4d9a-a149-253f022a7805.png#clientId=u3d4aae83-b6ce-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=164&id=u50a8c6d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102734&status=done&style=none&taskId=ueebde7b7-f499-49b4-871b-6468765c809&title=&width=792.8" alt="image.png"><br>对象名::方法名<br>类名::静态方法名<br>类名::方法名<br>类名::构造器<br>数组::构造器</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647166775189-4fc4f1df-2047-4df9-83ca-a7ac1875f0de.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u3ed3b079&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=746&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200596&status=done&style=none&taskId=u61ef2c4d-4333-4e1d-a048-f67fd83500e&title=&width=596.8" alt="image.png"></p>
<h3 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="五、Stream API"></a>五、Stream API</h3><p>定义一个List集合  Arrays.asList()   主要针对集合的操作进行优化</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong>集合数据处理举例：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647167402749-d216eab5-b61e-419f-83d3-97678a08cfd3.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=562&id=ub62bdf79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=261806&status=done&style=none&taskId=u14d50692-7080-4b55-89b7-584931f439a&title=&width=1007.2" alt="image.png"></p>
<p>Stream对数据进行加工处理，filter、map、skip、count</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168172502-addcc8dd-9ccf-490f-a388-92c969283727.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=519&id=u7fe5d9d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=1213&originalType=binary&ratio=1&rotation=0&showTitle=false&size=330818&status=done&style=none&taskId=u505ff1b5-31ce-4d06-8d6d-16afb9df596&title=&width=970.4" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168463324-78e4b3ea-7367-4466-bc0b-a79776390c60.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=519&id=ud47c6cd6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=274970&status=done&style=none&taskId=ucf5dade7-cb2a-45c0-8367-6d08b4f40ab&title=&width=976" alt="image.png"></p>
<p><strong>stream要调用终结方法才有作用</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168829000-bf606e0a-fff3-4fb3-ada7-2e412dc40e43.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=92&id=u7fabf8ec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25255&status=done&style=none&taskId=ufaaa0e40-3efc-4c9d-a59e-5dc2f6f0ca3&title=&width=260" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168875637-b13c740f-a065-46f7-aa44-21da381f1b29.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=84&id=ufddc94f0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29979&status=done&style=none&taskId=uc9cac828-dae4-49e9-90a1-57c46f0b4d1&title=&width=415.2" alt="image.png"><br>** 4.3 filter**<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169084499-e2e61f47-f308-4c5f-87e0-96719e30ac57.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u2137d325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=1234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=135991&status=done&style=none&taskId=u20911917-c1c1-4a7e-b451-26ad7765172&title=&width=987.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169234120-a858d482-d797-4e8c-be8f-5eb5a2b8d96b.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=u85cf442b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=462&originWidth=1059&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92138&status=done&style=none&taskId=u2a107a58-81f1-42f0-9b5b-e9fca597623&title=&width=847.2" alt="image.png"></p>
<p><strong>4.5 skip</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169430333-6b0c70ff-1a67-42df-b506-29cb0b11a12f.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=74&id=uc2e3c241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=92&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31507&status=done&style=none&taskId=uf610f471-676f-4617-8aa8-2b659af18b8&title=&width=588.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169646238-d0fbedf8-9476-4d65-8f53-044b5cb45b1e.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=666&id=udc06268f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=833&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=285922&status=done&style=none&taskId=u0778cc04-433c-4e55-a765-d2036994867&title=&width=1024" alt="image.png"><br><strong>4.7 sorted</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169776843-921b1887-4377-4c78-80ec-cbc494955b74.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u1a16dabc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&size=150944&status=done&style=none&taskId=ub5c3819e-effc-4f71-8fda-289a3b74f3f&title=&width=753.6" alt="image.png"><br>o2 - o1 代表降序  sorted默认是升序<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170041222-fb4adeab-9d23-488a-994c-e1944796b62d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=110&id=u576716be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28624&status=done&style=none&taskId=u905f037b-80d4-4373-b12f-405597e27ac&title=&width=370.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170236073-286439de-50d9-44cb-ab73-3f398bfc36ff.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=u06a06ffe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140025&status=done&style=none&taskId=u957ebc71-348c-4868-8ebe-3af7a2dad02&title=&width=968" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170377654-35a78b6d-8fd6-4ccc-bbae-e1916be6aa81.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=u41228ccc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105746&status=done&style=none&taskId=u69a247ff-bcf8-42bc-8276-57fa2b4ea9c&title=&width=968" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170439395-3ee72977-88c4-4641-b326-491616080ef5.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=90&id=u502e2250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=521&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31675&status=done&style=none&taskId=u7750f4c0-3137-4ea4-b6f8-879ce3674ad&title=&width=416.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170599823-faf233fd-2efe-4e6b-a7cc-7615b05b801e.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u41422863&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121661&status=done&style=none&taskId=ud076ce4d-15b4-4715-9baa-afddd0e51f9&title=&width=928.8" alt="image.png"><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170622800-0499edf1-c225-4195-8b2f-16b30d57e5ac.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=u2d0038fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=591&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39919&status=done&style=none&taskId=ue95b8bab-a57e-4e4f-abcb-5be17d67767&title=&width=472.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170993407-22eac015-e324-411d-99a3-e57350b24556.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ua7924805&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55506&status=done&style=none&taskId=u3fa10043-45f4-49d2-991e-d9ddb487edd&title=&width=671.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647172388224-ec691e4f-79ca-4c61-a328-25f2685f4087.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u91872cb2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113939&status=done&style=none&taskId=u8cce103b-bc31-491f-b5c0-9d34add5395&title=&width=574.4" alt="image.png"><br>-&gt; 叫做箭头</p>
<p><strong>4.13 map与reduce的结合</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647172817396-d10786d0-b847-470b-89cb-bf6cffdbf277.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=ubd87fe22&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297685&status=done&style=none&taskId=ubf08f031-f490-44c0-8f20-7764f43c124&title=&width=800" alt="image.png"></p>
<p>stream对包装类进行操作i，比如Integer</p>
<p>Integer.intValue 把String转为int</p>
<p><strong>4.14 mapToInt</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175783195-e9d17cbc-5fbc-40fd-ae01-3414fbec94d4.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=u35db0212&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&size=193753&status=done&style=none&taskId=u3d4d0fed-db1b-4633-a354-9dfa21166cf&title=&width=948.8" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175933281-d192541b-2ee5-4f99-b327-226a69cb1d0d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=72&id=ua8910985&margin=%5Bobject%20Object%5D&name=image.png&originHeight=90&originWidth=758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41359&status=done&style=none&taskId=u4605c6b1-817b-4c73-9bef-15104c556b1&title=&width=606.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175938173-515d3fe2-e9a2-4d8f-848b-85c597eab22f.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=204&id=u72f1c526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108482&status=done&style=none&taskId=ud4a84833-3bed-4502-9cf4-afbc2f9d4f9&title=&width=956" alt="image.png"></p>
<p><strong>4.16 综合案例</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647177637801-30c16d42-6e8a-4ebe-9ac5-18751838ae00.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=u16d869c5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=334&originWidth=621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136831&status=done&style=none&taskId=u3a2108f0-89a3-400d-be86-5e4d6d1576e&title=&width=496.8" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.bobo.jdk.stream;</span><br><span class="line">import com.bobo.jdk.lambda.domain.Person;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line">public class StreamTest21Demo &#123;</span><br><span class="line">/**</span><br><span class="line">* 1. 第一个队伍只保留姓名长度为3的成员</span><br><span class="line">* 2. 第一个队伍筛选之后只要前3个人</span><br><span class="line">* 3. 第二个队伍只要姓张的成员</span><br><span class="line">* 4. 第二个队伍筛选之后不要前两个人</span><br><span class="line">* 5. 将两个队伍合并为一个队伍</span><br><span class="line">* 6. 根据姓名创建Person对象输出结果：</span><br><span class="line">5.Stream结果收集</span><br><span class="line">5.1 结果收集到集合中</span><br><span class="line">* 7. 打印整个队伍的Person信息</span><br><span class="line">* @param args</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list1 = Arrays.asList(&quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;, &quot;老子&quot;,</span><br><span class="line">&quot;庄子&quot;, &quot;孙子&quot;, &quot;洪七 公&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(&quot;古力娜扎&quot;, &quot;张无忌&quot;, &quot;张三丰&quot;, &quot;赵丽颖&quot;,</span><br><span class="line">&quot;张二狗&quot;, &quot;张天爱&quot;, &quot;张三&quot;);</span><br><span class="line">// 1. 第一个队伍只保留姓名长度为3的成员</span><br><span class="line">// 2. 第一个队伍筛选之后只要前3个人</span><br><span class="line">Stream&lt;String&gt; stream1 = list1.stream().filter(s -&gt; s.length() ==</span><br><span class="line">3).limit(3);</span><br><span class="line">// 3. 第二个队伍只要姓张的成员</span><br><span class="line">// 4. 第二个队伍筛选之后不要前两个人</span><br><span class="line">Stream&lt;String&gt; stream2 = list2.stream().filter(s -&gt;</span><br><span class="line">s.startsWith(&quot;张&quot;)).skip(2);</span><br><span class="line">// 5. 将两个队伍合并为一个队伍</span><br><span class="line">// 6. 根据姓名创建Person对象</span><br><span class="line">// 7. 打印整个队伍的Person信息</span><br><span class="line">Stream.concat(stream1,stream2)</span><br><span class="line">//.map(n-&gt; new Person(n))</span><br><span class="line">.map(Person::new)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要test测试，可以引入 junit 依赖</p>
<h4 id="Stream结果收集"><a href="#Stream结果收集" class="headerlink" title="Stream结果收集"></a>Stream结果收集</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647178563912-c6591790-b342-4a4e-9979-9ead888f6a13.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=129&id=u7adbce3e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=161&originWidth=334&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25070&status=done&style=none&taskId=u6940cf2f-de4a-426f-a72d-4b7cdb33c72&title=&width=267.2" alt="image.png"><br><strong>聚合运算：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* Stream流中数据的聚合计算</span><br><span class="line">*/</span><br><span class="line">@Testpublic void test03()&#123;</span><br><span class="line">// 获取年龄的最大值</span><br><span class="line">Optional&lt;Person&gt; maxAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">System.out.println(&quot;最大年龄：&quot; + maxAge.get());</span><br><span class="line">// 获取年龄的最小值</span><br><span class="line">Optional&lt;Person&gt; minAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">System.out.println(&quot;最新年龄:&quot; + minAge.get());</span><br><span class="line">// 求所有人的年龄之和</span><br><span class="line">Integer sumAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">)</span><br><span class="line">//.collect(Collectors.summingInt(s -&gt; s.getAge()))</span><br><span class="line">.collect(Collectors.summingInt(Person::getAge))</span><br><span class="line">;</span><br><span class="line">System.out.println(&quot;年龄总和：&quot; + sumAge);</span><br><span class="line">// 年龄的平均值</span><br><span class="line">Double avgAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.averagingInt(Person::getAge));</span><br><span class="line">System.out.println(&quot;年龄的平均值：&quot; + avgAge);</span><br><span class="line">// 统计数量</span><br><span class="line">Long count = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).filter(p-&gt;p.getAge() &gt; 18)</span><br><span class="line">.collect(Collectors.counting());</span><br><span class="line">System.out.println(&quot;满足条件的记录数:&quot; + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组分组：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179626317-254cdac5-c34d-4dc2-849f-d84984c06d54.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=524&id=ud90100e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=655&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180622&status=done&style=none&taskId=u70b49964-2bee-4904-8731-c3d3b45f8c2&title=&width=627.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179638583-d8484c76-f18e-4767-9f89-584a99c3a08d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=241&id=u3ae54ac1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98518&status=done&style=none&taskId=u44894e9a-2ec9-4a95-8337-3fd55ad8eba&title=&width=624.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179651531-503736f8-5a4c-44fe-96ec-f2757d7f64db.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=584&id=u6108f6f0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146207&status=done&style=none&taskId=ub2a321f5-75ed-4d5b-b2a7-b7e15a304ec&title=&width=751.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179660821-c377f2b0-dbd4-4e64-baf1-a713fffa4a7d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ue6d20e07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56925&status=done&style=none&taskId=uacf4ca4b-6a14-48a4-80e5-d7b270d81d6&title=&width=614.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180654573-e7a407f3-ffbc-4bbe-95e3-6efb69aa2218.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=80&id=u4df3d602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=100&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73903&status=done&style=none&taskId=u1dc5b796-bff6-42ec-bb1c-5fa1737d797&title=&width=792" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180677098-1cadc779-e2b1-4c5a-8d10-b52c6bd06a86.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=478&id=u63cf98f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1173&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237475&status=done&style=none&taskId=uca829a68-06b1-4ead-937b-776b843af90&title=&width=938.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180837472-fb80d88f-ea35-4918-a62e-59b2004c93b1.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=586&id=u966eb087&margin=%5Bobject%20Object%5D&name=image.png&originHeight=733&originWidth=585&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166511&status=done&style=none&taskId=u0e0278c4-471f-43ae-a764-60bac8a1329&title=&width=468" alt="image.png"></p>
<h4 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h4><p>之前的Stream操作都是串行流，它们都是在一个线程中去操作，因此效率不是很高</p>
<p>获取并行流的两种方式：<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647181128005-f647a650-850c-4c76-ab09-60e33c70e266.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u14d06f5d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106286&status=done&style=none&taskId=uaac7c4ba-4f27-4b89-9f57-3eb902a98a3&title=&width=636" alt="image.png"><br> 并行流就是转换成多线程处理<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647181628393-92ff0244-2bd7-40ae-bc2e-9aad634f4602.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=u61d988c9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=97&originWidth=1013&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71388&status=done&style=none&taskId=u53bc737f-992c-4d96-8a08-801de0ec736&title=&width=810.4" alt="image.png"></p>
<p><strong>并行流中的线程安全问题</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647182090800-ea4afd80-1047-4336-a03a-07f1ae5fc53b.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=69&id=u693bd55f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=341&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21077&status=done&style=none&taskId=u9dbd05a3-255e-410c-a769-9313a57ceba&title=&width=272.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647184649734-ee71bab7-48d9-4580-82a6-fda775163a3c.png#clientId=uf2d0c17c-91f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u607dcf26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=421&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118752&status=done&style=none&taskId=u1259999d-441c-41c4-83fc-5cde74fd18e&title=&width=697" alt="image.png"></p>
<h3 id="六、Optional类"><a href="#六、Optional类" class="headerlink" title="六、Optional类"></a>六、Optional类</h3><p>解决空指针问题<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743599004-08b191de-e18c-4f73-b186-77839a73966d.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=ub450af9f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=1189&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122159&status=done&style=none&taskId=u4373d58f-4296-44bc-8a1b-d21aab4db17&title=&width=951.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743683010-ebb82e44-b390-4db1-bea7-5dabb6d24892.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=367&id=uf5803731&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=1102&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133437&status=done&style=none&taskId=u36c1298f-627a-472e-bb0e-a8343568010&title=&width=881.6" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743837918-d7d451ff-30b3-4350-bac4-83a13a8407bd.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=435&id=u41f3b9fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223324&status=done&style=none&taskId=ue1d94bcb-d4e6-4acf-a0db-0f4fc37b7e0&title=&width=940" alt="image.png"></p>
<h4 id="Optional常用方法"><a href="#Optional常用方法" class="headerlink" title="Optional常用方法"></a>Optional常用方法</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647744191519-9ea36f5a-d550-4e3e-8fa5-48987186ca5b.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=222&id=u5070de8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175401&status=done&style=none&taskId=uda2c94c1-0726-474d-a17e-60dd8c056e8&title=&width=859.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647745482613-a70fb790-959d-4d5a-82ad-da9f7592f40e.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=478&id=u8ac1d41e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=203328&status=done&style=none&taskId=ubfba51f2-44d2-46a9-9e71-81246c4646c&title=&width=636" alt="image.png"></p>
<h3 id="七、新日期时间API"><a href="#七、新日期时间API" class="headerlink" title="七、新日期时间API"></a>七、新日期时间API</h3><p>sdf.format 将时间转为字符串<br>sdf.parse  将字符串转为时间</p>
<p>想要不打印错误日志，可以 try catch 打印一下，可以把错误信息提示去除<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746317953-6786d83b-bcdb-46ed-8d25-6d857323ccd4.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=136&id=uc591c46b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144569&status=done&style=none&taskId=u3006f330-0abd-4313-92d9-04255a7a464&title=&width=996.8" alt="image.png"></p>
<p>新的API位于java.time包下</p>
<h4 id="新日期API介绍"><a href="#新日期API介绍" class="headerlink" title="新日期API介绍"></a>新日期API介绍</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746396473-0349ea86-25e7-4596-a70f-09f269d0f457.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=579&id=u0c209939&margin=%5Bobject%20Object%5D&name=image.png&originHeight=724&originWidth=1047&originalType=binary&ratio=1&rotation=0&showTitle=false&size=378576&status=done&style=none&taskId=ua871272d-8a07-4bd8-9667-a64d20f629a&title=&width=837.6" alt="image.png"><br>日期时间类型：<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746584959-84dfd393-ddbc-414b-8ea6-23a1fbddb045.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=442&id=u443e977a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=283749&status=done&style=none&taskId=uf366d8e0-78b1-48d1-b58e-2e08655b123&title=&width=884.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746669098-c69f00f8-1ced-470f-a4c5-1c269ca270ad.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=321&id=u4248d8a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208704&status=done&style=none&taskId=u018cbf5e-9a1f-4190-be8c-1a6e23f855c&title=&width=873.6" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746737104-e921d675-3d52-465a-83ef-70273d3a6e2a.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=463&id=ub8f12d62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179792&status=done&style=none&taskId=uaabaac09-2230-44b6-aad7-acb296c5fcc&title=&width=554.4" alt="image.png"><br>LocalDate、LocalTime、LocalDateTime的操作</p>
<h4 id="日期时间的修改和比较"><a href="#日期时间的修改和比较" class="headerlink" title="日期时间的修改和比较"></a>日期时间的修改和比较</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746979632-3ebe66c5-3281-4fa8-ab6a-39d7e707e83c.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=348&id=ude506394&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197602&status=done&style=none&taskId=u5786614b-575b-40d3-80a7-7882f632e68&title=&width=751.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747163521-9d9f746f-d8d8-46ca-912c-6dda46a9f7c8.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=494&id=u40ab0fdd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=303832&status=done&style=none&taskId=u986d62ac-18f0-40b9-9014-507c70af771&title=&width=764.8" alt="image.png"><br>变量后加soutv，可以快速打印，并且是v = 的形式<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747360936-51b80635-f45e-44ff-b1e8-54b70789664f.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=334&id=u74e0693f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204069&status=done&style=none&taskId=u96db3670-0c7b-49b1-a245-9e43918356e&title=&width=769.6" alt="image.png"><br>新日期API在多线程场景下是日期安全的，因为他创建了一个新对象，不是在原对象基础上修改的</p>
<h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747567914-6737e3ba-c7f3-498b-9e12-0bbceaf1ee5d.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=360&id=uda475eec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&size=299194&status=done&style=none&taskId=u141ebb62-febf-4906-85e4-3be55e90007&title=&width=1012" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747639659-16bb6f50-b9ea-4d4f-9213-091daeda2011.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=143&id=u14867fbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=179&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109495&status=done&style=none&taskId=u4f7ad158-e52b-488a-a64e-475575b3103&title=&width=955.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748259901-7b8787ea-4f14-43c9-b4db-2612d5fa5a14.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=116&id=u50d66240&margin=%5Bobject%20Object%5D&name=image.png&originHeight=145&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65035&status=done&style=none&taskId=u93f47d88-1f85-4da2-be09-2d8e42e4b21&title=&width=490.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748172134-3138a5a2-f8a1-4580-b00e-7293df637fe5.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=438&id=uaf1fcb26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252551&status=done&style=none&taskId=u967fca3e-0e36-462d-95a0-847fed13f3c&title=&width=734.4" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748632770-069986bb-ba90-4a16-8a76-01caf5caee6a.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=113&id=u4d0a4b31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67287&status=done&style=none&taskId=u4794be92-5689-4b13-81b0-300b0fa05d7&title=&width=688" alt="image.png"><br>使用方法引用打印更加的简洁<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748836615-aeadf7ea-85a8-45b7-8c19-c83595e6a94e.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=769&id=uc3a68617&margin=%5Bobject%20Object%5D&name=image.png&originHeight=961&originWidth=1224&originalType=binary&ratio=1&rotation=0&showTitle=false&size=498945&status=done&style=none&taskId=ueb268e45-dcad-43aa-9d5f-345ea507ab2&title=&width=979.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748960552-503db30c-9118-414f-a1c5-1f91addfa5c0.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=uaef9a9b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=237&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119465&status=done&style=none&taskId=ue30be5b6-8ad7-402a-9715-bcf78e05b76&title=&width=768" alt="image.png"></p>
<h3 id="八、其他新特性"><a href="#八、其他新特性" class="headerlink" title="八、其他新特性"></a>八、其他新特性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647749367561-15481f08-5408-4e50-a762-ba9ced27ef07.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=513&id=u0733fda8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=641&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156840&status=done&style=none&taskId=u73d5fecf-de65-4bd0-99df-7b64ed9f20e&title=&width=620.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647749476548-015f1e9c-08d9-4665-b31e-e42e850d0155.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=148&id=u93d98f85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=701&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64487&status=done&style=none&taskId=u2415e2cd-4be1-4c55-93d1-21bf847d7a7&title=&width=560.8" alt="image.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jdk新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习</title>
    <url>/posts/1141.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="设计模式学习"><a href="#设计模式学习" class="headerlink" title="设计模式学习"></a>设计模式学习</h1><h2 id="一、面向对象设计原则-7原则"><a href="#一、面向对象设计原则-7原则" class="headerlink" title="一、面向对象设计原则(7原则)"></a>一、面向对象设计原则(7原则)</h2><p>我们在进行软件开发时，不仅需要将基本的业务给完成，还要考虑整个项目的可维护性和可复用性，我们开发的项目不单单需要我们自己来维护，也需要其他的开发者一起来进行共同维护，因此我们在编写代码时，应该尽可能的规范。如果我们在编写代码时不注重这些问题，随着项目的不断扩大，整体结构只会越来越糟。为了避免这种情况的发生，我们就可以使用设计模式</p>
<span id="more"></span>

<h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><blockquote>
<p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个人类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人类会编程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂打螺丝也会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工厂打螺丝也会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 送外卖也会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;送外卖也会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个People类啥都会，显然这个People太过臃肿，根据单一职责原则，我们需要进行更明确的划分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序员会编程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工人会打螺丝&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;骑手会送外卖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将类的粒度进行近一步划分，以后在设计Mapper、Service、Controller时，根据不同的业务进行划分，都可以采用单一职责原则</p>
<h3 id="2、开闭原则"><a href="#2、开闭原则" class="headerlink" title="2、开闭原则"></a>2、开闭原则</h3><blockquote>
<p>软件实体应当对扩展开放，对修改关闭</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JavaCoder</span> <span class="keyword">extends</span> <span class="title">Coder</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java太卷了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PHPCoder</span> <span class="keyword">extends</span> <span class="title">Coder</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;PHP是世界上最好的语言&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CCoder</span> <span class="keyword">extends</span> <span class="title">Coder</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;底层还是得找我&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的程序员可以自由地决定他们该如何进行编程，这是扩展开放；具体哪个程序员使用什么语言怎么编程，不需要其他程序员干涉，这是修改关闭</p>
<h3 id="3、里氏替换原则"><a href="#3、里氏替换原则" class="headerlink" title="3、里氏替换原则"></a>3、里氏替换原则</h3><blockquote>
<p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JavaCoder</span> <span class="keyword">extends</span> <span class="title">Coder</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">game</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;艾欧尼亚最强王者已上号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里我们对父类的行为进行了重写，现在它不再具备父类原本的能力了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;摆烂了，啊对对对&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;emo结束，继续卷&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对父类的方法进行了重写，子类已经不具备父类的原本的行为，违背了里氏替换原则</p>
<p>正确的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;   <span class="comment">//这个行为还是定义出来，但是不实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我会打代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JavaCoder</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">game</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;艾欧尼亚最强王者已上号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;摆烂了，啊对对对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、依赖倒转原则"><a href="#4、依赖倒转原则" class="headerlink" title="4、依赖倒转原则"></a>4、依赖倒转原则</h3><blockquote>
<p>高层模块不应该依赖低层模块，二者都应该依赖接口</p>
</blockquote>
<p>未使用依赖倒转原则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyReverse</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">		System.out.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用接口实现依赖倒转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyReverse</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		person.receive(<span class="keyword">new</span> Wechat());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceive</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceive</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> <span class="keyword">implements</span> <span class="title">IReceive</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,world--wechat&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceive info)</span> </span>&#123;</span><br><span class="line">		System.out.println(info.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h3><blockquote>
<p>对接口的细化</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCpu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getMemory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑就是一种电子设备，那么我们就实现此接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i9-12900K&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电脑&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;32G DDR5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电风扇也算是一种电子设备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fan</span> <span class="keyword">implements</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//就一个破风扇，还需要CPU？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风扇&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//风扇也不需要内存吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>风扇不需要CPU和内存，我们要对其进行更细粒度的划分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SmartDevice</span> </span>&#123;   <span class="comment">//智能设备才有getCpu和getMemory</span></span><br><span class="line">    <span class="function">String <span class="title">getCpu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getMemory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NormalDevice</span> </span>&#123;   <span class="comment">//普通设备只有getType</span></span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑是一种智能设备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">SmartDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i9-12900K&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电脑&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;32G DDR5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电风扇是一种普通设备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fan</span> <span class="keyword">implements</span> <span class="title">NormalDevice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风扇&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h3><blockquote>
<p>优先使用对象组合，而不是通过继承来达到复用的目的</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是连接数据库操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;    <span class="comment">//直接通过继承的方式，得到A的数据库连接逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);</span><br><span class="line">        connectDatabase();   <span class="comment">//直接调用父类方法就行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码耦合度太高，修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是连接数据库操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;   <span class="comment">//不进行继承，而是在用的时候给我一个A，当然也可以抽象成一个接口，更加灵活</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);</span><br><span class="line">        a.connectDatabase();   <span class="comment">//在通过传入的对象A去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、迪米特法则"><a href="#7、迪米特法则" class="headerlink" title="7、迪米特法则"></a>7、迪米特法则</h3><blockquote>
<p>一个类对其他类交互越少越好，目的还是降低耦合度</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);   <span class="comment">//假设我们当前的程序需要进行网络通信</span></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.test(socket);   <span class="comment">//现在需要执行test方法来做一些事情</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比如test方法需要得到我们当前Socket连接的本地地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IP地址：&quot;</span>+socket.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.test(socket.getLocalAddress());  <span class="comment">//在外面解析好就行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;   <span class="comment">//一个字符串就能搞定，就没必要丢整个对象进来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;IP地址：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、创建型-5种"><a href="#二、创建型-5种" class="headerlink" title="二、创建型(5种)"></a>二、创建型(5种)</h2><h3 id="1、工厂方法模式"><a href="#1、工厂方法模式" class="headerlink" title="1、工厂方法模式"></a>1、工厂方法模式</h3><blockquote>
<p>当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，而不是直接new一个对象。这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改</p>
</blockquote>
<p>以前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;   <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot;@&quot;</span>+hashCode();   <span class="comment">//打印一下当前水果名称，还有对象的hashCode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;   <span class="comment">//苹果，继承自水果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;  <span class="comment">//橘子，也是继承自水果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        System.out.println(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt; </span>&#123;   <span class="comment">//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getFruit</span><span class="params">()</span></span>;  <span class="comment">//不同的水果工厂，通过此方法生产不同的水果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">FruitFactory</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;  <span class="comment">//苹果工厂，直接返回Apple，一步到位</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> AppleFactory()::getFruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、抽象工厂模式"><a href="#2、抽象工厂模式" class="headerlink" title="2、抽象工厂模式"></a>2、抽象工厂模式</h3><blockquote>
<p>工厂方法模式只适用于简单对象，当我们需要多个产品族的时候，就需要抽象工厂模式</p>
</blockquote>
<p>比如小米产品线上生产小米手机、小米平板、小米路由；华为产品线上生产华为手机、华为平板、华为路由；Apple产品线上生产iPhone、iPad、AirPort</p>
<p>按工厂方法模式，需要创建手机工厂、平板工厂、路由器工厂，然后分别实现三个产品子工厂，共9个工厂</p>
<p>使用抽象工厂模式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Table <span class="title">getTable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Router <span class="title">getRouter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需要创建三个产品族子工厂即可</p>
<h3 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h3><blockquote>
<p>我们通过建造者来不断配置参数或是内容，当我们配置完所有内容后，最后再进行对象的构建</p>
</blockquote>
<p>以前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, <span class="keyword">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.college = college;</span><br><span class="line">        <span class="keyword">this</span>.profession = profession;</span><br><span class="line">        <span class="keyword">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>, Arrays.asList(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数太多，我们得一个个对应着去填，不小心可能把参数填到错误的位置</p>
<p>现在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一律使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, <span class="keyword">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title">builder</span><span class="params">()</span></span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentBuilder</span></span>&#123;   <span class="comment">//这里就直接创建一个内部类</span></span><br><span class="line">        <span class="comment">//Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">id</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      	...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">awards</span><span class="params">(String... awards)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样赋值的方式就比以前优雅多了，lombok提供了@Builder注解，可以直接使用建造者模式</p>
<h3 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h3><blockquote>
<p>只有一个实例对象，SpringBoot采用的就是单例模式 singleton</p>
</blockquote>
<p><strong>饿汉式</strong>，对象在一开始类加载的时候就创建好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();   <span class="comment">//用于引用全局唯一的单例对象，在一开始就创建好</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;   <span class="comment">//不允许随便new，需要对象直接找getInstance</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;   <span class="comment">//获取全局唯一的单例对象</span></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式</strong>，当我们需要获取对象时，才进行检查并创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;   <span class="comment">//在一开始先不进行对象创建</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;   <span class="comment">//将对象的创建延后到需要时再进行</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;    <span class="comment">//如果实例为空，那么就进行创建，不为空说明已经创建过了，那么就直接返回</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境下，如果三条线程同时调用 getInstance() 方法，会导致对象被多次创建，因此需要对懒汉式的写法做一些改进，加上锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;    <span class="comment">//实际上只需要对赋值这一步进行加锁即可</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这样还不完美，因为这样还是有可能多个线程同时判断为null而进入等锁的状态，这样还是会导致对象被多次创建，所以，我们还得加一层内层判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> Singleton();  <span class="comment">//内层还要进行一次检查，双重检查锁定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使这样，我们还缺少了一项内容，我们要添加一个 volatile 给 INSTANCE，INSTANCE的作用是让对象在线程之间可见，这样其他线程才会拿 INSTANCE 的最新值去判断</p>
<h3 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h3><blockquote>
<p>通过原对象拷贝创建新对象</p>
</blockquote>
<p><strong>浅拷贝</strong>：对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//基本类型浅拷贝</span></span><br><span class="line">    System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    Object k = o;    <span class="comment">//引用类型浅拷贝，拷贝的仅仅是对上面对象的引用</span></span><br><span class="line">    System.out.println(o == k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝</strong>：将原对象拷贝成新的对象，我们可以使用 Cloneable 接口实现深拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Student student0 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    Student student1 = (Student) student0.clone();</span><br><span class="line">    System.out.println(student0.getName() == student1.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的 clone 方法只会进行浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">    Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">    student.name = <span class="keyword">new</span> String(name);</span><br><span class="line">    <span class="keyword">return</span> student;   <span class="comment">//成员拷贝完成后，再返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们改进一下，对成员变量也进行拷贝，就实现了深拷贝</p>
<h2 id="三、结构型-7种"><a href="#三、结构型-7种" class="headerlink" title="三、结构型(7种)"></a>三、结构型(7种)</h2><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><blockquote>
<p>比如Macbook为了轻薄全是type-c的接口，而我们现在需要使用usb口，这时需要买一个扩展坞，这实际上就是一种适配模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSupplier</span> </span>&#123;   <span class="comment">//手机供应商类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">supply</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;iPhone 14 Pro&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;    <span class="comment">//手机供应商接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">supply</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestSupplier supplier = new TestSupplier();</span><br><span class="line">      	test( ? ); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(Target target)&#123;   //test方法只支持手机供应商接口，但是我们想要传入TestSupplier手机供应商类，使用其中的supply方法</span><br><span class="line">        System.out.println(&quot;成功得到：&quot;+target.supply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    TestSupplier supplier;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAdapter</span><span class="params">(TestSupplier supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">supply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.doSupply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestAdapter adapter = <span class="keyword">new</span> TestAdapter();</span><br><span class="line">    test(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Target target)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成功得到：&quot;</span>+target.supply());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h3><blockquote>
<p>买奶茶时，我们需要确认大中小杯、什么配料，不同类型的奶茶都要去创建一个类。桥接模式就是，将奶茶的类型作为最基本的抽象类，然后对尺寸、配料等属性进行桥接</p>
</blockquote>
<p>以前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tea</span> </span>&#123;   <span class="comment">//不同奶茶类型</span></span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Size</span> </span>&#123;   <span class="comment">//分大杯中杯小杯</span></span><br><span class="line">    <span class="function">String <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大杯芋圆啵啵奶茶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeKissTea</span> <span class="keyword">implements</span> <span class="title">Tea</span>, <span class="title">Size</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;大杯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;芋圆啵啵奶茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTea</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Size size;   <span class="comment">//尺寸作为桥接属性存放在类中</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractTea</span><span class="params">(Size size)</span></span>&#123;   <span class="comment">//在构造时需要知道尺寸属性</span></span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getType</span><span class="params">()</span></span>;   <span class="comment">//奶茶类型由子类决定</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span></span>&#123;   <span class="comment">//添加尺寸维度获取方式</span></span><br><span class="line">        <span class="keyword">return</span> size.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要为Size创建子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Large</span> <span class="keyword">implements</span> <span class="title">Size</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;大杯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建芋圆啵啵奶茶子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KissTea</span> <span class="keyword">extends</span> <span class="title">AbstractTea</span></span>&#123;   <span class="comment">//创建一个芋圆啵啵奶茶的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KissTea</span><span class="params">(Size size)</span> </span>&#123;   <span class="comment">//在构造时需要指定具体的大小实现</span></span><br><span class="line">        <span class="keyword">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;芋圆啵啵奶茶&quot;</span>;   <span class="comment">//返回奶茶类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    KissTea tea = <span class="keyword">new</span> KissTea(<span class="keyword">new</span> Large());</span><br><span class="line">    System.out.println(tea.getType());</span><br><span class="line">    System.out.println(tea.getSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、组合模式"><a href="#3、组合模式" class="headerlink" title="3、组合模式"></a>3、组合模式</h3><blockquote>
<p>使用 Employee 类来创建和打印员工的层次结构，打印所有员工</p>
</blockquote>
<p>创建 Employee 类，该类带有 Employee 对象的列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span>+ name </span><br><span class="line">      +<span class="string">&quot;, dept : &quot;</span>+ dept + <span class="string">&quot;, salary :&quot;</span></span><br><span class="line">      + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Employee 类来创建和打印员工的层次结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Employee CEO = <span class="keyword">new</span> Employee(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;CEO&quot;</span>, <span class="number">30000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee headSales = <span class="keyword">new</span> Employee(<span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Head Sales&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">&quot;Michel&quot;</span>,<span class="string">&quot;Head Marketing&quot;</span>, <span class="number">20000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Laura&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">      Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Marketing&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Richard&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">      Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">&quot;Rob&quot;</span>,<span class="string">&quot;Sales&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">      CEO.add(headSales);</span><br><span class="line">      CEO.add(headMarketing);</span><br><span class="line"> </span><br><span class="line">      headSales.add(salesExecutive1);</span><br><span class="line">      headSales.add(salesExecutive2);</span><br><span class="line"> </span><br><span class="line">      headMarketing.add(clerk1);</span><br><span class="line">      headMarketing.add(clerk2);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//打印该组织的所有员工</span></span><br><span class="line">      System.out.println(CEO); </span><br><span class="line">      <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">         System.out.println(headEmployee);</span><br><span class="line">         <span class="keyword">for</span> (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee :[ Name : John, dept : CEO, salary :<span class="number">30000</span> ]</span><br><span class="line">Employee :[ Name : Robert, dept : Head Sales, salary :<span class="number">20000</span> ]</span><br><span class="line">Employee :[ Name : Richard, dept : Sales, salary :<span class="number">10000</span> ]</span><br><span class="line">Employee :[ Name : Rob, dept : Sales, salary :<span class="number">10000</span> ]</span><br><span class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :<span class="number">20000</span> ]</span><br><span class="line">Employee :[ Name : Laura, dept : Marketing, salary :<span class="number">10000</span> ]</span><br><span class="line">Employee :[ Name : Bob, dept : Marketing, salary :<span class="number">10000</span> ]</span><br></pre></td></tr></table></figure>

<h3 id="4、装饰模式"><a href="#4、装饰模式" class="headerlink" title="4、装饰模式"></a>4、装饰模式</h3><blockquote>
<p>对现有的类进行装饰</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;   <span class="comment">//顶层抽象类，定义了一个test方法执行业务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是业务方法&quot;</span>);   <span class="comment">//具体的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的实现类太单调了，我们加一点装饰上去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;   <span class="comment">//装饰者需要将装饰目标组合到类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Base base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Base base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        base.test();    <span class="comment">//这里还是使用原本方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DecoratorImpl extends Decorator&#123;   //装饰实现</span><br><span class="line"></span><br><span class="line">    public DecoratorImpl(Base base) &#123;</span><br><span class="line">        super(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;    //对原本的方法进行装饰，我们可以在前后都去添加额外操作</span><br><span class="line">        System.out.println(&quot;装饰方法：我是操作前逻辑&quot;);</span><br><span class="line">        super.test();</span><br><span class="line">        System.out.println(&quot;装饰方法：我是操作后逻辑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现装饰模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Base base = <span class="keyword">new</span> BaseImpl();</span><br><span class="line">    Decorator decorator = <span class="keyword">new</span> DecoratorImpl(base);  <span class="comment">//将Base对象进行装饰</span></span><br><span class="line">    </span><br><span class="line">    decorator.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、代理模式"><a href="#5、代理模式" class="headerlink" title="5、代理模式"></a>5、代理模式</h3><blockquote>
<p>对现有的类进行代理</p>
</blockquote>
<p>实现代理模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;  <span class="comment">//此类无法直接使用，需要我们进行代理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是测试方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;   <span class="comment">//为了保证和Subject操作方式一样，保证透明性，也得继承</span></span><br><span class="line"></span><br><span class="line">    Subject target;   <span class="comment">//被代理的对象（甚至可以多重代理）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;   <span class="comment">//由代理去执行被代理对象的方法，并且我们还可以在前后添油加醋</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理前绕方法&quot;</span>);</span><br><span class="line">        target.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理后绕方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理模式和装饰模式很像，不同的在于思想。装饰模式强调增强自身；代理模式强调让别人帮你做事情，比如记录日志、设置缓存等</p>
<h3 id="6、外观模式"><a href="#6、外观模式" class="headerlink" title="6、外观模式"></a>6、外观模式</h3><blockquote>
<p>比如我们需要吃饭，需要做买菜、煮菜、吃饭的准备，但是现在我们通过门面统一来完成，这就是外观模式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;煮菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加一个门面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SubSystemA a = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">    SubSystemB b = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">    SubSystemC c = <span class="keyword">new</span> SubSystemC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">havaLunch</span><span class="params">()</span></span>&#123;   <span class="comment">//吃饭一条龙服务</span></span><br><span class="line">        a.test1();</span><br><span class="line">        b.test2();</span><br><span class="line">        c.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">    facade.havaLunch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外观模式简化了流程</p>
<h3 id="7、享元模式"><a href="#7、享元模式" class="headerlink" title="7、享元模式"></a>7、享元模式</h3><blockquote>
<p>将重复出现的内容作为共享部分取出。比如现在我们有两个服务，但是他们都需要使用数据库工具类来操作，实际上这个工具类没必要创建多个，我们这时就可以使用享元模式，让数据库工具类作为享元类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectDB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是数据库操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtilFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DBUtil UTIL = <span class="keyword">new</span> DBUtil();   <span class="comment">//享元对象被存放在工厂中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DBUtil <span class="title">getFlyweight</span><span class="params">()</span></span>&#123;   <span class="comment">//获取享元对象</span></span><br><span class="line">        <span class="keyword">return</span> UTIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要使用数据库，直接找享元工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;   <span class="comment">//用户服务</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DBUtil util = DBUtilFactory.getFlyweight();   <span class="comment">//通过享元工厂拿到DBUtil对象</span></span><br><span class="line">        util.selectDB();    <span class="comment">//数据库操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、行为型-11种"><a href="#四、行为型-11种" class="headerlink" title="四、行为型(11种)"></a>四、行为型(11种)</h2><h3 id="1、解释器模式"><a href="#1、解释器模式" class="headerlink" title="1、解释器模式"></a>1、解释器模式</h3><blockquote>
<p>该设计模式比较少使用，就是对我们的语言进行解释</p>
</blockquote>
<p>比如我们输入：1+2*3，最后得到结果7，这就是解释器模式</p>
<h3 id="2、模板方法模式"><a href="#2、模板方法模式" class="headerlink" title="2、模板方法模式"></a>2、模板方法模式</h3><blockquote>
<p>在程序中，某些操作是固定的，而有些操作需要视情况而定，由不同的子类实现，这时要用到模板方法模式</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象诊断方法，因为现在只知道挂号和看医生是固定模式，剩下的开处方和拿药都是不确定的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDiagnosis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;今天头好晕，不想起床，开摆，先跟公司请个假&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;去医院看病了~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1 &gt;&gt; 先挂号&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2 &gt;&gt; 等待叫号&quot;</span>);</span><br><span class="line">        <span class="comment">//由于现在不知道该开什么处方，所以只能先定义一下行为，然后具体由子类实现</span></span><br><span class="line">      	<span class="comment">//大致的流程先定义好就行</span></span><br><span class="line">        <span class="keyword">this</span>.prescribe();</span><br><span class="line">        <span class="keyword">this</span>.medicine();  <span class="comment">//开药同理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prescribe</span><span class="params">()</span></span>;   <span class="comment">//开处方操作根据具体病症决定了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">medicine</span><span class="params">()</span></span>;   <span class="comment">//拿药也是根据具体的处方去拿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 感冒相关的具体实现子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDiagnosis</span> <span class="keyword">extends</span> <span class="title">AbstractDiagnosis</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prescribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3 &gt;&gt; 没有感冒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">medicine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4 &gt;&gt; 开点头孢回去吃吧&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractDiagnosis diagnosis = <span class="keyword">new</span> ColdDiagnosis();</span><br><span class="line">    diagnosis.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看病的逻辑已经由父类定义好了，所以子类只需要实现需要实现的部分即可，这样我们就实现了简单的模板方法模式</p>
<h3 id="3、责任链模式"><a href="#3、责任链模式" class="headerlink" title="3、责任链模式"></a>3、责任链模式</h3><blockquote>
<p>使用责任链模式来模拟一个简单的面试过程，按一面二面三面这样走的流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;    <span class="comment">//这里我们就设计责任链以单链表形式存在，这里存放后继节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">connect</span><span class="params">(Handler successor)</span></span>&#123;     <span class="comment">//拼接后续节点</span></span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">        <span class="keyword">return</span> successor;  <span class="comment">//这里返回后继节点，方便我们一会链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doHandle();   <span class="comment">//由不同的子类实现具体处理过程</span></span><br><span class="line">        Optional</span><br><span class="line">                .ofNullable(successor)</span><br><span class="line">                .ifPresent(Handler::handle);    <span class="comment">//责任链上如果还有后继节点，就继续向下传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">()</span></span>;   <span class="comment">//结合上节课学习的模板方法，交给子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;   <span class="comment">//用于一面的处理器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 一面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 谈谈你对static关键字的理解？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 内部类可以调用外部的数据吗？如果是静态的呢？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. hashCode()方法是所有的类都有吗？默认返回的是什么呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;  <span class="comment">//二面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 二面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 如果我们自己创建一个java.lang包并且编写一个String类，能否实现覆盖JDK默认的？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. HashMap的负载因子有什么作用？变化规律是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 线程池的运作机制是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. ReentrantLock公平锁和非公平锁的区别是什么？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;  <span class="comment">//三面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 三面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. synchronized关键字了解吗？如何使用？底层是如何实现的？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. IO和NIO的区别在哪里？NIO三大核心组件？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. TCP握手和挥手流程？少一次握手可以吗？为什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 操作系统中PCB是做什么的？运行机制是什么？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写好每一轮的面试流程，我们就可以构建一个责任链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> FirstHandler();  <span class="comment">//一面首当其冲</span></span><br><span class="line">    handler</span><br><span class="line">            .connect(<span class="keyword">new</span> SecondHandler())   <span class="comment">//继续连接二面和三面</span></span><br><span class="line">            .connect(<span class="keyword">new</span> ThirdHandler());</span><br><span class="line">    handler.handle();   <span class="comment">//开始面试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、命令模式"><a href="#4、命令模式" class="headerlink" title="4、命令模式"></a>4、命令模式</h3><blockquote>
<p>比如现在我们有很多的类，彩电、冰箱、空调等，我们要通过一个遥控器去控制他们，就需要将控制这些电器的指令都给设计好，而且还不能有太强的关联性</p>
</blockquote>
<p>所有的电器都是接收者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;   <span class="comment">//具体行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要控制这些电器，那么肯定需要一个指令才能控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;   <span class="comment">//指令抽象，不同的电器有指令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Command</span><span class="params">(Receiver receiver)</span></span>&#123;   <span class="comment">//指定此命令对应的电器（接受者）</span></span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();   <span class="comment">//执行命令，实际上就是让接收者开始干活</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个遥控器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;   <span class="comment">//遥控器只需要把我们的指令发出去就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个空调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirConditioner</span> <span class="keyword">implements</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空调已开启，呼呼呼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个开启空调的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenCommand</span><span class="params">(AirConditioner airConditioner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(airConditioner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过遥控器开启空调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AirConditioner airConditioner = <span class="keyword">new</span> AirConditioner();   <span class="comment">//先创建一个空调</span></span><br><span class="line">    Controller.call(<span class="keyword">new</span> OpenCommand(airConditioner));   <span class="comment">//直接通过遥控器来发送空调开启命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、迭代器模式"><a href="#5、迭代器模式" class="headerlink" title="5、迭代器模式"></a>5、迭代器模式</h3><blockquote>
<p>通过迭代器进行集合的遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;   <span class="comment">//使用foreach语法进行迭代，依次获取每一个元素</span></span><br><span class="line">        System.out.println(s);   <span class="comment">//打印一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后使用的是迭代器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    Iterator var2 = list.iterator();   <span class="comment">//实际上这里本质是通过List生成的迭代器来遍历我们每个元素的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;   <span class="comment">//判断是否还有元素可以迭代，没有就false</span></span><br><span class="line">        String s = (String)var2.next();   <span class="comment">//通过next方法得到下一个元素，每调用一次，迭代器会向后移动一位</span></span><br><span class="line">        System.out.println(s);    <span class="comment">//打印一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、中介者模式"><a href="#6、中介者模式" class="headerlink" title="6、中介者模式"></a>6、中介者模式</h3><blockquote>
<p>程序中可能会出现很多的对象，这些对象之间的调用关系错综复杂，可能一个对象要做上面事情就得联系好几个对象。这时如果设置一个中间人，只需要联系中间人即可</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;   <span class="comment">//房产中介</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//在出售的房子需要存储一下</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String address, User user)</span></span>&#123;   <span class="comment">//出租房屋的人，需要告诉中介他的房屋在哪里</span></span><br><span class="line">        userMap.put(address, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String address)</span></span>&#123;   <span class="comment">//找房的人通过此方法来看看有没有对应的房源</span></span><br><span class="line">        <span class="keyword">return</span> userMap.get(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户有两种角色，一种是租房，一种是出租</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;   <span class="comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span></span><br><span class="line">    String name;</span><br><span class="line">    String tel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String tel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String address, Mediator mediator)</span></span>&#123;   <span class="comment">//找房子的话，需要一个中介和你具体想找的地方</span></span><br><span class="line">        <span class="keyword">return</span> mediator.find(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (电话：&quot;</span>+tel+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user0 = <span class="keyword">new</span> User(<span class="string">&quot;刘女士&quot;</span>, <span class="string">&quot;10086&quot;</span>);   <span class="comment">//出租人</span></span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="string">&quot;李先生&quot;</span>, <span class="string">&quot;10010&quot;</span>);   <span class="comment">//找房人</span></span><br><span class="line">    Mediator mediator = <span class="keyword">new</span> Mediator();   <span class="comment">//我是中介</span></span><br><span class="line"></span><br><span class="line">    mediator.register(<span class="string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, user0);   <span class="comment">//先把房子给中介挂上去</span></span><br><span class="line"></span><br><span class="line">    User user = user1.find(<span class="string">&quot;成都市武侯区天府五街下硅谷&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) System.out.println(<span class="string">&quot;没有找到对应的房源&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user = user1.find(<span class="string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//成功找到对应房源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系</p>
<h3 id="7、备忘录模式"><a href="#7、备忘录模式" class="headerlink" title="7、备忘录模式"></a>7、备忘录模式</h3><blockquote>
<p>为我们的软件提供了一个可回溯的时间节点，可能我们程序在运行过程中某一步出现了错误，这时我们就可以回到之前某个节点重新来过</p>
</blockquote>
<p>学生对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String currentWork;   <span class="comment">//当前正在做的事情</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> percentage;   <span class="comment">//当前的工作完成百分比</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(String currentWork)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentWork = currentWork;</span><br><span class="line">        <span class="keyword">this</span>.percentage = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我现在正在做：&quot;</span>+currentWork+<span class="string">&quot; (进度：&quot;</span>+percentage+<span class="string">&quot;%)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态保存类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String currentWork;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> percentage;</span><br><span class="line"></span><br><span class="line">    State(String currentWork, <span class="keyword">int</span> percentage) &#123;   <span class="comment">//仅开放给同一个包下的Student类使用</span></span><br><span class="line">        <span class="keyword">this</span>.currentWork = currentWork;</span><br><span class="line">        <span class="keyword">this</span>.percentage = percentage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现状态的保存和恢复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> State(currentWork, percentage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(State state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentWork = state.currentWork;</span><br><span class="line">        <span class="keyword">this</span>.percentage = state.percentage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.work(<span class="string">&quot;学Java&quot;</span>);   <span class="comment">//开始学Java</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    State savedState = student.save();   <span class="comment">//保存一下当前的状态</span></span><br><span class="line"></span><br><span class="line">    student.work(<span class="string">&quot;打游戏&quot;</span>);   <span class="comment">//学一半，然后开始打游戏</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    student.restore(savedState);   <span class="comment">//两级反转！回到上一个保存的状态</span></span><br><span class="line">    System.out.println(student);   <span class="comment">//回到学Java的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、观察者模式"><a href="#8、观察者模式" class="headerlink" title="8、观察者模式"></a>8、观察者模式</h3><blockquote>
<p>当对象发生改变时，观察者能够立刻观察到并进行一些联动操作</p>
</blockquote>
<p>观察者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;   <span class="comment">//观察者接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;   <span class="comment">//当对象有更新时，会回调此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(Observer observer)</span> </span>&#123;   <span class="comment">//添加观察者</span></span><br><span class="line">        observerSet.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> </span>&#123;   <span class="comment">//模拟对象进行修改</span></span><br><span class="line">        observerSet.forEach(Observer::update);   <span class="comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">    <span class="comment">//当对象发生修改时，会通知所有的观察者，进行方法回调</span></span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是一号观察者！&quot;</span>));</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是二号观察者！&quot;</span>));</span><br><span class="line">    subject.modify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是一号观察者！</span><br><span class="line">我是二号观察者！</span><br></pre></td></tr></table></figure>

<h3 id="9、状态模式"><a href="#9、状态模式" class="headerlink" title="9、状态模式"></a>9、状态模式</h3><blockquote>
<p>水在不同的温度下呈现不同的状态，这就是状态模式</p>
</blockquote>
<p>我们来设计一个学生类，然后学生的学习方法会根据状态不同而发生改变，我们先设计一个状态枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;   <span class="comment">//状态直接使用枚举定义</span></span><br><span class="line">    NORMAL, REST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;   <span class="comment">//使用一个成员来存储状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;   <span class="comment">//根据不同的状态，学习方法会有不同的结果</span></span><br><span class="line">            <span class="keyword">case</span> REST:</span><br><span class="line">                System.out.println(<span class="string">&quot;学累了，我去休息一会儿&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NORMAL:</span><br><span class="line">                System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setState(State.NORMAL);   <span class="comment">//先正常模式</span></span><br><span class="line">    student.study();</span><br><span class="line"></span><br><span class="line">    student.setState(State.LAZY);   <span class="comment">//开启休息模式</span></span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、策略模式"><a href="#10、策略模式" class="headerlink" title="10、策略模式"></a>10、策略模式</h3><blockquote>
<p>为对象设定一种策略，之后对象的行为就按这个策略执行。跟刚刚说的状态模式有点像，区别在于策略模式由我们指定，状态模式是运行过程中自动切换</p>
</blockquote>
<p>策略模式其实我们以前也遇到过，比如线程池的各种策略，拒绝策略、抛弃策略、抛弃最老策略等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),  <span class="comment">//这里不给排队</span></span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());   <span class="comment">//这里指定线程池为拒绝策略</span></span><br><span class="line"></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    executor.execute(runnable);   <span class="comment">//连续提交两次任务，肯定塞不下，这时就得走拒绝了</span></span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、访问者模式"><a href="#11、访问者模式" class="headerlink" title="11、访问者模式"></a>11、访问者模式</h3><blockquote>
<p>不同的访问者对某一件事务的处理可能不同</p>
</blockquote>
<p>比如我们日以继夜地努力，终于在某某比赛赢得了冠军，而不同的访问者对这份荣誉有不同的反应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prize</span> </span>&#123;   <span class="comment">//奖</span></span><br><span class="line">    String name;   <span class="comment">//比赛名称</span></span><br><span class="line">    String level;    <span class="comment">//等级</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prize</span><span class="params">(String name, String level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Prize prize)</span></span>;   <span class="comment">//visit方法来访问我们的奖项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;   <span class="comment">//指导老师作为一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Prize prize)</span> </span>&#123;   <span class="comment">//老师关心你得了什么奖以及是几等奖</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你得了什么奖？&quot;</span>+prize.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;你得了几等奖？&quot;</span>+prize.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Family</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;    <span class="comment">//家人作为一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Prize prize)</span> </span>&#123;   <span class="comment">//你的家人并不最先关心你得了什么奖，而是先关心你自己然后才是奖项</span></span><br><span class="line">        System.out.println(<span class="string">&quot;孩子，辛苦了，有没有好好照顾自己啊&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你得了什么奖啊？&quot;</span>+prize.name+<span class="string">&quot;，很不错，要继续加油啊！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问者模式将奖项本身的属性和对于奖项的不同操作进行了分离</p>
<h1 id="小傅哥设计模式"><a href="#小傅哥设计模式" class="headerlink" title="小傅哥设计模式"></a>小傅哥设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706019083815-c268248c-a0d8-474b-b40a-e7fa172da921.png?x-oss-process=image/resize,w_642,limit_0"></p>
<h3 id="1、工厂方法模式-1"><a href="#1、工厂方法模式-1" class="headerlink" title="1、工厂方法模式"></a>1、工厂方法模式</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1705754450281-e90db75c-3c10-4570-a3e0-3d4329241487.png"></p>
<h3 id="2、结构型模式"><a href="#2、结构型模式" class="headerlink" title="2、结构型模式"></a>2、结构型模式</h3><h3 id="3、建造者模式-1"><a href="#3、建造者模式-1" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h3><h3 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h3><h3 id="5、单例模式"><a href="#5、单例模式" class="headerlink" title="5、单例模式"></a>5、单例模式</h3><p>懒汉、饿汉、线程是否安全、静态类、内部类、加锁、串行化</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h3 id="6、适配器模式"><a href="#6、适配器模式" class="headerlink" title="6、适配器模式"></a>6、适配器模式</h3><h3 id="7、桥接模式"><a href="#7、桥接模式" class="headerlink" title="7、桥接模式"></a>7、桥接模式</h3><h3 id="8、组合模式"><a href="#8、组合模式" class="headerlink" title="8、组合模式"></a>8、组合模式</h3><h3 id="9、装饰器模式"><a href="#9、装饰器模式" class="headerlink" title="9、装饰器模式"></a>9、装饰器模式</h3><h3 id="10、外观模式"><a href="#10、外观模式" class="headerlink" title="10、外观模式"></a>10、外观模式</h3><h3 id="11、享元模式"><a href="#11、享元模式" class="headerlink" title="11、享元模式"></a>11、享元模式</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2024/png/12855610/1706107958434-a2c4d75b-a332-46a0-a1bb-420a9d82cc35.png"></p>
<h3 id="12、代理模式"><a href="#12、代理模式" class="headerlink" title="12、代理模式"></a>12、代理模式</h3><h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><h3 id="13、责任链模式"><a href="#13、责任链模式" class="headerlink" title="13、责任链模式"></a>13、责任链模式</h3><h3 id="14、命令模式"><a href="#14、命令模式" class="headerlink" title="14、命令模式"></a>14、命令模式</h3><h3 id="15、迭代器模式"><a href="#15、迭代器模式" class="headerlink" title="15、迭代器模式"></a>15、迭代器模式</h3><h3 id="16、中介者模式"><a href="#16、中介者模式" class="headerlink" title="16、中介者模式"></a>16、中介者模式</h3><h3 id="17、备忘录模式"><a href="#17、备忘录模式" class="headerlink" title="17、备忘录模式"></a>17、备忘录模式</h3><h3 id="18、策略模式"><a href="#18、策略模式" class="headerlink" title="18、策略模式"></a>18、策略模式</h3><h3 id="19、模板模式"><a href="#19、模板模式" class="headerlink" title="19、模板模式"></a>19、模板模式</h3><h3 id="20、访问者模式"><a href="#20、访问者模式" class="headerlink" title="20、访问者模式"></a>20、访问者模式</h3><p>2024.1.28已完结！</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/posts/c7f5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>开始路途漫漫的计算机网络学习吧，视频来自<a href="https://www.bilibili.com/video/BV1c4411d7jb">计算机网络微课堂</a></p>
</blockquote>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/jpeg/12855610/1630208621955-a4a8ad3a-087d-4521-ab8a-0ca28358b4fd.jpeg?x-oss-process=image/resize,w_750,limit_0"><br>​<span id="more"></span></p>
<h1 id="第1章（概述）"><a href="#第1章（概述）" class="headerlink" title="第1章（概述）"></a>第1章（概述）</h1><h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628777569933-58dd3f9a-ce38-4aba-8626-27d783e01a07.png#clientId=u5bcd3f52-855b-4&from=paste&height=104&id=ubbcf1626&margin=%5Bobject%20Object%5D&name=&originHeight=104&originWidth=1000&originalType=binary&ratio=1&size=96303&status=done&style=none&taskId=uf1ac7f41-93c7-4c5d-ae49-9a88e2478cf&width=1000"></p>
<h2 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628778640771-c607a095-9977-4e60-a27f-d55a4c498e29.png#clientId=u5bcd3f52-855b-4&from=paste&height=179&id=uc944f721&margin=%5Bobject%20Object%5D&name=&originHeight=179&originWidth=1163&originalType=binary&ratio=1&size=131039&status=done&style=none&taskId=u4f04652f-227b-48dc-87c2-23f6d7952ae&width=1163"></p>
<h3 id="因特网服务提供者ISP"><a href="#因特网服务提供者ISP" class="headerlink" title="因特网服务提供者ISP"></a>因特网服务提供者ISP</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779152193-65729399-20d2-4595-9036-3ef181486f82.png#clientId=u5bcd3f52-855b-4&from=paste&height=644&id=uc6be73cd&margin=%5Bobject%20Object%5D&name=&originHeight=644&originWidth=1047&originalType=binary&ratio=1&size=459365&status=done&style=none&taskId=u31f8023d-1da3-4b27-8154-e89ce8957c6&width=1047"></p>
<h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779468596-76a020d5-8599-4ae4-bbe3-4304145f3a17.png#clientId=u5bcd3f52-855b-4&from=paste&height=630&id=u93a628ff&margin=%5Bobject%20Object%5D&name=&originHeight=630&originWidth=1300&originalType=binary&ratio=1&size=464641&status=done&style=none&taskId=u9a57a76d-e150-4a63-9871-f075b8eb7f2&width=1300"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779815480-8af16f6f-f25b-4d48-9014-53176b717c1d.png#clientId=u5bcd3f52-855b-4&from=paste&height=282&id=u86ebf233&margin=%5Bobject%20Object%5D&name=&originHeight=282&originWidth=1083&originalType=binary&ratio=1&size=95378&status=done&style=none&taskId=u828a76be-e1a3-422b-9d0d-d3547a5626c&width=1083"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>用户发送的信息称为报文，将报文分成等长的数据段，数据段加上首部称为分组，也可简称为”包”。首部存放的是分组的目的地址<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628780330715-dfe331ed-8243-48aa-bacc-d23e41a69ff3.png#clientId=u5bcd3f52-855b-4&from=paste&height=521&id=u525e3440&margin=%5Bobject%20Object%5D&name=&originHeight=521&originWidth=984&originalType=binary&ratio=1&size=228921&status=done&style=none&taskId=u2af371e5-b3a3-4d48-8b8e-f308b9fa7c8&width=984"></p>
<h3 id="电路交换、分组交换、报文交换的对比"><a href="#电路交换、分组交换、报文交换的对比" class="headerlink" title="电路交换、分组交换、报文交换的对比"></a>电路交换、分组交换、报文交换的对比</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628841426201-9638448d-ba29-4861-8d10-f91f80f6db19.png#clientId=u5bb285be-1404-4&from=paste&height=425&id=u5e1ac898&margin=%5Bobject%20Object%5D&name=&originHeight=849&originWidth=1874&originalType=binary&ratio=1&size=770247&status=done&style=none&taskId=ub3a5cbab-12d9-4f81-ad5c-a2156053f5d&width=937"></p>
<h2 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628845551278-72841815-6d10-4d00-9446-f98d03d7adee.png#clientId=u5bb285be-1404-4&from=paste&height=104&id=u6f83d95b&margin=%5Bobject%20Object%5D&name=&originHeight=207&originWidth=1142&originalType=binary&ratio=1&size=278066&status=done&style=none&taskId=u0350f4b5-b06d-431b-89f4-76518a998a5&width=571"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>广域网覆盖范围大，局域网覆盖范围小，<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628846531841-26ab0036-589b-4a75-9ad4-1b8bc16d639d.png#clientId=u5bb285be-1404-4&from=paste&height=439&id=u1b0bc7d0&margin=%5Bobject%20Object%5D&name=&originHeight=878&originWidth=1094&originalType=binary&ratio=1&size=668143&status=done&style=none&taskId=u2c86f648-0382-4734-8d49-2c6b781bcac&width=547"></p>
<h2 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628943139704-18617916-77e1-4530-b4bf-014cd51856c0.png#clientId=u008fe770-74df-4&from=paste&height=231&id=u93ed42de&margin=%5Bobject%20Object%5D&name=&originHeight=461&originWidth=1599&originalType=binary&ratio=1&size=400174&status=done&style=none&taskId=uf3ee2cdf-3602-4fb5-bf22-476adf0b4ab&width=799.5"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628943540735-34976ced-d791-4e38-8885-f7947781f2f8.png#clientId=u008fe770-74df-4&from=paste&height=338&id=u0cecd14e&margin=%5Bobject%20Object%5D&name=&originHeight=675&originWidth=1604&originalType=binary&ratio=1&size=408215&status=done&style=none&taskId=u955ff525-4a15-460e-9f73-05aa11e1e52&width=802"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>最好控制信道利用率为50%</p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>只有网络拥塞时才会出现丢包</p>
<h2 id="1-6-计算机网络的体系结构"><a href="#1-6-计算机网络的体系结构" class="headerlink" title="1.6 计算机网络的体系结构"></a>1.6 计算机网络的体系结构</h2><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628944041887-4f8d25b7-21c5-4e50-aac2-807f71dd964e.png#clientId=u008fe770-74df-4&from=paste&height=403&id=uc6766672&margin=%5Bobject%20Object%5D&name=&originHeight=805&originWidth=1220&originalType=binary&ratio=1&size=498670&status=done&style=none&taskId=ud21a8693-6662-4088-9409-3ab19027eb9&width=610"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629102778484-a4375c7d-e25c-46c5-a4b7-634f09065303.png#clientId=u64bc25fb-3b69-4&from=paste&height=188&id=uea4d7f43&margin=%5Bobject%20Object%5D&name=&originHeight=375&originWidth=935&originalType=binary&ratio=1&size=187683&status=done&style=none&taskId=u52f62287-7221-4a4d-8296-17879e42a02&width=467.5"><br>TCP/IP协议协议中，TCP协议和IP协议是比较重要的，IP协议互连不同的网络接口，TCP协议提供数据有效传输<br>四层的TCP/IP协议是国际标准<br>学习计算机网络时，一般折中采用五层协议进行学习<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629102958791-c724a7a7-d0cf-4f1f-9f65-a90dc387d1e5.png#clientId=u64bc25fb-3b69-4&from=paste&height=307&id=ufb7bec20&margin=%5Bobject%20Object%5D&name=&originHeight=613&originWidth=590&originalType=binary&ratio=1&size=230227&status=done&style=none&taskId=u557781a2-d4aa-4a3f-91b9-2e17874c26a&width=295"></p>
<h3 id="计算机网络结构分层的必要性"><a href="#计算机网络结构分层的必要性" class="headerlink" title="计算机网络结构分层的必要性"></a>计算机网络结构分层的必要性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629103392690-4af6eef5-7d70-4750-8369-787181a976b9.png#clientId=u64bc25fb-3b69-4&from=paste&height=364&id=u8560b7aa&margin=%5Bobject%20Object%5D&name=&originHeight=727&originWidth=1817&originalType=binary&ratio=1&size=932937&status=done&style=none&taskId=uf6acf1b9-4a78-4de9-be04-7f6f23ee14c&width=908.5"></p>
<p>计算机网络的分层处理方法，使得数据能够正确传输</p>
<p>各层数据包的举例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629104185818-c08fce11-d4e4-4410-b6fb-1baa70ad5977.png#clientId=u64bc25fb-3b69-4&from=paste&height=366&id=u7361f9a6&margin=%5Bobject%20Object%5D&name=&originHeight=732&originWidth=1128&originalType=binary&ratio=1&size=827790&status=done&style=none&taskId=u69ee9565-cc86-4155-a83b-39ad3261dcd&width=564"><br>下面的协议对上面的实体是透明的</p>
<h2 id="1-7-习题课"><a href="#1-7-习题课" class="headerlink" title="1.7 习题课"></a>1.7 习题课</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629117738283-1cb1a1ae-e61e-4851-bb12-deeb2b02ad3b.png#clientId=ubd2f1b92-2427-4&from=paste&height=123&id=udc342371&margin=%5Bobject%20Object%5D&name=&originHeight=123&originWidth=1191&originalType=binary&ratio=1&size=83808&status=done&style=none&taskId=u7667cc77-34b5-4d7b-a959-9e47d9dc398&width=1191"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629118231321-b842b248-fd5e-4d57-9684-1569864a06f4.png#clientId=ubd2f1b92-2427-4&from=paste&height=288&id=uc8176aee&margin=%5Bobject%20Object%5D&name=&originHeight=288&originWidth=689&originalType=binary&ratio=1&size=135451&status=done&style=none&taskId=u6424df0c-3db1-47f3-ba40-ee60b7a2fb8&width=689"><br>时延计算略<br>​</p>
<h1 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章(物理层)"></a>第2章(物理层)</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629200527694-948834b0-bc43-4c48-b56e-fcc4d4c63a12.png#clientId=u1eb3b024-ecfa-4&from=paste&height=438&id=uc4aa2912&margin=%5Bobject%20Object%5D&name=&originHeight=438&originWidth=629&originalType=binary&ratio=1&size=261785&status=done&style=none&taskId=u730c5340-7af5-4928-a773-62bcfcc5561&width=629"></p>
<h2 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629200855340-646208c1-d520-4774-80e4-51df205cebc4.png#clientId=u1eb3b024-ecfa-4&from=paste&height=128&id=u1cab68d1&margin=%5Bobject%20Object%5D&name=&originHeight=128&originWidth=1364&originalType=binary&ratio=1&size=98667&status=done&style=none&taskId=ueeb2f2a5-01d2-4c57-b4c4-73b5c92f72a&width=1364"></p>
<h2 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629201175213-957f0e0c-59c8-4ba9-9c47-b084e2d006d8.png#clientId=u1eb3b024-ecfa-4&from=paste&height=98&id=ueb416d47&margin=%5Bobject%20Object%5D&name=&originHeight=98&originWidth=1322&originalType=binary&ratio=1&size=62170&status=done&style=none&taskId=u0731372b-75b5-4700-ac94-51366553951&width=1322"><br>计算机网络采用串行传输，计算机内部采用并行传输<br>双向同时通信需要两个信道，举例来说就是电话</p>
<h2 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h2><p>把数字信号转换为模拟信号，在模拟信道中传输，称为调制<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629201848075-40b2b230-6c51-4007-810d-e3a4dbd3e8bc.png#clientId=u1eb3b024-ecfa-4&from=paste&height=524&id=u1e6a7732&margin=%5Bobject%20Object%5D&name=&originHeight=524&originWidth=1214&originalType=binary&ratio=1&size=243345&status=done&style=none&taskId=udb5a7a5a-a603-4911-9dce-a6248f32e28&width=1214"></p>
<h2 id="2-5-信道的极限容量"><a href="#2-5-信道的极限容量" class="headerlink" title="2.5 信道的极限容量"></a>2.5 信道的极限容量<img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629202078655-40d685d9-732d-4faa-bed7-ac8150891280.png#clientId=u1eb3b024-ecfa-4&from=paste&height=587&id=ub64dcd8d&margin=%5Bobject%20Object%5D&name=&originHeight=587&originWidth=1294&originalType=binary&ratio=1&size=351376&status=done&style=none&taskId=u235bff9a-6313-4752-919e-33bd8733634&width=1294"></h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629203564639-b25b0344-4fee-4e93-bfcd-ccad61a1bd76.png#clientId=u5cb0ce9a-30ea-4&from=paste&height=102&id=ua455be91&margin=%5Bobject%20Object%5D&name=&originHeight=102&originWidth=1152&originalType=binary&ratio=1&size=111983&status=done&style=none&taskId=ue7689295-cce4-4ffe-abc8-062a578ba1a&width=1152"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629203626245-d42138f6-e427-49f7-95aa-f726a1a78e7f.png#clientId=u5cb0ce9a-30ea-4&from=paste&height=462&id=ub966c689&margin=%5Bobject%20Object%5D&name=&originHeight=462&originWidth=1012&originalType=binary&ratio=1&size=208642&status=done&style=none&taskId=ue150b397-b462-450f-890a-dcfc5dc2d2a&width=1012"></p>
<h1 id="第3章-数据链路层"><a href="#第3章-数据链路层" class="headerlink" title="第3章(数据链路层)"></a>第3章(数据链路层)</h1><h2 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h2><p>封装成帧   差错检测   可靠传输</p>
<h2 id="3-2-封装成帧"><a href="#3-2-封装成帧" class="headerlink" title="3.2 封装成帧"></a>3.2 封装成帧</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290277118-dd210354-686c-4704-bc50-654f3ae6e50f.png#clientId=ua9168488-b0f8-4&from=paste&height=284&id=u7e86c531&margin=%5Bobject%20Object%5D&name=&originHeight=284&originWidth=1009&originalType=binary&ratio=1&size=198401&status=done&style=none&taskId=u910c6f2c-ad08-45ed-acb7-7961f34e2e2&width=1009"></p>
<h2 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290534706-57cc08d2-63be-4eca-aaa3-d2662a3127c2.png#clientId=ua9168488-b0f8-4&from=paste&height=229&id=ue662ebaf&margin=%5Bobject%20Object%5D&name=&originHeight=229&originWidth=1118&originalType=binary&ratio=1&size=194303&status=done&style=none&taskId=u4f1f72ef-d744-4cec-b970-dd10c5db9c3&width=1118"><br>差错检测方法：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290789366-68ba85f3-8017-488d-9191-d645b78ff6ea.png#clientId=ua9168488-b0f8-4&from=paste&height=213&id=u553f9740&margin=%5Bobject%20Object%5D&name=&originHeight=213&originWidth=1107&originalType=binary&ratio=1&size=191730&status=done&style=none&taskId=ua382a9c1-f1f7-4548-8489-083eb43054f&width=1107"><br>奇偶校验差错高，计算机网络一般不采用这种方法<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290866564-4c155a10-07d4-4ba3-a2c3-9b7722daa9d1.png#clientId=ua9168488-b0f8-4&from=paste&height=196&id=u763f8ddf&margin=%5Bobject%20Object%5D&name=&originHeight=196&originWidth=1226&originalType=binary&ratio=1&size=128459&status=done&style=none&taskId=ucfa771b0-e329-435c-8142-2820364d364&width=1226"><br>循环冗余校验CRC有很好的检错能力，漏检率非常低。<br>检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误。</p>
<h2 id="3-4-可靠传输的基本概念"><a href="#3-4-可靠传输的基本概念" class="headerlink" title="3.4 可靠传输的基本概念"></a>3.4 可靠传输的基本概念</h2><p>可靠传输的实现机制：</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629292662338-65b7f3be-90c8-4359-ab23-16bd67be040c.png#clientId=ua9168488-b0f8-4&from=paste&height=617&id=uf88c4940&margin=%5Bobject%20Object%5D&name=&originHeight=617&originWidth=1312&originalType=binary&ratio=1&size=733181&status=done&style=none&taskId=u3c6ddb6d-7fd1-4dec-beec-6eae827c499&width=1312"><br><strong>数据分组和确认分组需要进行编号</strong></p>
<h3 id="回退N帧协议"><a href="#回退N帧协议" class="headerlink" title="回退N帧协议"></a>回退N帧协议</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629294865323-fd01821d-ed19-47fb-bda4-ccf550b21daf.png#clientId=ua9168488-b0f8-4&from=paste&height=690&id=u2958ac55&margin=%5Bobject%20Object%5D&name=&originHeight=690&originWidth=1312&originalType=binary&ratio=1&size=580852&status=done&style=none&taskId=u4492cdc6-155a-4daa-ba68-ee092892049&width=1312"><br>回退N帧协议又叫发送窗口协议<br>​</p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>为了避免对通信资源的极大浪费，接收窗口的尺寸WR 不应该再等于1<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629296593908-9e67ae88-5c8c-4c13-ae66-444f2b69ca6a.png#clientId=ua9168488-b0f8-4&from=paste&height=577&id=u46696a81&margin=%5Bobject%20Object%5D&name=&originHeight=577&originWidth=1322&originalType=binary&ratio=1&size=369006&status=done&style=none&taskId=u82530c8b-956a-4ba3-8b35-7d14a46d4e0&width=1322"></p>
<h2 id="3-5-点对点协议PPP"><a href="#3-5-点对点协议PPP" class="headerlink" title="3.5 点对点协议PPP"></a>3.5 点对点协议PPP</h2><p>PPP协议是目前使用最广泛的点对点数据链路层协议<br>​</p>
<h2 id="3-6-媒体接入控制"><a href="#3-6-媒体接入控制" class="headerlink" title="3.6 媒体接入控制"></a>3.6 媒体接入控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629297686952-c9a95a94-9dc2-49ab-be72-7bc0cc83eedc.png#clientId=ua9168488-b0f8-4&from=paste&height=137&id=u3eb3596a&margin=%5Bobject%20Object%5D&name=&originHeight=137&originWidth=1305&originalType=binary&ratio=1&size=85954&status=done&style=none&taskId=u538331aa-b395-4aa8-85a2-adbbc0e6ea1&width=1305"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629298839897-0cf743dc-45c3-40c8-a17a-7fa7241d578e.png#clientId=ua9168488-b0f8-4&from=paste&height=460&id=u6e333eaa&margin=%5Bobject%20Object%5D&name=&originHeight=460&originWidth=1331&originalType=binary&ratio=1&size=474262&status=done&style=none&taskId=u00a7b1ae-c54a-458b-be16-2351ef88829&width=1331"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629299237438-6acadd2c-74e8-4da6-8fe9-6aafd356af2a.png#clientId=ua9168488-b0f8-4&from=paste&height=678&id=u81856fd3&margin=%5Bobject%20Object%5D&name=&originHeight=678&originWidth=1187&originalType=binary&ratio=1&size=511831&status=done&style=none&taskId=udcff65b9-de80-47bd-bda5-cd6564763fb&width=1187"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629300122249-e9ab13a0-246c-4eb7-95fb-f77d34517ef3.png#clientId=ua9168488-b0f8-4&from=paste&height=480&id=ue4d3e6c2&margin=%5Bobject%20Object%5D&name=&originHeight=480&originWidth=999&originalType=binary&ratio=1&size=193070&status=done&style=none&taskId=udce33ca2-47e0-48ce-956f-39c82239705&width=999"></p>
<p>CSMA协议有可能发生冲突，也称为碰撞<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301658247-638460fe-1b15-49b6-920e-ec3e6d0db37b.png#clientId=ua9168488-b0f8-4&from=paste&height=50&id=u3d4fc360&margin=%5Bobject%20Object%5D&name=&originHeight=50&originWidth=962&originalType=binary&ratio=1&size=35992&status=done&style=none&taskId=ucb6db744-1d1a-4939-b352-fd8d0d681ec&width=962"></p>
<h2 id="3-7-MAC地址、IP地址、ARP协议"><a href="#3-7-MAC地址、IP地址、ARP协议" class="headerlink" title="3.7 MAC地址、IP地址、ARP协议"></a>3.7 MAC地址、IP地址、ARP协议</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址属于数据链路层的范畴<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301904582-517c8a42-9a3f-4974-8dab-e9509565cd4c.png#clientId=ua9168488-b0f8-4&from=paste&height=303&id=u7a6a9dce&margin=%5Bobject%20Object%5D&name=&originHeight=303&originWidth=824&originalType=binary&ratio=1&size=372037&status=done&style=none&taskId=u3d2b4fec-06b4-4b2d-aee3-e90ff229a0d&width=824"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301998830-48eebe72-6f79-4eb9-8264-f042c1f13ca3.png#clientId=ua9168488-b0f8-4&from=paste&height=76&id=ua24b333d&margin=%5Bobject%20Object%5D&name=&originHeight=76&originWidth=1123&originalType=binary&ratio=1&size=54042&status=done&style=none&taskId=uc91b7081-7c0d-4b33-b79c-049721aac7e&width=1123"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629302321990-6479766a-b622-4d60-9c97-b0ee86971e1c.png#clientId=ua9168488-b0f8-4&from=paste&height=367&id=ueaf2463e&margin=%5Bobject%20Object%5D&name=&originHeight=367&originWidth=1192&originalType=binary&ratio=1&size=238556&status=done&style=none&taskId=ua1762187-c5ac-4828-82e5-b1df28479c7&width=1192"><br>可以从组织唯一标识符，看出硬件生产产商，如华为、小米等，由IEEE分配组织唯一标识符<br>​</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>如果主机所在的网络要接入因特网，那么MAC地址和IP地址都要使用<br>习题：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629303483376-182f0e41-e291-40cb-8737-a62f2ec11dc8.png#clientId=ua9168488-b0f8-4&from=paste&height=373&id=u598afa0c&margin=%5Bobject%20Object%5D&name=&originHeight=373&originWidth=1086&originalType=binary&ratio=1&size=316979&status=done&style=none&taskId=u8515097b-b4e5-4000-8e63-42d6dd12432&width=1086"></p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如果未知目标设备的MAC地址，通过ARP协议，可以获得目标设备的MAC地址。<br>ARP协议只能在一段链路上使用，不能跨网络使用</p>
<h2 id="3-8-集线器与交换机的区别"><a href="#3-8-集线器与交换机的区别" class="headerlink" title="3.8 集线器与交换机的区别"></a>3.8 集线器与交换机的区别</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629303816796-82fa3ecd-6610-4d9d-aeee-6e313b32fd35.png#clientId=ua9168488-b0f8-4&from=paste&height=350&id=ubfb21641&margin=%5Bobject%20Object%5D&name=&originHeight=350&originWidth=607&originalType=binary&ratio=1&size=256324&status=done&style=none&taskId=uca1dff74-87c0-4e8c-94c1-8367d5595f9&width=607"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304226953-e5ce5eef-a733-4da8-b495-22dee74c9772.png#clientId=ua9168488-b0f8-4&from=paste&height=599&id=ud3e8abf6&margin=%5Bobject%20Object%5D&name=&originHeight=599&originWidth=1141&originalType=binary&ratio=1&size=480219&status=done&style=none&taskId=u1d644ff1-450b-4927-830d-86797da63b5&width=1141"></p>
<h2 id="3-9-以太网交换机自学习和转发帧的流程"><a href="#3-9-以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9 以太网交换机自学习和转发帧的流程"></a>3.9 以太网交换机自学习和转发帧的流程</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304325116-f5fe6a7b-e69e-4630-9769-d10762422efe.png#clientId=ua9168488-b0f8-4&from=paste&height=182&id=u94c6727b&margin=%5Bobject%20Object%5D&name=&originHeight=182&originWidth=1144&originalType=binary&ratio=1&size=188050&status=done&style=none&taskId=ufe27744c-72a7-4a7a-a0c5-e85564a8a9f&width=1144"></p>
<h2 id="3-10-以太网交换机的生成树协议STP"><a href="#3-10-以太网交换机的生成树协议STP" class="headerlink" title="3.10 以太网交换机的生成树协议STP"></a>3.10 以太网交换机的生成树协议STP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304936182-215ca9e7-a5ea-4820-a6d2-106ae42fee1d.png#clientId=ua9168488-b0f8-4&from=paste&height=332&id=uacb6852f&margin=%5Bobject%20Object%5D&name=&originHeight=332&originWidth=676&originalType=binary&ratio=1&size=297082&status=done&style=none&taskId=u3b044536-5836-4444-b244-66ea7ba4905&width=676"></p>
<h2 id="3-11-虚拟局域网VLAN概述"><a href="#3-11-虚拟局域网VLAN概述" class="headerlink" title="3.11 虚拟局域网VLAN概述"></a>3.11 虚拟局域网VLAN概述</h2><p>使用广播有可能发生广播风暴问题，占用CPU资源<br><strong>虚拟局域网VLAN技术可以隔绝广播域</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629305135155-9cd015c3-b81f-4430-8667-647ed365146c.png#clientId=ua9168488-b0f8-4&from=paste&height=73&id=ufafd0705&margin=%5Bobject%20Object%5D&name=&originHeight=73&originWidth=1072&originalType=binary&ratio=1&size=125501&status=done&style=none&taskId=u32512650-2ae0-41eb-9921-afe74f16d23&width=1072"></p>
<h1 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章(网络层)"></a>第4章(网络层)</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629895311610-dc712f8b-6e8b-446b-a2b2-05f555c834f1.png#clientId=ue04b705f-4445-4&from=paste&height=317&id=u63e8a5e8&margin=%5Bobject%20Object%5D&name=&originHeight=317&originWidth=1015&originalType=binary&ratio=1&size=233847&status=done&style=none&taskId=ub46a736e-d0cb-4cdf-ad49-d541521519d&width=1015"></p>
<h2 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h2><p>面向连接的虚电路服务、无连接的数据报服务<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629899004716-3e50cbca-eb9a-4228-bef1-79009bc6bb53.png#clientId=u8b60e0cf-ca8a-4&from=paste&height=442&id=u1b006b96&margin=%5Bobject%20Object%5D&name=&originHeight=589&originWidth=595&originalType=binary&ratio=1&size=408181&status=done&style=none&taskId=u971b57cb-929a-429c-b56d-de229d30b12&width=446"></p>
<h2 id="4-3-IPv4地址"><a href="#4-3-IPv4地址" class="headerlink" title="4.3 IPv4地址"></a>4.3 IPv4地址</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629899675919-db69ba64-3615-4f73-b0b1-0a95fc7260c5.png#clientId=ue530bc8e-ad2f-4&from=paste&height=75&id=uff8ac2f0&margin=%5Bobject%20Object%5D&name=&originHeight=75&originWidth=1110&originalType=binary&ratio=1&size=95144&status=done&style=none&taskId=u235b3b7e-fee0-45a4-b67e-0c3ad2b2fa5&width=1110"><br>8位无符号二进制整数转十进制数</p>
<h3 id="2-分类编址的IPv4地址"><a href="#2-分类编址的IPv4地址" class="headerlink" title="2.分类编址的IPv4地址"></a>2.分类编址的IPv4地址</h3><p><strong>地址=网络号+主机号</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984338002-912e1f84-7c66-4b29-aed6-3449f05c5995.png#clientId=u99cd8dab-b839-4&from=paste&height=617&id=udf80f2dc&margin=%5Bobject%20Object%5D&name=&originHeight=617&originWidth=1346&originalType=binary&ratio=1&size=295402&status=done&style=none&taskId=u03d45a6b-33fd-48ed-852e-719c181885e&width=1346"><br><strong>主机号全0为网络地址，主机号全1为广播地址</strong><br><strong>​</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984617029-5a6a4caf-ef43-48da-8c95-a946932f2846.png#clientId=u99cd8dab-b839-4&from=paste&height=679&id=ubd8cdd92&margin=%5Bobject%20Object%5D&name=&originHeight=679&originWidth=1363&originalType=binary&ratio=1&size=517829&status=done&style=none&taskId=u636f1bfd-dbe7-40bb-a2d4-247c495f22f&width=1363"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984830276-4ab15ae7-9b26-412b-8cd1-580b79ad079b.png#clientId=u99cd8dab-b839-4&from=paste&height=577&id=u2ce8ddf7&margin=%5Bobject%20Object%5D&name=&originHeight=577&originWidth=1346&originalType=binary&ratio=1&size=304949&status=done&style=none&taskId=u48a7df6c-8267-487c-9e9a-010b570244a&width=1346"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984902741-162a94ee-f47d-4c04-acf5-d94c8369596e.png#clientId=u99cd8dab-b839-4&from=paste&height=557&id=ub2ff9fbb&margin=%5Bobject%20Object%5D&name=&originHeight=557&originWidth=1328&originalType=binary&ratio=1&size=310296&status=done&style=none&taskId=u8947a48f-e3cc-4ea2-96d0-a246e1fe049&width=1328"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629985792094-1e11b136-8bb3-4c40-b65a-bdbfba1c20f4.png#clientId=u029f7a3f-c032-4&from=paste&height=640&id=uf08660dd&margin=%5Bobject%20Object%5D&name=&originHeight=640&originWidth=1310&originalType=binary&ratio=1&size=447945&status=done&style=none&taskId=u9fa9194b-4b6c-43bc-b811-d3903fd9555&width=1310"></p>
<p>主机号小于127的A类，128-191的B类，192-223的C类<br>申请C类网络地址，可分配的IP地址数量为254个；其他类，查看上述图片<br> 可以将主机号的一部分作为子网号，划分子网<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629986771700-3c3629bb-99d5-4bc5-8994-a31693b4f99b.png#clientId=u029f7a3f-c032-4&from=paste&height=527&id=u5cc376b8&margin=%5Bobject%20Object%5D&name=&originHeight=527&originWidth=1350&originalType=binary&ratio=1&size=429821&status=done&style=none&taskId=u6463215b-01d4-4838-94d4-c0bf3283428&width=1350"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629995061991-39429b99-d8a1-4a62-b212-0d8c2dfd0076.png#clientId=u79734b0e-78be-4&from=paste&height=568&id=u96f678b4&margin=%5Bobject%20Object%5D&name=&originHeight=568&originWidth=889&originalType=binary&ratio=1&size=352083&status=done&style=none&taskId=u9aea79f9-3d21-4213-8ff2-58e7bf01e18&width=889"><br>一般是从主机号借用比特作为子网号</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h4><p>定长的子网掩码FLSM、变长的子网掩码VLSM<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629996092066-b012a8b3-28f2-4f6a-b51a-7f2f9c7a896d.png#clientId=u79734b0e-78be-4&from=paste&height=449&id=ub8d95f7d&margin=%5Bobject%20Object%5D&name=&originHeight=449&originWidth=1062&originalType=binary&ratio=1&size=452150&status=done&style=none&taskId=u1f1d22b4-4200-4bce-b673-c42fc156841&width=1062"></p>
<h2 id="4-4-IP数据报的发送和转发过程"><a href="#4-4-IP数据报的发送和转发过程" class="headerlink" title="4.4 IP数据报的发送和转发过程"></a>4.4 IP数据报的发送和转发过程</h2><p>由IP地址和子网掩码，可以得出网络地址。路由器进行网络地址的转发，需要知道目的网络地址，才能将数据发送出去<br>由路由器的路由表确定该由哪个路由器进行转发</p>
<h2 id="4-5-静态路由配置及其可能产生的路由环路问题"><a href="#4-5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5 静态路由配置及其可能产生的路由环路问题"></a>4.5 静态路由配置及其可能产生的路由环路问题</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630033837991-9cbbf289-e74c-49d0-9939-2169778518cd.png#clientId=u1edab733-fa4e-4&from=paste&height=443&id=ud5bf8b66&margin=%5Bobject%20Object%5D&name=&originHeight=886&originWidth=1375&originalType=binary&ratio=1&size=564202&status=done&style=none&taskId=u343600c5-1042-42e1-97b7-167411a5ee6&width=687.5"></p>
<h2 id="4-6-路由选择协议概述"><a href="#4-6-路由选择协议概述" class="headerlink" title="4.6 路由选择协议概述"></a>4.6 路由选择协议概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630034856622-aa26428d-2a5c-4707-8101-fa1c17c86148.png#clientId=u1edab733-fa4e-4&from=paste&height=312&id=u0b055cc5&margin=%5Bobject%20Object%5D&name=&originHeight=623&originWidth=1882&originalType=binary&ratio=1&size=626706&status=done&style=none&taskId=u59cf01a9-16ea-4c76-ab15-d4335ff3ed7&width=941"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035046058-c765bfc6-eae8-42d4-ab78-0da7633367fd.png#clientId=u1edab733-fa4e-4&from=paste&height=351&id=u779726ef&margin=%5Bobject%20Object%5D&name=&originHeight=702&originWidth=1886&originalType=binary&ratio=1&size=803225&status=done&style=none&taskId=ub218777c-8a9d-4a3f-b2c6-b7b2a00702e&width=943"></p>
<h3 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035159645-6c39b751-7f04-454d-957c-54381e128e21.png#clientId=u1edab733-fa4e-4&from=paste&height=448&id=ub491947c&margin=%5Bobject%20Object%5D&name=&originHeight=895&originWidth=1823&originalType=binary&ratio=1&size=692025&status=done&style=none&taskId=u754ce3b2-23e8-437c-a0d1-9954696f143&width=911.5"></p>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><strong>路由信息协议RIP</strong>认为好的路由就是距离短的路由<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035343897-15d16f08-a902-4e78-8851-bd32906e0ec8.png#clientId=u1edab733-fa4e-4&from=paste&height=139&id=u944fd16b&margin=%5Bobject%20Object%5D&name=&originHeight=277&originWidth=815&originalType=binary&ratio=1&size=243398&status=done&style=none&taskId=uc88d86b2-99f5-4db0-aa78-a2e40b587d5&width=407.5"><br>路由表包含的条目是到目的地址的信息<br>​</p>
<p><strong>开放式最短路径优先OSPF</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630037745333-f80e84da-6a62-4786-be44-65194105c4df.png#clientId=u1edab733-fa4e-4&from=paste&height=315&id=u17811cdf&margin=%5Bobject%20Object%5D&name=&originHeight=630&originWidth=1369&originalType=binary&ratio=1&size=564539&status=done&style=none&taskId=u20d1c9cd-f259-4a33-93e5-d984e09aa09&width=684.5"><br>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域。这样使每个区域内部交换的信息量大大减少。<br>​</p>
<p><strong>边界网关协议BGP</strong><br>直接封装RIP、OSPF、BGP的报文协议分别是UDP、IP、TCP</p>
<h2 id="4-7-IPv4数据报的首部格式"><a href="#4-7-IPv4数据报的首部格式" class="headerlink" title="4.7 IPv4数据报的首部格式"></a>4.7 IPv4数据报的首部格式</h2><p>首部的固定部分是20字节，可变部分字节数是变化的<br>生存时间是TTL<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630039612119-7b02c6bc-48c6-4cd9-8cbf-3099d51a1bca.png#clientId=ufe427c8a-6a89-4&from=paste&height=203&id=u2e6fc32f&margin=%5Bobject%20Object%5D&name=&originHeight=406&originWidth=1207&originalType=binary&ratio=1&size=161011&status=done&style=none&taskId=u350e8067-d81f-419c-9f6b-178fea205f9&width=603.5"><br>** 每行都是4个字节，32个bit**<br>可变部分长度可变，导致首部的长度也是可变的，增加了路由器处理数据的压力，但一般可变部分很少用到<br><strong>网际层使用的是IP协议进行封装</strong></p>
<h2 id="4-8-网际控制报文协议ICMP"><a href="#4-8-网际控制报文协议ICMP" class="headerlink" title="4.8 网际控制报文协议ICMP"></a>4.8 网际控制报文协议ICMP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630042596629-61f0d547-1888-4960-bd05-54412795b981.png#clientId=ufe427c8a-6a89-4&from=paste&height=87&id=ua0d05f77&margin=%5Bobject%20Object%5D&name=&originHeight=173&originWidth=1831&originalType=binary&ratio=1&size=130854&status=done&style=none&taskId=u2ef2d7c2-e6bb-4923-9871-68c8e5f8bdb&width=915.5"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630042807657-c98ecabc-ecfa-4139-b17a-91cc51843d89.png#clientId=ufe427c8a-6a89-4&from=paste&height=379&id=u4b356a6a&margin=%5Bobject%20Object%5D&name=&originHeight=757&originWidth=1455&originalType=binary&ratio=1&size=706490&status=done&style=none&taskId=ue3341430-1f78-4925-abbf-66dece8c83a&width=727.5"></p>
<p>ICMP的应用举例：分组网间探测PING、跟踪路由</p>
<h2 id="4-9-虚拟专用网VPN与网络地址转换NAT"><a href="#4-9-虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网VPN与网络地址转换NAT"></a>4.9 虚拟专用网VPN与网络地址转换NAT</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043094390-f7d123b9-a37d-42f5-99a1-c3558fcfcc13.png#clientId=ufe427c8a-6a89-4&from=paste&height=140&id=u8833eeaa&margin=%5Bobject%20Object%5D&name=&originHeight=279&originWidth=1541&originalType=binary&ratio=1&size=535228&status=done&style=none&taskId=u35043e21-25ff-4d2d-961b-0e0e0af3ddb&width=770.5"><br>在因特网的所有路由器中，对目的地址是私有地址的IP数据报一律不进行转发<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043308159-fc9f8123-7157-4317-9a1c-74aa21e4c563.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=341&id=u361b8b3a&margin=%5Bobject%20Object%5D&name=&originHeight=682&originWidth=1899&originalType=binary&ratio=1&size=823624&status=done&style=none&taskId=u8e2e6ad2-9622-4037-a562-40dab9ac475&width=949.5"><br>可重用IP一般是说每人都可以用的，比如局域网中的：192.168.x.x这类格式。<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043660820-2dad3301-df24-4378-b5a4-41fd6fe4d023.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=84&id=ue3f3fa7d&margin=%5Bobject%20Object%5D&name=&originHeight=168&originWidth=1686&originalType=binary&ratio=1&size=203217&status=done&style=none&taskId=u58389169-a82c-43aa-97d8-a1184c23705&width=843"><br><strong>​</strong></p>
<p><strong>网络地址转换NAT</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043936507-ba8576fe-58f9-4e26-826e-806ef1fb11d8.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=107&id=uc0f13ddb&margin=%5Bobject%20Object%5D&name=&originHeight=214&originWidth=1845&originalType=binary&ratio=1&size=681462&status=done&style=none&taskId=u8b3fdb8c-bca2-4733-b0f3-8321ed0ea92&width=922.5"></p>
<p>什么是私有IP地址、公有IP地址？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630044115083-3e9a8654-305a-4007-9898-5cf28ea74729.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=230&id=u44e24201&margin=%5Bobject%20Object%5D&name=&originHeight=459&originWidth=1101&originalType=binary&ratio=1&size=76276&status=done&style=none&taskId=u138ca015-957f-4674-8d71-0ebffe072c5&width=550.5"></p>
<h1 id="第5章-运输层"><a href="#第5章-运输层" class="headerlink" title="第5章(运输层)"></a>第5章(运输层)</h1><h2 id="5-1-运输层概述"><a href="#5-1-运输层概述" class="headerlink" title="5.1 运输层概述"></a>5.1 运输层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151394190-c7aaf562-8f82-4d1d-ab6f-1f1bcb855a2a.png#clientId=ub9f2d9a6-7257-4&from=paste&height=197&id=u63c74f32&margin=%5Bobject%20Object%5D&name=&originHeight=197&originWidth=1298&originalType=binary&ratio=1&size=223824&status=done&style=none&taskId=ue1d70bed-e248-4c43-9295-397f0803afe&width=1298"></p>
<h2 id="5-2-运输层端口号、复用与分用的概念"><a href="#5-2-运输层端口号、复用与分用的概念" class="headerlink" title="5.2 运输层端口号、复用与分用的概念"></a>5.2 运输层端口号、复用与分用的概念</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151619401-fa742f7b-f72b-4db2-ba4d-1a8a9d400d62.png#clientId=ub9f2d9a6-7257-4&from=paste&height=356&id=uaf62bba6&margin=%5Bobject%20Object%5D&name=&originHeight=356&originWidth=1050&originalType=binary&ratio=1&size=362460&status=done&style=none&taskId=ud9c8a6dd-0ecb-4645-88be-7f85193c5fa&width=1050"><br><strong>网络层使用的是IP协议，运输层使用的是TCP/UDP协议</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151743066-bc4aad62-026c-480b-a299-2f38fb16e661.png#clientId=ub9f2d9a6-7257-4&from=paste&height=597&id=uf773e8a3&margin=%5Bobject%20Object%5D&name=&originHeight=597&originWidth=1364&originalType=binary&ratio=1&size=407162&status=done&style=none&taskId=u55fbea37-4a7a-45d3-840a-c5238da8bf0&width=1364"><br>​</p>
<p>举例：浏览器输入一个域名后，产生哪些行为？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152197425-a33616c5-f278-4abb-a9aa-b08ecee73904.png#clientId=ub9f2d9a6-7257-4&from=paste&height=638&id=ua93e4a47&margin=%5Bobject%20Object%5D&name=&originHeight=638&originWidth=1332&originalType=binary&ratio=1&size=280055&status=done&style=none&taskId=u50b5092e-987d-474a-898b-6aac7b3e2b9&width=1332"><br><strong>DNS服务器将域名解析为IP地址</strong></p>
<h2 id="5-3-UDP和TCP的对比"><a href="#5-3-UDP和TCP的对比" class="headerlink" title="5.3 UDP和TCP的对比"></a>5.3 UDP和TCP的对比</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152415885-e3eefc50-b07a-4e38-bf9f-d70af0a9b934.png#clientId=ub9f2d9a6-7257-4&from=paste&height=646&id=u4a432f79&margin=%5Bobject%20Object%5D&name=&originHeight=646&originWidth=1324&originalType=binary&ratio=1&size=407134&status=done&style=none&taskId=u247eb5c6-a637-488c-84d3-3fe0b8303f3&width=1324"><br>UDP支持一对一、一对多、一对全的通信，TCP只支持一对一的通信<br>全双工：两个方向可以同时通信   半双工：同一时间只能一个方向通信<br><strong>UDP适用于视频会议等，TCP适用于文件传输等</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152811341-3b3237cd-55e5-4d8a-8f6e-6b4dea538c31.png#clientId=ub9f2d9a6-7257-4&from=paste&height=627&id=u2d63d285&margin=%5Bobject%20Object%5D&name=&originHeight=627&originWidth=1320&originalType=binary&ratio=1&size=925199&status=done&style=none&taskId=u9a019bc3-4680-41df-b77a-4ad34cecb12&width=1320"><br><strong>报文段包括首部和数据部分</strong><br><strong>​</strong></p>
<h2 id="5-4-TCP的流量控制"><a href="#5-4-TCP的流量控制" class="headerlink" title="5.4 TCP的流量控制"></a>5.4 TCP的流量控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630154365890-263cfe95-ee9e-4d52-bec5-05e97354491e.png#clientId=ub9f2d9a6-7257-4&from=paste&height=126&id=uff2e2b8e&margin=%5Bobject%20Object%5D&name=&originHeight=126&originWidth=1097&originalType=binary&ratio=1&size=128609&status=done&style=none&taskId=u9040db5e-5082-42b8-80f9-f802095be60&width=1097"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155032423-032c4192-5ef6-4a79-8457-67ae54238197.png#clientId=ub9f2d9a6-7257-4&from=paste&height=158&id=u131bcd78&margin=%5Bobject%20Object%5D&name=&originHeight=158&originWidth=1029&originalType=binary&ratio=1&size=132336&status=done&style=none&taskId=ua2773e6f-889e-4702-b590-b5088f8b5a1&width=1029"><br><strong>举例：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155507437-b11e06a6-f7a4-4032-a593-c218976f8aa7.png#clientId=ub9f2d9a6-7257-4&from=paste&height=648&id=u78676055&margin=%5Bobject%20Object%5D&name=&originHeight=648&originWidth=1303&originalType=binary&ratio=1&size=385129&status=done&style=none&taskId=ub936cdf8-7e16-4388-8dae-0e1811f25f4&width=1303"></p>
<h2 id="5-5-TCP的拥塞控制"><a href="#5-5-TCP的拥塞控制" class="headerlink" title="5.5 TCP的拥塞控制"></a>5.5 TCP的拥塞控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155711085-9849f28b-73eb-4fef-81c8-d560450727af.png#clientId=ub9f2d9a6-7257-4&from=paste&height=618&id=u2e53147a&margin=%5Bobject%20Object%5D&name=&originHeight=618&originWidth=1123&originalType=binary&ratio=1&size=435382&status=done&style=none&taskId=u145afe6f-def4-45fd-b61c-4967a680db9&width=1123"><br><strong>首部加数据部分构成报文段。若报文段发送过程发生丢失，会超时重传</strong><br>​</p>
<p>拥塞控制算法：<br><strong>慢开始和拥塞避免</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630156160974-728768c9-2641-4c3f-b8d3-e48a6e13ef38.png#clientId=ub9f2d9a6-7257-4&from=paste&height=628&id=u5186d1f7&margin=%5Bobject%20Object%5D&name=&originHeight=628&originWidth=1337&originalType=binary&ratio=1&size=551041&status=done&style=none&taskId=udd3ad504-99eb-455f-91cc-55209faa5c5&width=1337"><br><strong>快重传和快恢复</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630158712140-bbee739f-3e37-4004-836e-4af308d0b182.png#clientId=ub9f2d9a6-7257-4&from=paste&height=586&id=u174c061e&margin=%5Bobject%20Object%5D&name=&originHeight=586&originWidth=1320&originalType=binary&ratio=1&size=681522&status=done&style=none&taskId=u6f11787a-7ded-4c52-acf1-f1a33f57b36&width=1320"><br>如果只是丢失个别的报文段，而不是拥塞，可以不用启动慢开始算法，执行快恢复算法，提高效率<br>​</p>
<h2 id="5-6-TCP超时重传时间的选择"><a href="#5-6-TCP超时重传时间的选择" class="headerlink" title="5.6 TCP超时重传时间的选择"></a>5.6 TCP超时重传时间的选择</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630162592421-ac1f7a4f-b862-40d7-a722-3b864809527e.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=640&id=u95370f7d&margin=%5Bobject%20Object%5D&name=&originHeight=640&originWidth=1329&originalType=binary&ratio=1&size=583789&status=done&style=none&taskId=uba6ed328-a647-4ea4-8dda-d07e2e5f794&width=1329"></p>
<h2 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h2><p>TCP基于以字节为单位的<strong>滑动窗口</strong>来实现可靠传输<br>滑动窗口的原理需要能够描述，就是发送数据时，滑动窗口的状态及移动的过程<br>​</p>
<p>确认号字段确认接收后，发送窗口才会移动。若发送方迟迟收不到接收方的确认，会产生超时重传<br><strong>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。</strong><br><strong>发送方和接收方对报文段数据的确认</strong><br><strong>​</strong></p>
<h2 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630163696397-0aafbadd-3cb0-49af-808e-433f8c2bbee2.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=361&id=u32087d3a&margin=%5Bobject%20Object%5D&name=&originHeight=361&originWidth=1027&originalType=binary&ratio=1&size=187346&status=done&style=none&taskId=uf49ca996-8142-4abb-a6e6-df7e3e53ece&width=1027"></p>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630164187936-77352136-a111-45ce-a6f0-b41a3bc22367.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=635&id=ubcdc22e8&margin=%5Bobject%20Object%5D&name=&originHeight=635&originWidth=1367&originalType=binary&ratio=1&size=581262&status=done&style=none&taskId=ue41660fc-7d64-4866-a85d-de07b2ce1ad&width=1367"></p>
<h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p> <img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630164942626-cda2bb15-02e7-4e09-9bb0-21b306e1416d.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=671&id=ubecb3812&margin=%5Bobject%20Object%5D&name=&originHeight=671&originWidth=1302&originalType=binary&ratio=1&size=635753&status=done&style=none&taskId=u2057b9a3-b969-4f93-a476-de7d7a9793f&width=1302"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165044359-a3efc946-429a-4c04-b7a9-925e92aa8101.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=518&id=ub37c3a1d&margin=%5Bobject%20Object%5D&name=&originHeight=518&originWidth=1271&originalType=binary&ratio=1&size=425579&status=done&style=none&taskId=u39499b91-88c3-4040-95bc-346829bd477&width=1271"></p>
<h2 id="5-9-TCP报文段的首部格式"><a href="#5-9-TCP报文段的首部格式" class="headerlink" title="5.9 TCP报文段的首部格式"></a>5.9 TCP报文段的首部格式</h2><p>TCP报文段的首部格式与IP报文段的首部格式类似<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165168614-2083232e-ddbd-4859-a192-0aaf40d24c53.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=532&id=u812b32cd&margin=%5Bobject%20Object%5D&name=&originHeight=532&originWidth=1102&originalType=binary&ratio=1&size=273454&status=done&style=none&taskId=u9f368cc7-f3b0-4202-95d8-a3201a166fd&width=1102"><br>如何确定是请求报文段还是确认报文段？<br>看是否有SYN和ACK<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165518609-85973199-ea5f-49f2-bc6e-4c2900203dde.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=295&id=u19c921a5&margin=%5Bobject%20Object%5D&name=&originHeight=295&originWidth=576&originalType=binary&ratio=1&size=110544&status=done&style=none&taskId=u4b66e5d4-2339-4d55-bd72-74d4de7d4c6&width=576"></p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="第6章-应用层"><a href="#第6章-应用层" class="headerlink" title="第6章(应用层)"></a>第6章(应用层)</h1><h2 id="6-1-应用层概述"><a href="#6-1-应用层概述" class="headerlink" title="6.1 应用层概述"></a>6.1 应用层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630199429756-e4f5f638-f08f-4b0b-b30c-5c525f2c92f1.png#clientId=ub9b57106-a89f-4&from=paste&height=512&id=u2dc3e02c&margin=%5Bobject%20Object%5D&name=&originHeight=512&originWidth=1289&originalType=binary&ratio=1&size=577711&status=done&style=none&taskId=u70efb5fa-2d71-41ef-8517-2555ab0dd26&width=1289"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630200373985-461de6bf-bb1e-4af6-83a5-e519cade7062.png#clientId=ub9b57106-a89f-4&from=paste&height=78&id=ube25ac6a&margin=%5Bobject%20Object%5D&name=&originHeight=78&originWidth=1184&originalType=binary&ratio=1&size=93580&status=done&style=none&taskId=u06c5a5a8-687d-4cc4-aa75-022a80fe3e5&width=1184"></p>
<h2 id="6-2-客户-服务器方式-C-S-和对等方式-P2P"><a href="#6-2-客户-服务器方式-C-S-和对等方式-P2P" class="headerlink" title="6.2 客户/服务器方式(C/S)和对等方式(P2P)"></a>6.2 客户/服务器方式(C/S)和对等方式(P2P)</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630200831698-c77ac187-3fc5-44e9-8652-dcf869c4695d.png#clientId=ub9b57106-a89f-4&from=paste&height=563&id=u79fe9ba6&margin=%5Bobject%20Object%5D&name=&originHeight=563&originWidth=1141&originalType=binary&ratio=1&size=557098&status=done&style=none&taskId=u3684ab91-db88-4149-99d0-37cfd4523c3&width=1141"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630201032087-fb7b31df-497b-4dcc-8f30-b18bd46c05d8.png#clientId=ub9b57106-a89f-4&from=paste&height=444&id=u0b9fe317&margin=%5Bobject%20Object%5D&name=&originHeight=444&originWidth=1147&originalType=binary&ratio=1&size=519812&status=done&style=none&taskId=u599b7045-24d6-4f99-8208-0be9bae7c62&width=1147"></p>
<h2 id="6-3-动态主机配置协议DHCP"><a href="#6-3-动态主机配置协议DHCP" class="headerlink" title="6.3 动态主机配置协议DHCP"></a>6.3 动态主机配置协议DHCP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630201944412-686589fc-c905-4bd2-b2dc-3ee52487e1e3.png#clientId=ub9b57106-a89f-4&from=paste&height=604&id=uc0e23d08&margin=%5Bobject%20Object%5D&name=&originHeight=604&originWidth=1205&originalType=binary&ratio=1&size=537647&status=done&style=none&taskId=ud1bb0dde-e94f-4247-92de-dcbc474e74d&width=1205"></p>
<h2 id="6-4-域名系统DNS"><a href="#6-4-域名系统DNS" class="headerlink" title="6.4 域名系统DNS"></a>6.4 域名系统DNS<img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202164656-cb1a90ae-fe46-4ae8-be47-ccc69e81d94c.png#clientId=ub9b57106-a89f-4&from=paste&height=608&id=ucb89939f&margin=%5Bobject%20Object%5D&name=&originHeight=608&originWidth=1314&originalType=binary&ratio=1&size=421163&status=done&style=none&taskId=u1c961911-4fec-4da4-8146-d0dce8e2121&width=1314"></h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202299316-8ffc70f7-eed3-44c1-add5-3ca672e347c0.png#clientId=ub9b57106-a89f-4&from=paste&height=568&id=ubc037671&margin=%5Bobject%20Object%5D&name=&originHeight=568&originWidth=1157&originalType=binary&ratio=1&size=548071&status=done&style=none&taskId=uf8a40b71-6be2-4632-a3da-119105403c6&width=1157"></p>
<p><strong>DNS使用分布在各地的域名服务器来实现域名到IP地址的转换</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202647784-7b86c9da-e8d5-4ab1-ac61-3158f840bda6.png#clientId=ub9b57106-a89f-4&from=paste&height=625&id=u751a9ecb&margin=%5Bobject%20Object%5D&name=&originHeight=625&originWidth=1327&originalType=binary&ratio=1&size=668642&status=done&style=none&taskId=u88c4b465-be63-46b9-a5d7-43f901d5239&width=1327"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202883291-8b0c811e-4df1-42d4-b841-0ed0cf33b55f.png#clientId=ub9b57106-a89f-4&from=paste&height=265&id=ua872447e&margin=%5Bobject%20Object%5D&name=&originHeight=265&originWidth=524&originalType=binary&ratio=1&size=103950&status=done&style=none&taskId=u39c92748-b78c-40db-b2cd-b8cb777addf&width=524"></p>
<h2 id="6-5-文件传送协议FTP"><a href="#6-5-文件传送协议FTP" class="headerlink" title="6.5 文件传送协议FTP"></a>6.5 文件传送协议FTP</h2><p> Windows可以搭建FTP服务器。如果想要从Linux服务器上下载文件，使用相关FTP连接工具即可<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630203346283-3846b7d6-cdbf-40f1-8b7d-65e664f1890c.png#clientId=ub9b57106-a89f-4&from=paste&height=392&id=uda6a5fe3&margin=%5Bobject%20Object%5D&name=&originHeight=392&originWidth=1006&originalType=binary&ratio=1&size=209350&status=done&style=none&taskId=ud3badeb0-5e14-465a-b1b7-813e40d942f&width=1006"><br>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接<br>​</p>
<h2 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h2><p>SMTP邮件发送协议、POP3邮件读取协议<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630203941529-219a6adb-61cb-4dc6-87dd-783f8958e378.png#clientId=ub9b57106-a89f-4&from=paste&height=215&id=u844094aa&margin=%5Bobject%20Object%5D&name=&originHeight=215&originWidth=1167&originalType=binary&ratio=1&size=214913&status=done&style=none&taskId=ube9ccd78-223d-4184-939a-1e5680f7cbb&width=1167"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630204242121-aa4f2e0b-7b8f-4c1a-864f-68feb340547d.png#clientId=ub9b57106-a89f-4&from=paste&height=195&id=u6a645476&margin=%5Bobject%20Object%5D&name=&originHeight=195&originWidth=1249&originalType=binary&ratio=1&size=224137&status=done&style=none&taskId=u9cef5bc0-9252-40c5-9fea-3eff8992529&width=1249"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630204496512-20fa7951-8d10-4f08-8290-ebff30eac324.png#clientId=ub9b57106-a89f-4&from=paste&height=624&id=u9243faf5&margin=%5Bobject%20Object%5D&name=&originHeight=624&originWidth=1241&originalType=binary&ratio=1&size=404555&status=done&style=none&taskId=ua09d7108-4ac1-417a-9992-1667494b297&width=1241"></p>
<h2 id="6-7-万维网WWW"><a href="#6-7-万维网WWW" class="headerlink" title="6.7 万维网WWW"></a>6.7 万维网WWW</h2><p>万维网使用统一资源定位符URL来指明因特网上任何种类”资源”的位置<br>在html中，使用link标签引入css文件，使用script标签引入js文件</p>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206119239-ea21236e-e479-47f9-901d-23c6579c9267.png#clientId=ub9b57106-a89f-4&from=paste&height=362&id=u292c3051&margin=%5Bobject%20Object%5D&name=&originHeight=362&originWidth=1022&originalType=binary&ratio=1&size=216576&status=done&style=none&taskId=u33225de8-7b73-4fea-99c3-2de11947567&width=1022"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206273896-ec1a7b75-0f50-4b69-b1ed-b3c8b3fa3b8c.png#clientId=ub9b57106-a89f-4&from=paste&height=464&id=ue6be07f0&margin=%5Bobject%20Object%5D&name=&originHeight=464&originWidth=1110&originalType=binary&ratio=1&size=547130&status=done&style=none&taskId=ub0a3026d-914c-4870-9dac-a86723e8843&width=1110"></p>
<p>HTTP请求报文格式举例：<br>请求报文=请求行+首部行<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206487325-2a36d06c-81fe-4965-9b80-d1895ef6c4c0.png#clientId=ub9b57106-a89f-4&from=paste&height=178&id=uc0c6ad59&margin=%5Bobject%20Object%5D&name=&originHeight=178&originWidth=647&originalType=binary&ratio=1&size=122364&status=done&style=none&taskId=uc08a9301-bd22-447c-9580-6ea770cc4dc&width=647"><br>HTTP响应报文格式举例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206593049-c310094c-5e44-4bd9-a544-a4c1877b1b34.png#clientId=ub9b57106-a89f-4&from=paste&height=323&id=u042817fc&margin=%5Bobject%20Object%5D&name=&originHeight=323&originWidth=1242&originalType=binary&ratio=1&size=186479&status=done&style=none&taskId=u287d71a5-f5f2-4889-876d-7ca41dd610f&width=1242"></p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用Cookie在服务器上记录用户登录信息</p>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206808227-e1c756a1-56cc-469e-9934-de96db23a75d.png#clientId=ub9b57106-a89f-4&from=paste&height=204&id=u67a05313&margin=%5Bobject%20Object%5D&name=&originHeight=204&originWidth=1166&originalType=binary&ratio=1&size=266028&status=done&style=none&taskId=ua454bc7a-7798-4bb5-b89a-c38c6d1e5c0&width=1166"><br><strong>练习：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206934741-e6d00b84-a0c9-4144-ae3f-9b6fa90f45e9.png#clientId=ub9b57106-a89f-4&from=paste&height=227&id=ucc68afb7&margin=%5Bobject%20Object%5D&name=&originHeight=227&originWidth=929&originalType=binary&ratio=1&size=194817&status=done&style=none&taskId=u95f63382-86f5-4349-879f-4e0844ee632&width=929"></p>
<h1 id="第7章-总结"><a href="#第7章-总结" class="headerlink" title="第7章(总结)"></a>第7章(总结)</h1><blockquote>
<p>计算机网络是我一直很想学习的课程，从8.12-8.29我将教书匠的课程学完，并且记下了这个笔记，方便日后复习。但计算机网络的学习并没有结束，将理论的学习用实践验证，学习路上道阻且长。</p>
</blockquote>
<p><strong>最后以唐朝韩愈的话劝勉自己：学知不足，业精于勤。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm虚拟机</title>
    <url>/posts/d776.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>作为一个Java后端攻城狮，jvm是必须要懂的知识点。我主要是看书+看视频结合起来学习，书看的是『深入理解java虚拟机第三版』，视频看的是宋红康的jvm教程。<br><a href="https://www.bilibili.com/video/BV1PJ411n7xZ">宋红康jvm教程</a></p>
<blockquote>
<p>接下来就开始漫长的jvm学习之旅吧(◕ᴗ◕✿)</p>
</blockquote>
<span id="more"></span>


<h1 id="内存与垃圾回收篇"><a href="#内存与垃圾回收篇" class="headerlink" title="内存与垃圾回收篇"></a>内存与垃圾回收篇</h1><h2 id="1-JVM与Java体系结构"><a href="#1-JVM与Java体系结构" class="headerlink" title="1 JVM与Java体系结构"></a>1 JVM与Java体系结构</h2><p>比较重要的两个概念：虚拟机、垃圾回收器<br>Java虚拟机：它是一台虚拟的计算机，专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令称为Java字节码指令。jdk8用的虚拟机是Hotspot<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629188980108-46893a3d-8145-46e0-95f1-0a001187cda7.png#clientId=ub0061409-9ae3-4&from=paste&height=256&id=u2c554a39&originHeight=511&originWidth=1139&originalType=binary&ratio=1&size=227840&status=done&style=none&taskId=u5c10cc52-e888-4834-869a-7e3e2ec7afe&width=569.5" alt="image.png"></p>
<hr>
<p><strong>jvm的整体结构</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629189469130-c642fbcb-8394-43d7-ac8e-5de0dd1c5743.png#clientId=ub0061409-9ae3-4&from=paste&height=334&id=uecf6cfbc&originHeight=667&originWidth=717&originalType=binary&ratio=1&size=309169&status=done&style=none&taskId=u008713af-9649-43bd-a154-7b5f4b6e344&width=358.5" alt="image.png"><br><strong>jvm的架构模型</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629190799872-bd3472a1-04b6-4db8-aa9b-4b77ddea45d3.png#clientId=ub0061409-9ae3-4&from=paste&height=258&id=u63cca91b&originHeight=515&originWidth=1184&originalType=binary&ratio=1&size=315291&status=done&style=none&taskId=u15957cb3-a9f7-4f89-a80a-d6e8c7d9dcd&width=592" alt="image.png"><br>现在的虚拟机一般都包括解释器和编译器，解释器响应速度快，编译器提升的是性能<br>比较流行的三个商用虚拟机：Hotspot、JRocket、J9</p>
<h2 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2 类加载子系统"></a>2 类加载子系统</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629274706793-5173b44a-b24d-4b83-b09a-e93adb6c1e16.png#clientId=uc828670a-6cf7-4&from=paste&height=245&id=u57047b53&originHeight=489&originWidth=1012&originalType=binary&ratio=1&size=373556&status=done&style=none&taskId=uff86dffc-e7ad-4387-892a-d757729467f&width=506" alt="image.png"><br>验证：验证字节码文件是否正确<br>准备：初始化变量，赋默认值</p>
<p><strong>虚拟机自带的加载器</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629277655020-4ebde1d1-ce76-4ef1-bd7a-c17811d6004f.png#clientId=uc828670a-6cf7-4&from=paste&height=253&id=ub53853bd&originHeight=506&originWidth=1050&originalType=binary&ratio=1&size=258151&status=done&style=none&taskId=u600f5a05-d029-41cb-a7cb-b2dc1eae475&width=525" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629277775441-dab4a288-db70-4a94-a7a9-1b45b4af08df.png#clientId=uc828670a-6cf7-4&from=paste&height=215&id=ucbd2c9d9&originHeight=430&originWidth=1007&originalType=binary&ratio=1&size=221653&status=done&style=none&taskId=ue8ff6983-fcb4-46db-b080-c7b4206a493&width=503.5" alt="image.png"></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629337315522-19823cf9-ac1f-4194-9451-be94549d1604.png#clientId=ua5e09a8e-b179-4&from=paste&height=102&id=u1f91714f&originHeight=204&originWidth=1058&originalType=binary&ratio=1&size=158721&status=done&style=none&taskId=u3fc1aed2-4467-40dc-9554-74d306fe14b&width=529" alt="image.png"><br><strong>为了防止项目被恶意攻击，引入双亲委派机制，把请求交给父类处理。倘若父类加载器无法完成任务，子类加载器才会去加载。</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629336964388-aeed76be-6583-4037-82d4-c27cec01f397.png#clientId=ua5e09a8e-b179-4&from=paste&height=333&id=u9fb356b9&originHeight=666&originWidth=484&originalType=binary&ratio=1&size=240030&status=done&style=none&taskId=uaf3e42b6-f4ef-42e5-bd8c-2a366543cf4&width=242" alt="image.png"><br>自定义对象的加载器就是系统加载器Application  ClassLoader<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629338147267-25a3b303-a34a-4705-a3f1-d23073321a89.png#clientId=ua5e09a8e-b179-4&from=paste&height=114&id=u758593e6&originHeight=228&originWidth=657&originalType=binary&ratio=1&size=96900&status=done&style=none&taskId=u930c1a3a-0582-4b0c-b6e0-a0e6eda9f3c&width=328.5" alt="image.png"></p>
<p>沙箱安全机制：对java核心源代码的保护<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629338413798-b8f0d486-5d03-40e7-8db5-e27b62158bad.png#clientId=ua5e09a8e-b179-4&from=paste&height=80&id=ua1d16c7b&originHeight=160&originWidth=896&originalType=binary&ratio=1&size=78463&status=done&style=none&taskId=ufad81a5f-d341-4ea0-9056-c1a976d5f7a&width=448" alt="image.png"><br>字节码文件是放到方法区进行保存的，还有类加载器信息也是放在方法区</p>
<h2 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3 运行时数据区"></a>3 运行时数据区</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629338955308-4af9ce66-37ff-4999-b293-31de5ab0f1c8.png#clientId=ua5e09a8e-b179-4&from=paste&height=267&id=ub368fd8d&originHeight=534&originWidth=762&originalType=binary&ratio=1&size=164008&status=done&style=none&taskId=ua9a13a7f-ab6b-4920-9798-a0c4970514a&width=381" alt="image.png"><br>举例：虚拟机就是1个进程，1个进程有5个线程，就有5组虚拟机栈。这些线程共用方法区和堆区。<br><strong>重点优化主要在于堆和方法区。</strong>95%垃圾回收发生在堆，5%发生在方法区。jdk8后方法区被替换为元空间，元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中”java.lang.OutOfMemoryError: PermGen space”这种错误。</p>
<h2 id="4-程序计数器"><a href="#4-程序计数器" class="headerlink" title="4 程序计数器"></a>4 程序计数器</h2><p>程序计数器，也称作PC寄存器<br>栈和程序计数器是没有垃圾回收的，堆和方法区有垃圾回收<br>javap -v对字节码文件进行解析，要切换到class的目录里<br>java文件反编译的话使用jd-gui<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629343049132-66bffa25-98bd-4267-a979-d99b435192e3.png#clientId=ud593b6cf-bc8e-4&from=paste&height=275&id=ue16d3044&originHeight=550&originWidth=530&originalType=binary&ratio=1&size=147039&status=done&style=none&taskId=u76815d33-cf81-4665-8659-770d4548130&width=265" alt="image.png"><br>指令地址是存在程序计数器中的。程序计数器用来存储指向下一条指令的地址。<strong>因为cpu不断切换各个线程，就需要程序计数器记录当前执行的指令地址。每个线程分配一个程序计数器</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629343421657-f136de46-5b84-4c15-b44e-492633b6bd6a.png#clientId=ud593b6cf-bc8e-4&from=paste&height=290&id=u797025b1&originHeight=579&originWidth=1169&originalType=binary&ratio=1&size=305268&status=done&style=none&taskId=u66e8c502-4b29-4173-9592-257ab8dec87&width=584.5" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629343796139-c1afec55-6b4a-499d-b0b5-16b68113e424.png#clientId=ud593b6cf-bc8e-4&from=paste&height=227&id=ue37c377b&originHeight=453&originWidth=1010&originalType=binary&ratio=1&size=163389&status=done&style=none&taskId=uc96dbfcc-c6ea-4d2a-9739-f7490e8a4ba&width=505" alt="image.png"></p>
<h2 id="5-虚拟机栈"><a href="#5-虚拟机栈" class="headerlink" title="5 虚拟机栈"></a>5 虚拟机栈</h2><h3 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h3><p><strong>虚拟机栈保存方法的局部变量、部分结果，对应着一次次Java方法的调用</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629343961233-b45f7fcc-e616-4ddb-b363-f9d1cbc64310.png#clientId=ud593b6cf-bc8e-4&from=paste&height=150&id=u3ed61e49&originHeight=299&originWidth=1031&originalType=binary&ratio=1&size=204483&status=done&style=none&taskId=u18a54403-9d9a-4b15-a9ae-1b908bbcc47&width=515.5" alt="image.png"><br>栈是运行时的单位，堆是存储时的单位<br>一般来说数据区堆的占比是比较大的，现在元空间改用本地内存后，空间大大增加<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629353145035-280ae6e2-bb36-49a5-b32d-e84a600a653c.png#clientId=ud593b6cf-bc8e-4&from=paste&height=287&id=u2e5e20af&originHeight=573&originWidth=1110&originalType=binary&ratio=1&size=306262&status=done&style=none&taskId=ub49b3272-f52c-4bc6-bbac-f180d89d858&width=555" alt="image.png"></p>
<h3 id="栈的优点、可能出现的异常"><a href="#栈的优点、可能出现的异常" class="headerlink" title="栈的优点、可能出现的异常"></a>栈的优点、可能出现的异常</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629353351772-e805a915-d88a-4ee1-946a-b57552d53def.png#clientId=ud593b6cf-bc8e-4&from=paste&height=266&id=u346a72ba&originHeight=532&originWidth=843&originalType=binary&ratio=1&size=136569&status=done&style=none&taskId=u3b1a4d28-5af2-41ec-b5b0-061608c5f57&width=421.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629353566572-63b153e5-02cc-4b32-88b2-b81e25f420dd.png#clientId=ud593b6cf-bc8e-4&from=paste&height=226&id=u62efd1ef&originHeight=452&originWidth=1066&originalType=binary&ratio=1&size=328051&status=done&style=none&taskId=u976db46b-9825-41d6-991a-7dac42768c9&width=533" alt="image.png"><br>虚拟机调优：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629353761553-3f4ea11a-216e-4eeb-a9af-e2819c7a732f.png#clientId=ud593b6cf-bc8e-4&from=paste&height=68&id=ue1604d16&originHeight=135&originWidth=1100&originalType=binary&ratio=1&size=70310&status=done&style=none&taskId=u3026fd29-a9c6-4c2d-a319-684a30d49bb&width=550" alt="image.png"><br>不同线程之间的栈帧是不允许相互引用的</p>
<h3 id="栈的内部结构"><a href="#栈的内部结构" class="headerlink" title="栈的内部结构"></a>栈的内部结构</h3><p>虚拟机栈内部包括局部变量表、操作数栈<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629708549295-7bfaf153-fa08-4230-8212-e962bd919c39.png#clientId=u3d0a2ea3-202a-4&from=paste&height=212&id=u776b0cd6&originHeight=424&originWidth=453&originalType=binary&ratio=1&size=178911&status=done&style=none&taskId=ub03ef91c-233a-4d31-a831-9487fc8e89d&width=226.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629358892779-ed3c934d-62b9-4a63-9534-652325bac487.png#clientId=ud593b6cf-bc8e-4&from=paste&height=117&id=u0fdfe50f&originHeight=234&originWidth=980&originalType=binary&ratio=1&size=163346&status=done&style=none&taskId=ub695af84-0ac8-4558-9b81-0e563671a9b&width=490" alt="image.png"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629359121167-7b50c5c8-e89f-4895-bd7f-de6f801817c3.png#clientId=ud593b6cf-bc8e-4&from=paste&height=220&id=u7bcb201f&originHeight=440&originWidth=1029&originalType=binary&ratio=1&size=367837&status=done&style=none&taskId=u1a4be011-ef0f-44ba-aaad-7f8bbe5260a&width=514.5" alt="image.png"><br>javap对字节码文件进行解析，可以看到局部变量、栈帧信息、指令地址<br>局部变量表最基本的存储单元是Slot(变量槽)     8个字节对应两个槽，从第一个槽读取<br>this变量不存在于当前方法的局部变量表中</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629364088500-33c7590b-03aa-4d09-9f01-41350548aa14.png#clientId=ud593b6cf-bc8e-4&from=paste&height=41&id=u009e177d&originHeight=81&originWidth=1030&originalType=binary&ratio=1&size=100797&status=done&style=none&taskId=u42daa7a6-91eb-4266-a0e1-e8745b63e2a&width=515" alt="image.png"><br>操作数栈在编译的时候，长度就确定了<br>++i 和 i++如果不进行赋值，它们的效果是一样的</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>指向运行时常量池的方法引用，运行时常量池存在于方法区</p>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629705549852-93ad9dde-36fb-4f64-b73b-36adc923b336.png#clientId=u3d0a2ea3-202a-4&from=paste&height=137&id=u68d4e834&originHeight=274&originWidth=1129&originalType=binary&ratio=1&size=149849&status=done&style=none&taskId=u0bac4ac7-e420-477b-966b-460b606f5e9&width=564.5" alt="image.png"></p>
<p>Java是静态语言，静态类型语言检查在编译期，动态类型语言检查在运行期<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629706364700-f93a4f64-6843-4a59-a6de-03645d4f4ce8.png#clientId=u3d0a2ea3-202a-4&from=paste&height=286&id=uef423892&originHeight=571&originWidth=1101&originalType=binary&ratio=1&size=411169&status=done&style=none&taskId=ubadb4b84-7a02-4227-b4b0-69031e6d0a5&width=550.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629707722442-f24fd98b-9a9c-43f4-9e50-9f328212e419.png#clientId=u3d0a2ea3-202a-4&from=paste&height=282&id=u0627dfc9&originHeight=563&originWidth=1066&originalType=binary&ratio=1&size=388324&status=done&style=none&taskId=u0ccab9c3-9a10-4a28-a092-726f41f8474&width=533" alt="image.png"><br>两个线程公用一个资源，有可能线程不安全。线程不安全的原因是两个线程对同一个对象进行操作，产生冲突</p>
<h2 id="6-本地方法接口"><a href="#6-本地方法接口" class="headerlink" title="6 本地方法接口"></a>6 本地方法接口</h2><p>native关键字修饰的方法，一个Native Method就是一个Java调用非Java代码的接口<br>Native Method就是调用了底层的C、C++方法<br>Java与底层操作系统交互，可能要用到C的接口</p>
<h2 id="7-本地方法栈"><a href="#7-本地方法栈" class="headerlink" title="7 本地方法栈"></a>7 本地方法栈</h2><p>Java虚拟机栈用于管理Java方法的调用，本地方法栈用于管理本地方法的调用</p>
<h2 id="8-堆"><a href="#8-堆" class="headerlink" title="8 堆"></a>8 堆</h2><h3 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1.堆的核心概述"></a>1.堆的核心概述</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个进程对应一个jvm实例，对应一个运行时数据区。一个进程里有多个线程，多个线程共享堆和方法区。共享就要考虑线程安全问题<br>堆在创建时空间大小就被分配了，堆的空间大小可以调节<br>javac 编译    java运行<br>堆可以处于物理上不连续，逻辑上连续<br>对象实例和数组存放在堆上<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629773432778-765ffbca-d7d9-4789-8b33-54002a7dfcfd.png#clientId=ubd794167-0280-4&from=paste&height=200&id=u9b6a4321&originHeight=399&originWidth=851&originalType=binary&ratio=1&size=227120&status=done&style=none&taskId=u9b239ca1-b94a-49da-9a9f-36a967594cf&width=425.5" alt="image.png"><br>栈中存放的是对象的引用，堆中存放的是对象的实例。当对象使用完后，对象指向堆的引用就被断开，这个对象<br>当堆空间不够用的时候，会触发GC，判断是否成为垃圾需要回收。GC不能频繁触发，会影响用户线程的效率。<strong>栈中只存在入栈出栈的操作，没有垃圾回收</strong></p>
<h4 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629774089648-fca14fe1-4e75-4120-9cdb-f2a246a7f913.png#clientId=u13abf8be-0370-4&from=paste&height=253&id=ue0b143f0&originHeight=506&originWidth=1136&originalType=binary&ratio=1&size=634217&status=done&style=none&taskId=uc6db4638-5b8b-4ecb-aa41-fed7ce7f309&width=568" alt="image.png"><br>jdk7的时候叫永久代，jdk8的时候叫元空间<br>逻辑上新生代、老年代、元空间属于堆，实际上只管辖新生代、老年代。元空间属于方法区的范畴<br>在VM options中设置虚拟机运行参数</p>
<h3 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2.设置堆内存大小与OOM"></a>2.设置堆内存大小与OOM</h3><p>-Xms用来设置堆空间的起始内存大小，-Xmx用来设置堆空间的最大内存大小<br>默认堆空间大小：<br>初始内存：电脑内存大小/64<br>最大内存：电脑内存大小/4</p>
<p>开发中建议将初始堆内存和最大堆内存设置成相同的值。避免GC扩容造成系统不必要的占用。<br>s0(from)和s1(to)由于复制算法的原因，二选一使用，有一个是不存放数据的。因此实际计算的最大内存比设置的小。<br>-XX：+PrintGCDetails  打印GC过程中的细节<br>Throwable分为Exception和Error<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629779838469-9400c860-f9ec-4627-a51d-e08a2ba04352.png#clientId=u13abf8be-0370-4&from=paste&height=160&id=u946e2f87&originHeight=320&originWidth=593&originalType=binary&ratio=1&size=169083&status=done&style=none&taskId=ub4414acd-b5c0-4444-8604-c768fecb623&width=296.5" alt="image.png"><br>默认情况下：<br>新生代：老年代=1:2<br>Eden：s0：s1=8:1:1<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629780623831-b49a0fa7-1121-4fa7-8006-8bd1570ecab8.png#clientId=u13abf8be-0370-4&from=paste&height=81&id=u8e289695&originHeight=161&originWidth=960&originalType=binary&ratio=1&size=113795&status=done&style=none&taskId=u5a7cb92d-740d-445e-a7d3-e9fc4e097d7&width=480" alt="image.png"><br>没有引用指向的堆内存叫做垃圾<br>s0、s1为空的区域称为to区，年龄计数器达到15，对象进入老年代。Eden满了会触发Young GC,s0区垃圾回收是被动的，Young GC也触发so垃圾回收。老年代很少发生GC，大部分回收的都是新生代<br><strong>总结</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629784792722-df26c166-2ff3-442a-b65c-daf6b1eca475.png#clientId=u13abf8be-0370-4&from=paste&height=86&id=uf597ad85&originHeight=172&originWidth=1028&originalType=binary&ratio=1&size=169911&status=done&style=none&taskId=u3c2f5a7f-8ddc-4ab5-9968-7dc4c5ef8f0&width=514" alt="image.png"></p>
<p>超大对象有可能直接进入老年代，Eden存活的对象如果放不进so、s1，也有可能直接晋升老年代。老年代发生的垃圾回收是Full GC。发生10次Young GC，才有可能发生一次Full GC<br>老年代满了就会报OOM错误。调优就是让GC的次数尽量少一些，让用户线程执行的效率更高<br>Full GC收集整个堆空间和方法区的垃圾回收<br>如果Full GC后空间还是不足，就会报OOM</p>
<p><strong>分代的理由就是优化GC性能</strong></p>
<h3 id="3-内存分配策略"><a href="#3-内存分配策略" class="headerlink" title="3.内存分配策略"></a>3.内存分配策略</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629787476740-553323ed-080f-47a6-8466-0e53a00d0a1e.png#clientId=u13abf8be-0370-4&from=paste&height=294&id=u8c417f93&originHeight=588&originWidth=1084&originalType=binary&ratio=1&size=244823&status=done&style=none&taskId=u87efd833-17a6-4baa-999d-a36d34085fd&width=542" alt="image.png"><br>举例：<br>byte[] byte = new byte[1024 * 1024 * 20] 就是一个20M的大对象，如果该对象大于Eden区内存，就会直接被分配到老年代<br>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。TLAB一般占Eden的1%，是被每个线程私有的空间<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629789158389-795f9885-2100-463e-898a-82dd2489946a.png#clientId=u13abf8be-0370-4&from=paste&height=267&id=u75c65a67&originHeight=534&originWidth=1128&originalType=binary&ratio=1&size=295665&status=done&style=none&taskId=udc7c003e-0fed-4966-986d-fe6dce59e74&width=564" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629789540252-2c70efce-8d80-4ef7-bae8-df3631ce909f.png#clientId=u13abf8be-0370-4&from=paste&height=287&id=u26cc344d&originHeight=574&originWidth=1030&originalType=binary&ratio=1&size=666804&status=done&style=none&taskId=u93578466-1fbf-4062-a177-f2f81bd9436&width=515" alt="image.png"></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629791016955-dc4f5a5a-3d98-4690-8c95-b571d6e6c4ce.png#clientId=u13abf8be-0370-4&from=paste&height=107&id=ufa9a7c1f&originHeight=214&originWidth=1096&originalType=binary&ratio=1&size=141871&status=done&style=none&taskId=u2f2740f5-eadf-43e7-9cb0-7a85ddaae92&width=548" alt="image.png"></p>
<p>这个例子new出的对象，作用域只在当前方法有效，没有发生逃逸，因此对象存在栈中。<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629791319281-8468db6d-0d17-4146-adbb-1703046bf69c.png#clientId=u13abf8be-0370-4&from=paste&height=220&id=uee84c421&originHeight=440&originWidth=1163&originalType=binary&ratio=1&size=188930&status=done&style=none&taskId=u05f9ade8-8262-4e7a-af70-35d2446cccf&width=581.5" alt="image.png"><br>开启逃逸分析后，未发生逃逸的对象会分配到栈上，提高程序效率。但这种情况发生的较少，大部分实例对象还是存储在堆上的。</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629792761214-cc0910b1-41bc-4e34-97e4-f79546a7b082.png#clientId=u13abf8be-0370-4&from=paste&height=353&id=u6bce07b4&originHeight=706&originWidth=1223&originalType=binary&ratio=1&size=363870&status=done&style=none&taskId=u57f7a605-543b-48d8-b734-c699120e115&width=611.5" alt="image.png"><br>标量是指一个无法再分解为更小数据的数据<br>局部变量存储在栈中</p>
<h2 id="9-方法区"><a href="#9-方法区" class="headerlink" title="9 方法区"></a>9 方法区</h2><p>方法区的内部结构：永久代-&gt;元空间<br>方法区中存放程序加载的类的信息</p>
<h3 id="1-栈、堆、方法区的交互关系"><a href="#1-栈、堆、方法区的交互关系" class="headerlink" title="1.栈、堆、方法区的交互关系"></a>1.栈、堆、方法区的交互关系</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629794721183-1c589c47-f8ac-47e6-9390-af9ac96b993e.png#clientId=u13abf8be-0370-4&from=paste&height=279&id=u763f2ecd&originHeight=558&originWidth=1119&originalType=binary&ratio=1&size=442061&status=done&style=none&taskId=u8a038313-fa88-4511-ae59-5662a1b29fa&width=559.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629794762654-e2bd4c84-4bf6-436b-9796-bf3ba42bf720.png#clientId=u13abf8be-0370-4&from=paste&height=106&id=u6e36a0d3&originHeight=212&originWidth=673&originalType=binary&ratio=1&size=113305&status=done&style=none&taskId=u1275c830-da81-4bb4-88c3-8f8f66fd8e8&width=336.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629794822461-671533aa-ccae-4126-8235-095f233a3e40.png#clientId=u13abf8be-0370-4&from=paste&height=255&id=u37b1fd77&originHeight=509&originWidth=917&originalType=binary&ratio=1&size=219265&status=done&style=none&taskId=u70a3ad45-6b38-4725-90cd-3068ea62271&width=458.5" alt="image.png"><br>永久代可能发生OOM，元空间使用本地内存<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629855146047-e291704f-109a-4987-baa6-ce1770d53843.png#clientId=ucd0cf206-347d-4&from=paste&height=357&id=u7f29491d&originHeight=714&originWidth=1153&originalType=binary&ratio=1&size=508131&status=done&style=none&taskId=u3090c717-b5b0-40e3-952e-7e2777ca012&width=576.5" alt="image.png"><br><strong>方法区中存储类型信息、方法信息(方法修饰符、返回类型等)、运行时常量池</strong><br><strong>jdk8后字符串常量池、静态变量存放到堆中了</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629856657979-1535b1c8-575b-4916-b089-ea41ad8c0d52.png#clientId=ucd0cf206-347d-4&from=paste&height=188&id=u72264bdb&originHeight=376&originWidth=1252&originalType=binary&ratio=1&size=289373&status=done&style=none&taskId=u42bcb75d-b171-4f00-afb9-88babc8fadf&width=626" alt="image.png"></p>
<h3 id="2-运行时常量池"><a href="#2-运行时常量池" class="headerlink" title="2.运行时常量池"></a>2.运行时常量池</h3><p>字节码文件直接打开是乱码的，要反编译后才能看到正常的字节码文件信息<br>字节码文件的常量池存放编译期生成的各种数值量和对类型、方法的符号引用<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629858926522-f80aa6fb-adae-4ed0-a4ea-1b81747ac032.png#clientId=ucd0cf206-347d-4&from=paste&height=57&id=u067fb767&originHeight=114&originWidth=1076&originalType=binary&ratio=1&size=87571&status=done&style=none&taskId=uac868206-0d82-47ef-bc04-8b23b143ce6&width=538" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629859079287-86aeac79-f2d0-49e7-a0c5-234477929190.png#clientId=ucd0cf206-347d-4&from=paste&height=65&id=u7a048094&originHeight=130&originWidth=1143&originalType=binary&ratio=1&size=203868&status=done&style=none&taskId=u31321258-7c2a-4411-a70d-a1e32667f51&width=571.5" alt="image.png"></p>
<p><strong>Hotspot中方法区的变化：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629860979816-67127a2c-f772-4992-9aee-749a5ecd976b.png#clientId=ucd0cf206-347d-4&from=paste&height=175&id=u9180e1be&originHeight=350&originWidth=1202&originalType=binary&ratio=1&size=483928&status=done&style=none&taskId=u7dc957de-ac25-4043-84d1-1b4508ea2d6&width=601" alt="image.png"></p>
<p><strong>永久代为什么被元空间替代？</strong><br>对永久代设置空间大小是很难确定的；对永久代进行调优是很困难的</p>
<p>元空间使用本地内存，大大减少GC的次数<br>full gc是老年代、元空间空间不足时才会触发<br>方法区的垃圾回收主要包括两部分内容：常量池中废弃的常量和不再使用的类型</p>
<h2 id="10-对象的实例化内存布局与访问定位"><a href="#10-对象的实例化内存布局与访问定位" class="headerlink" title="10 对象的实例化内存布局与访问定位"></a>10 对象的实例化内存布局与访问定位</h2><h3 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1.对象的实例化"></a>1.对象的实例化</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629873860674-8ee56ce4-19db-4404-a4a9-ddbb546513ca.png#clientId=ucd0cf206-347d-4&from=paste&height=185&id=u049496e8&originHeight=370&originWidth=1036&originalType=binary&ratio=1&size=280433&status=done&style=none&taskId=u1f4b4245-cd21-481a-8e47-569e01fa3f8&width=518" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629875466339-2d3439d5-b809-44a7-8201-15808d00b0b9.png#clientId=ucd0cf206-347d-4&from=paste&height=231&id=u3fe91a71&originHeight=461&originWidth=1079&originalType=binary&ratio=1&size=321044&status=done&style=none&taskId=u172a3370-2d39-429d-9645-c9b83e1cd79&width=539.5" alt="image.png"></p>
<h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629876110451-58b972c1-2739-416d-890a-3855d5023b5d.png#clientId=ucd0cf206-347d-4&from=paste&height=366&id=u0db7d022&originHeight=732&originWidth=1612&originalType=binary&ratio=1&size=503719&status=done&style=none&taskId=ua4ea5341-e86a-4206-8be8-9ced428fc3c&width=806" alt="image.png"><br>类的对象头包含什么？<br>运行时元数据、类型指针。如果是数组，还需记录数组的长度</p>
<h3 id="3-对象访问方式"><a href="#3-对象访问方式" class="headerlink" title="3.对象访问方式"></a>3.对象访问方式</h3><p>句柄访问、直接指针</p>
<h2 id="11-直接内存"><a href="#11-直接内存" class="headerlink" title="11 直接内存"></a>11 直接内存</h2><p>直接内存是在Java堆外的、直接向系统申请的内存空间<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629877295021-12e3bdaf-5d8f-49a5-bdc5-9d57b9752e8f.png#clientId=uaf89972c-bb44-4&from=paste&height=62&id=u30a788c0&originHeight=123&originWidth=729&originalType=binary&ratio=1&size=87504&status=done&style=none&taskId=uaa3bfe9e-a649-404f-843d-4553351b78f&width=364.5" alt="image.png"><br>IO阻塞，NIO非阻塞</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629877882153-eb93981a-7d00-45b6-b96e-c5f9ac96465c.png#clientId=uaf89972c-bb44-4&from=paste&height=315&id=u13897082&originHeight=629&originWidth=1077&originalType=binary&ratio=1&size=266218&status=done&style=none&taskId=u814aee64-e3c5-4318-b574-62005e71a7e&width=538.5" alt="image.png"></p>
<h2 id="12-执行引擎"><a href="#12-执行引擎" class="headerlink" title="12 执行引擎"></a>12 执行引擎</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629879337019-9502e872-87b6-4832-a120-e25f7da767a2.png#clientId=uaf89972c-bb44-4&from=paste&height=261&id=ubc0c3d56&originHeight=522&originWidth=1030&originalType=binary&ratio=1&size=298696&status=done&style=none&taskId=ubebbd4ed-cbff-4762-8800-fe9e1e356fb&width=515" alt="image.png"><br>Java字节码的执行是由执行引擎完成的</p>
<p>Java为什么是半解释半编译的语言？<br>Java字节码文件既可以由解释器执行，也可以由JIT即时编译器执行</p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>机器码是由二进制编码方式表示的指令，能被计算机直接识别<br>汇编语言、高级语言都需要翻译成机器指令，才能被cpu解释执行</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629941432484-59a36d7c-f344-487a-b834-f8f84d8773c6.png#clientId=uf4b4ceb7-2a91-4&from=paste&height=165&id=u65695dee&originHeight=329&originWidth=1305&originalType=binary&ratio=1&size=359326&status=done&style=none&taskId=ue8a0cac9-aa46-45c1-8944-727b87947f0&width=652.5" alt="image.png"><br>Java字节码是由解释器翻译成平台对应的本地机器指令执行，由PC计数器记录下一条需要被解释的字节码指令</p>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629942514105-8782ff17-1245-432a-a1aa-31f338d23d8f.png#clientId=u6063d391-b81c-4&from=paste&height=70&id=ua0d51280&originHeight=139&originWidth=1096&originalType=binary&ratio=1&size=108831&status=done&style=none&taskId=ub3bf9f97-53e4-4c4f-b237-d18ff7c15d0&width=548" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629942608487-eb10be77-8397-475a-83ab-27cc674d4675.png#clientId=u6063d391-b81c-4&from=paste&height=54&id=u6ed436f7&originHeight=108&originWidth=1097&originalType=binary&ratio=1&size=247278&status=done&style=none&taskId=uecae7dda-e46b-41f1-bb8b-28fa5de490c&width=548.5" alt="image.png"><br>解释器响应快，JIT编译器效率高</p>
<p>那么，什么时候使用解释器，什么时候使用即时编译器呢？<br>采用基于计数器的热点探测，符合条件就把代码翻译成机器指令，并且缓存</p>
<p>设置程序执行方式<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629944022177-72bb5827-a210-43b6-8bab-88bc305d39d4.png#clientId=u6063d391-b81c-4&from=paste&height=118&id=u6cc85728&originHeight=235&originWidth=1059&originalType=binary&ratio=1&size=149526&status=done&style=none&taskId=udf20f722-da20-4796-9a1d-c140b60b014&width=529.5" alt="image.png"></p>
<p><strong>JIT编译器的分类</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629944313996-8bf19cc9-a40e-42b9-8536-d57c45753c41.png#clientId=u6063d391-b81c-4&from=paste&height=99&id=u12c91f76&originHeight=198&originWidth=1048&originalType=binary&ratio=1&size=207164&status=done&style=none&taskId=ucf529e31-c76f-47b1-842f-58502b621ad&width=524" alt="image.png"><br>64位的jdk只能采用-server的JIT编译器<br>C1就是-client方式，C2就是-server方式</p>
<h2 id="13-String-Table"><a href="#13-String-Table" class="headerlink" title="13 String Table"></a>13 String Table</h2><h3 id="1-String的基本特性"><a href="#1-String的基本特性" class="headerlink" title="1.String的基本特性"></a>1.String的基本特性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629946002105-20ef79d7-9dfc-4a3d-8112-abe9cb7c9c1a.png#clientId=u6063d391-b81c-4&from=paste&height=214&id=uda6622e7&originHeight=428&originWidth=976&originalType=binary&ratio=1&size=209250&status=done&style=none&taskId=ub3d607c5-b7f0-4d79-ab23-c2d030b34d8&width=488" alt="image.png"><br>jdk9中关于String的变化：char[]两个字节，byte[]一个字节，byte加上编码标记，节约了内存<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629946241716-7cbc41f6-7c5d-4477-8d5a-9709c9e79316.png#clientId=u6063d391-b81c-4&from=paste&height=212&id=uc8737b09&originHeight=424&originWidth=1022&originalType=binary&ratio=1&size=287089&status=done&style=none&taskId=udef65839-35da-45b0-928e-3c9e68b6771&width=511" alt="image.png"></p>
<p><strong>当字符串常量池中的字符串很多时，提高StringTableSize，性能会提高</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629947350933-01cae21c-809e-4d84-b1ed-27c447a31b7c.png#clientId=u6063d391-b81c-4&from=paste&height=278&id=u08d10dff&originHeight=556&originWidth=1060&originalType=binary&ratio=1&size=473841&status=done&style=none&taskId=u397dd46a-ae99-4446-a3bf-6faa4f9cefd&width=530" alt="image.png"><br>如果是成员变量，那么不分基本类型和引用类型都是在java的堆内存里面分配空间，而局部变量的基本类型是在栈上分配的。<br>栈中存放对象引用和局部变量，对象引用指向堆</p>
<h3 id="2-字符串的拼接操作"><a href="#2-字符串的拼接操作" class="headerlink" title="2.字符串的拼接操作"></a>2.字符串的拼接操作</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629949077938-55b1048d-2608-4d1e-bf55-8f5a420daeba.png#clientId=u6063d391-b81c-4&from=paste&height=321&id=u8a544e81&originHeight=642&originWidth=1317&originalType=binary&ratio=1&size=577546&status=done&style=none&taskId=uc850db53-52cd-466f-81e0-ae35aea1527&width=658.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629949008086-d7d0a664-758f-4e27-9d69-8e28bd083553.png#clientId=u6063d391-b81c-4&from=paste&height=78&id=u3d05ee21&originHeight=155&originWidth=1298&originalType=binary&ratio=1&size=262544&status=done&style=none&taskId=u238d18e4-d2c0-4b6a-8093-b7c8a46dedf&width=649" alt="image.png"></p>
<p>拼接操作出现变量的情况下，左右两边变量是不相等的<br><strong>String字符串拼接的过程出现变量，会创建一个StringBuilder、String对象</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629958120561-18fada2f-f55a-4e27-a2cb-fa3ba370e845.png#clientId=u6063d391-b81c-4&from=paste&height=179&id=u2755c2d8&originHeight=358&originWidth=709&originalType=binary&ratio=1&size=230989&status=done&style=none&taskId=udee9b2c5-fd27-44d5-a9da-5fbdaeb60d3&width=354.5" alt="image.png"><br>StringBuilder的append()方法自始至终只使用一个对象，最终打印字符串需要使用toString()方法<br>开发当中，如果大概确定字符串的长度，建议构造器设置StringBuilder的长度，避免扩容影响效率</p>
<h3 id="3-intern-的理解"><a href="#3-intern-的理解" class="headerlink" title="3.intern()的理解"></a>3.intern()的理解</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629959877615-3d6b5099-0789-451b-9633-640e00d3e7c0.png#clientId=u6063d391-b81c-4&from=paste&height=125&id=uf04acfb1&originHeight=250&originWidth=986&originalType=binary&ratio=1&size=257012&status=done&style=none&taskId=u53d34a6c-d205-4cf3-bd0f-c98975421c1&width=493" alt="image.png"><br><strong>intern()方法的作用是在字符串常量池中创建字符串常量</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629961937046-541222c8-b1fa-4fde-b2e4-c57302c64860.png#clientId=u6063d391-b81c-4&from=paste&height=99&id=u00d6eaa4&originHeight=198&originWidth=1029&originalType=binary&ratio=1&size=194320&status=done&style=none&taskId=u3507f380-0655-4282-99e6-f9e5881ce50&width=514.5" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629962196993-089b0768-5641-497d-8c1b-9eed14e75ef4.png#clientId=u6063d391-b81c-4&from=paste&height=151&id=u1cce43b6&originHeight=302&originWidth=1272&originalType=binary&ratio=1&size=377773&status=done&style=none&taskId=ueec969a7-8004-44ca-b518-b87063eab88&width=636" alt="image.png"><br><strong>对于程序中大量存在的重复字符串，使用intern()赋值字符串，可以节约内存空间和执行时间</strong></p>
<h2 id="14-垃圾回收概述"><a href="#14-垃圾回收概述" class="headerlink" title="14 垃圾回收概述"></a>14 垃圾回收概述</h2><p>类的加载器将字节码文件加载到内存中，再由执行引擎解释执行</p>
<h3 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h3><p>垃圾是指运行程序中没有任何指针指向的对象</p>
<h3 id="2-为什么需要GC"><a href="#2-为什么需要GC" class="headerlink" title="2.为什么需要GC"></a>2.为什么需要GC</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630289403778-32cda2c7-33e9-4bff-b96a-94012fd0b22a.png#clientId=ud05094b7-83b4-4&from=paste&height=265&id=u69b64a19&originHeight=353&originWidth=1076&originalType=binary&ratio=1&size=319568&status=done&style=none&taskId=u65e12bb7-6afc-4813-bda6-5e6265e7ad7&width=807" alt="image.png"><br>垃圾回收只作用于方法区和堆，堆是垃圾收集器的工作重点</p>
<h2 id="15-垃圾回收相关算法"><a href="#15-垃圾回收相关算法" class="headerlink" title="15 垃圾回收相关算法"></a>15 垃圾回收相关算法</h2><h3 id="1-垃圾标记阶段：对象存活判断"><a href="#1-垃圾标记阶段：对象存活判断" class="headerlink" title="1.垃圾标记阶段：对象存活判断"></a>1.垃圾标记阶段：对象存活判断</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630290991150-332fa14d-33e1-4162-b772-7a368ae287d2.png#clientId=u2ba75510-99d3-4&from=paste&height=265&id=u249d794c&originHeight=353&originWidth=1040&originalType=binary&ratio=1&size=325628&status=done&style=none&taskId=u15994713-c523-4a1d-995a-a807f561d28&width=780" alt="image.png"></p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>Java没有使用这种算法，这样很难处理循环引用关系，可能导致内存泄漏<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630291277135-cb109f88-eb8d-4097-b577-7caf9986f227.png#clientId=u2ba75510-99d3-4&from=paste&height=579&id=ubd8cb717&originHeight=579&originWidth=1070&originalType=binary&ratio=1&size=452397&status=done&style=none&taskId=ua150839b-1026-40fb-ac38-59c36d248c3&width=1070" alt="image.png"><br>内存泄漏：对象已经没有价值了，但不能被GC<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630291529720-abdfd012-532b-406c-b426-afac16f45fba.png#clientId=u2ba75510-99d3-4&from=paste&height=431&id=u5fc381e1&originHeight=574&originWidth=985&originalType=binary&ratio=1&size=99877&status=done&style=none&taskId=u41726c19-9357-4f71-b005-6870372efc4&width=739" alt="image.png"></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Java使用这种算法，解决循环引用的问题，防止内存泄漏的发生<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630292213986-16bae4ca-805d-41f1-84af-dbafc79466ab.png#clientId=u6de02a75-3b61-4&from=paste&height=389&id=u8b687a3d&originHeight=518&originWidth=1120&originalType=binary&ratio=1&size=441303&status=done&style=none&taskId=ucd0f6b2d-8871-4bbc-9e45-f23dbd23c82&width=840" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630292426293-d67c1b58-05c0-4327-9f53-daeb0cd69d53.png#clientId=u6de02a75-3b61-4&from=paste&height=628&id=u4d23e414&originHeight=628&originWidth=1172&originalType=binary&ratio=1&size=361167&status=done&style=none&taskId=u989c43a7-5fa1-4f92-823b-13128c16963&width=1172" alt="image.png"></p>
<h3 id="2-对象的finalization机制"><a href="#2-对象的finalization机制" class="headerlink" title="2.对象的finalization机制"></a>2.对象的finalization机制</h3><p>垃圾回收对象之前，总会先调用这个对象的finalize()方法，交给垃圾回收器去调用即可。<br>可达性分析算法：如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，但不一定这个对象就是非回收不可的，还会调用finalize()方法进行判断，对象存在三种状态。<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630293476317-c30ca8a1-0cb5-4419-95dd-41867d2f32c0.png#clientId=u6de02a75-3b61-4&from=paste&height=371&id=uf6dfddc3&originHeight=494&originWidth=1137&originalType=binary&ratio=1&size=454341&status=done&style=none&taskId=u4d9b93be-fc30-40cd-85b8-c9181926753&width=853" alt="image.png"></p>
<p><strong>两次标记过程判断对象是否需要回收</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630293612132-4b92949e-6257-4a88-a654-f6a33998998b.png#clientId=u6de02a75-3b61-4&from=paste&height=581&id=u9bc27961&originHeight=581&originWidth=1160&originalType=binary&ratio=1&size=457816&status=done&style=none&taskId=u7c636950-17d3-4fce-a408-cd904931363&width=1160" alt="image.png"><br>第一次标记，调用finalize()方法，对象可复活。第二次标记，由于finalize()已经调用，对象就需要被回收<br><strong>Jprofile  JVM的调优工具，要求熟练使用，至少会用一款工具即可。</strong></p>
<p>堆空间的实体没有对象的引用，就需要被回收</p>
<h3 id="3-垃圾清除阶段：标记-清除算法、复制算法、标记-整理算法"><a href="#3-垃圾清除阶段：标记-清除算法、复制算法、标记-整理算法" class="headerlink" title="3.垃圾清除阶段：标记-清除算法、复制算法、标记-整理算法"></a>3.垃圾清除阶段：标记-清除算法、复制算法、标记-整理算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630297963813-f44b6536-db46-4505-8d7c-7a805386b5ee.png#clientId=u6de02a75-3b61-4&from=paste&height=338&id=ucb11bc79&originHeight=338&originWidth=1176&originalType=binary&ratio=1&size=280999&status=done&style=none&taskId=udf404498-75d8-4969-9432-5eaa552f7d4&width=1176" alt="image.png"><br>标记-清除算法中：不可达的对象会被垃圾回收，标记的对象是可达对象<br>效率不太高，需要遍历两次，标记一次，清除一次，并且需要stw<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630302594932-1cab8627-2191-463b-bbc6-e4f783215951.png#clientId=u6de02a75-3b61-4&from=paste&id=ub3cb60ab&originHeight=532&originWidth=1162&originalType=binary&ratio=1&size=263731&status=done&style=none&taskId=u6aaabf36-7cc7-4268-822e-50b488a0880" alt="image.png"></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><strong>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630303024816-bc822346-c280-4b04-adaa-5c2d45f9df52.png#clientId=u6de02a75-3b61-4&from=paste&height=536&id=ud40c8011&originHeight=536&originWidth=1178&originalType=binary&ratio=1&size=303558&status=done&style=none&taskId=u0462fa03-f618-45f5-9edf-ff722deea6a&width=1178" alt="image.png"><br><strong>新生代的survivor区使用复制算法非常高效</strong></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>不仅清除了垃圾，还进行内存碎片的整理，效率会比标记-清除算法低一些<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630303556931-b69bac00-8a83-48e9-958b-222a9a5feb96.png#clientId=u6de02a75-3b61-4&from=paste&height=313&id=u8163145d&originHeight=418&originWidth=455&originalType=binary&ratio=1&size=93672&status=done&style=none&taskId=ud9aaf8ac-7635-4da8-926b-41612afedd1&width=341" alt="image.png"></p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p><strong>Java虚拟机的垃圾回收使用的是分代收集算法</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630304191242-5b0e7cd9-e66b-454d-9d0b-93ce8ddfd424.png#clientId=u6de02a75-3b61-4&from=paste&height=615&id=ucd702ff6&originHeight=615&originWidth=1256&originalType=binary&ratio=1&size=453490&status=done&style=none&taskId=ue30bb8d2-19d2-4ce4-bd97-b720a6dbf66&width=1256" alt="image.png"></p>
<p>标记清除算法，标记和清除时都要处于stop the world状态，用户线需要停止。</p>
<h2 id="5-增量收集算法"><a href="#5-增量收集算法" class="headerlink" title="5.增量收集算法"></a>5.增量收集算法</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630376240840-f01c79be-2709-431c-b686-64d4c7cbb30b.png#clientId=u4462d743-05f8-4&from=paste&id=u53a2c470&originHeight=638&originWidth=1243&originalType=binary&ratio=1&size=737980&status=done&style=none&taskId=u27e814a7-2657-4459-80ed-655e6add72e" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630376314078-5b18045b-74c7-4e26-8c6d-880bc48d6cf3.png#clientId=u4462d743-05f8-4&from=paste&id=udc1dffd8&originHeight=227&originWidth=1156&originalType=binary&ratio=1&size=151076&status=done&style=none&taskId=uc9a92a8d-5bcd-4417-b827-22e70ee6b4a" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630378715705-18946394-a2e1-413f-85f2-545ccf074ea5.png#clientId=u4462d743-05f8-4&from=paste&height=584&id=uc811707c&originHeight=584&originWidth=1158&originalType=binary&ratio=1&size=301664&status=done&style=none&taskId=ud7e93d45-6d38-44ae-a6a0-d9b324c4579&width=1158" alt="image.png"></p>
<h2 id="16-垃圾回收相关概念"><a href="#16-垃圾回收相关概念" class="headerlink" title="16 垃圾回收相关概念"></a>16 垃圾回收相关概念</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1.System.gc()的理解"></a>1.System.gc()的理解</h3><p><strong>Full GC就是对老年代进行垃圾回收，一般也会对新生代进行垃圾回收。</strong><br>调用这个方法，会触发Full GC，会对老年代和新生代进行垃圾回收。附带免责声明，提醒jvm进行垃圾回收，但是不确定是否马上执行gc</p>
<h3 id="2-内存溢出与内存泄漏"><a href="#2-内存溢出与内存泄漏" class="headerlink" title="2.内存溢出与内存泄漏"></a>2.内存溢出与内存泄漏</h3><p>内存溢出(OOM)：没有空闲内存，并且垃圾收集器也无法提供更多内存<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630380368148-56d4bdb6-e192-46b6-8a7a-c74d4e64a6ce.png#clientId=u4462d743-05f8-4&from=paste&id=ucc6da7ca&originHeight=553&originWidth=1091&originalType=binary&ratio=1&size=553757&status=done&style=none&taskId=u10746fc6-a975-4a7d-8efe-964dfbb6ff3" alt="image.png"><br>内存泄漏：只有对象不会再被程序用到，但是GC又不能回收他们的情况，才叫内存泄漏。内存泄漏的数据比较多的时候，是有可能导致OOM的。<br><strong>举例:</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630380965616-bdcedf42-6c6e-46b4-807e-7069f6edd8ec.png#clientId=u4462d743-05f8-4&from=paste&height=399&id=u4d66e9bc&originHeight=399&originWidth=1054&originalType=binary&ratio=1&size=216566&status=done&style=none&taskId=ueaa20aad-98bd-4d9a-8968-c25c8be5e4d&width=1054" alt="image.png"></p>
<h3 id="3-Stop-The-World"><a href="#3-Stop-The-World" class="headerlink" title="3.Stop The World"></a>3.Stop The World</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630381115578-03735b21-4da6-486f-8590-ac7e457ef078.png#clientId=u4462d743-05f8-4&from=paste&height=448&id=u588a0d00&originHeight=448&originWidth=1018&originalType=binary&ratio=1&size=433780&status=done&style=none&taskId=uf8fc6638-b8f2-40ab-bc41-6e76268a269&width=1018" alt="image.png"></p>
<h3 id="4-垃圾回收的并行与并发"><a href="#4-垃圾回收的并行与并发" class="headerlink" title="4.垃圾回收的并行与并发"></a>4.垃圾回收的并行与并发</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>同一个程序段内几个程序运行<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630389350393-edc78fb6-5c5f-4550-8b67-87d535fb65c4.png#clientId=u4462d743-05f8-4&from=paste&height=213&id=u392072ff&originHeight=213&originWidth=1085&originalType=binary&ratio=1&size=182629&status=done&style=none&taskId=ufb339c7f-ca07-499e-bbbc-efea2041d17&width=1085" alt="image.png"></p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>同一时间几个程序运行<br>决定并行的因素是CPU的核心数量，多个核就可以同时进行多个进程</p>
<h3 id="5-安全点与安全区域"><a href="#5-安全点与安全区域" class="headerlink" title="5.安全点与安全区域"></a>5.安全点与安全区域</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630389734253-d88881be-25c8-49ea-901e-f3e51623768a.png#clientId=u4462d743-05f8-4&from=paste&height=377&id=u72ad9510&originHeight=377&originWidth=1011&originalType=binary&ratio=1&size=352753&status=done&style=none&taskId=u0c370348-04db-4b56-ab75-40c0cf770b8&width=1011" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630389908003-c7cf6d0c-ba21-4e24-871e-5c4eedb0dda0.png#clientId=u4462d743-05f8-4&from=paste&height=133&id=u79cd12d3&originHeight=133&originWidth=1069&originalType=binary&ratio=1&size=170717&status=done&style=none&taskId=u11fe7d11-927d-40c7-81b2-ea8d7d713e5&width=1069" alt="image.png"></p>
<h3 id="6-Java中引用的概念"><a href="#6-Java中引用的概念" class="headerlink" title="6.Java中引用的概念"></a>6.Java中引用的概念</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630390720784-015a6cb5-ec0b-4b90-ad36-cf759c55c4a1.png#clientId=u4462d743-05f8-4&from=paste&height=442&id=L3NCl&originHeight=442&originWidth=1075&originalType=binary&ratio=1&size=512175&status=done&style=none&taskId=ued4b5679-96b1-45d7-90bf-892e704acad&width=1075" alt="image.png"><br>以上四种引用，都是在引用关系还存在的情况下进行讨论，即可达的情况<br>栈帧中的局部变量表指向堆空间的对象</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>GC Roots中的引用指向堆空间的对象，属于强引用的范畴<br>日常开发中99%的对象都是强引用<br>强引用是造成内存泄漏的主要原因</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>系统将要发生内存溢出之前，才会把软引用对象回收。当内存够的时候，不会清除软引用<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630391784379-9ed29bd6-0a8c-46c6-a46d-4540ed15f064.png#clientId=u4462d743-05f8-4&from=paste&height=341&id=udc4c5787&originHeight=341&originWidth=1076&originalType=binary&ratio=1&size=200532&status=done&style=none&taskId=u918bca12-8e96-4732-a823-35e53ae85c1&width=1076" alt="image.png"></p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被<strong>弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong><br>软引用、弱引用非常适合来保存那些可有可无的缓存数据</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用即对象回收跟踪<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630392374940-ca659243-5894-48ce-898a-a485d2558a9a.png#clientId=u4462d743-05f8-4&from=paste&height=452&id=udfd7debb&originHeight=452&originWidth=1156&originalType=binary&ratio=1&size=389041&status=done&style=none&taskId=u963a32c5-38ce-4516-88e1-f8b256c8960&width=1156" alt="image.png"><br>守护线程：当程序中没有非守护线程时，守护线程也执行结束</p>
<h2 id="17-垃圾回收器"><a href="#17-垃圾回收器" class="headerlink" title="17 垃圾回收器"></a>17 垃圾回收器</h2><p>Java发展至今已经衍生了众多的GC版本<br><strong>jdk8默认的垃圾回收器是并行回收器，新生代用Parallel GC、老年代用Parallel Old GC。这两个垃圾回收器是搭配使用，互相激活</strong><br><strong>jdk9默认的垃圾回收器是并发回收器，使用G1 GC</strong></p>
<h3 id="1-Java8的新特性"><a href="#1-Java8的新特性" class="headerlink" title="1.Java8的新特性"></a>1.Java8的新特性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630461931527-db727212-52f4-44cb-916d-bd64559d0ca0.png#clientId=u166ac774-42da-4&from=paste&height=111&id=u188924b9&originHeight=111&originWidth=800&originalType=binary&ratio=1&size=75981&status=done&style=none&taskId=u485acb2c-fe73-4f8e-95a3-110bd4ec615&width=800" alt="image.png"></p>
<h3 id="2-垃圾回收器的分类和性能指标"><a href="#2-垃圾回收器的分类和性能指标" class="headerlink" title="2.垃圾回收器的分类和性能指标"></a>2.垃圾回收器的分类和性能指标</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630463591490-f7d025ac-0daf-4352-9824-4da20c3601c8.png#clientId=u166ac774-42da-4&from=paste&height=456&id=u5256ddad&originHeight=456&originWidth=1048&originalType=binary&ratio=1&size=337994&status=done&style=none&taskId=u64fd0a23-e4c5-4fc0-ba1c-a68d5d63bbd&width=1048" alt="image.png"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630464096628-e7e9ca96-4e1a-44df-b421-b861b4523b93.png#clientId=u166ac774-42da-4&from=paste&height=472&id=u6e1ed6ef&originHeight=472&originWidth=1008&originalType=binary&ratio=1&size=315299&status=done&style=none&taskId=uab549246-fa77-47f6-9359-e70cb611405&width=1008" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630465054106-2aa3d230-1790-415d-9150-0cb963e1ea72.png#clientId=u166ac774-42da-4&from=paste&height=286&id=u204cf35a&originHeight=286&originWidth=1033&originalType=binary&ratio=1&size=153289&status=done&style=none&taskId=u6f4cf208-f7ff-4901-b134-2839f2159e8&width=1033" alt="image.png"></p>
<h3 id="3-垃圾回收器的介绍"><a href="#3-垃圾回收器的介绍" class="headerlink" title="3.垃圾回收器的介绍"></a>3.垃圾回收器的介绍</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630465481453-cec80db8-a312-4dad-acbf-9a3808627d8f.png#clientId=u166ac774-42da-4&from=paste&height=161&id=u7ca9b4cb&originHeight=161&originWidth=923&originalType=binary&ratio=1&size=69589&status=done&style=none&taskId=u90ab0f3e-0084-43cb-a587-734e79bb1c0&width=923" alt="image.png"><br><strong>并发：用户线程和垃圾回收线程可以同时执行</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630465776502-2ecc6179-c651-4917-be87-699f9df3aabb.png#clientId=u166ac774-42da-4&from=paste&height=509&id=u479d66ec&originHeight=509&originWidth=967&originalType=binary&ratio=1&size=238784&status=done&style=none&taskId=ucf2b3bb3-3e9b-42c5-a254-e27458a90c6&width=967" alt="image.png"></p>
<h4 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h4><p>CMS GC作用于老年代，使用标记-清除算法<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630476192202-33ea688e-2ef1-46fd-9d37-2c516ddcbef5.png#clientId=u166ac774-42da-4&from=paste&height=560&id=u2a4031d2&originHeight=560&originWidth=1159&originalType=binary&ratio=1&size=577447&status=done&style=none&taskId=u913c099d-878d-4dce-a5f7-bc429c70807&width=1159" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630476406558-0f5901b0-d9a8-4f6e-9c1e-d31589bbb096.png#clientId=u166ac774-42da-4&from=paste&height=229&id=uf73fadcb&originHeight=229&originWidth=905&originalType=binary&ratio=1&size=112433&status=done&style=none&taskId=ueed5252d-e0cd-4c51-87c0-816bb79cdb2&width=905" alt="image.png"></p>
<h4 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h4><p>Parallel 和 Parallel Old垃圾回收可以达到吞吐量最优<br><strong>G1的优点：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630551225017-2314aecd-fb99-4bbe-94ec-2a87c710931e.png#clientId=u323e6f6e-8d0a-4&from=paste&height=534&id=u149141b3&originHeight=534&originWidth=1176&originalType=binary&ratio=1&size=495497&status=done&style=none&taskId=u5485145b-b038-4bc6-8ec2-ed44d438a30&width=1176" alt="image.png"><br><strong>G1的分区：堆空间被分为若干个区域</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630551392602-bc55edb4-5cd2-4b21-8a8a-d857f33c3610.png#clientId=u323e6f6e-8d0a-4&from=paste&height=385&id=u2d7a789c&originHeight=385&originWidth=1224&originalType=binary&ratio=1&size=300294&status=done&style=none&taskId=udbb36a04-a07f-49fb-9f24-0007104e05f&width=1224" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630551684996-c3a95c36-7d8c-44c2-9569-6dd801cd7485.png#clientId=u323e6f6e-8d0a-4&from=paste&height=314&id=ue0e7931e&originHeight=314&originWidth=1122&originalType=binary&ratio=1&size=330360&status=done&style=none&taskId=u9013c6f5-5fbf-4dba-9732-19fda5e25b8&width=1122" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630551698681-695bc8ac-fb54-4fed-8701-450e28f25971.png#clientId=u323e6f6e-8d0a-4&from=paste&height=489&id=ubab27b4c&originHeight=489&originWidth=1173&originalType=binary&ratio=1&size=517560&status=done&style=none&taskId=ubf5d3552-8239-46fe-9476-032a330a6a3&width=1173" alt="image.png"><br><strong>G1的缺点：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630551944501-ed2cf65c-e9d4-477d-97d1-bb1fa90b2b7c.png#clientId=u57d5fed1-f4d6-4&from=paste&height=287&id=u95603419&originHeight=287&originWidth=1151&originalType=binary&ratio=1&size=183859&status=done&style=none&taskId=u979a3b71-1912-44d8-8e18-dd5b252dce8&width=1151" alt="image.png"><br><strong>G1回收器的参数设置：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630552078826-71308c5e-ff9d-4d8c-942c-add41a078595.png#clientId=u57d5fed1-f4d6-4&from=paste&height=607&id=uc4e26004&originHeight=607&originWidth=1221&originalType=binary&ratio=1&size=640605&status=done&style=none&taskId=ude4cf748-e064-497a-bc28-ab95bc88c56&width=1221" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630558300107-3d2677ab-24b4-47ed-8390-a3e0a2df1a2e.png#clientId=u57d5fed1-f4d6-4&from=paste&height=299&id=uf27258ec&originHeight=299&originWidth=1148&originalType=binary&ratio=1&size=255878&status=done&style=none&taskId=u0a7bb9df-2dc8-4478-b239-31245b69f89&width=1148" alt="image.png"><br>G1回收器作用于新生代和老年代<br><strong>G1回收器垃圾回收过程：新生代GC + 并发标记过程 + 混合回收</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630562203749-f382f746-745e-492f-b4d2-4d873940269e.png#clientId=u57d5fed1-f4d6-4&from=paste&height=602&id=u1aa73fd8&originHeight=602&originWidth=1285&originalType=binary&ratio=1&size=197806&status=done&style=none&taskId=u694619f1-e646-405d-a4a3-819618dfe79&width=1285" alt="image.png"><br><strong>G1的初衷就是要尽量避免Full  GC，降低暂停时间，提高用户使用流畅度</strong><br><strong>ZGC比G1流畅度提升不少，ZGC还处于Oracle的测试已当中</strong></p>
<h3 id="4-垃圾回收器总结"><a href="#4-垃圾回收器总结" class="headerlink" title="4.垃圾回收器总结"></a>4.垃圾回收器总结</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630563320057-5dc84ab1-d689-4b52-9cfc-bdcc03b9288b.png#clientId=u57d5fed1-f4d6-4&from=paste&height=601&id=u83ff6d41&originHeight=601&originWidth=1333&originalType=binary&ratio=1&size=1052606&status=done&style=none&taskId=u6ef69242-0e49-4e87-afc8-15776deb7b8&width=1333" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630563564448-e47e1214-cd7b-4728-a5e4-b4d7e9034c8a.png#clientId=u57d5fed1-f4d6-4&from=paste&height=169&id=ufdb6edff&originHeight=169&originWidth=1251&originalType=binary&ratio=1&size=148353&status=done&style=none&taskId=u64b0366b-9cab-4a43-a700-17e4b5ae147&width=1251" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630563765098-dd726841-51a6-4cc1-bd08-37505a8802f0.png#clientId=u57d5fed1-f4d6-4&from=paste&height=396&id=ue854dd29&originHeight=396&originWidth=1193&originalType=binary&ratio=1&size=301676&status=done&style=none&taskId=u4b5031cf-a687-4dc6-9560-760969a1023&width=1193" alt="image.png"><br><strong>jdk8可以通过设置虚拟机参数使用G1回收器</strong></p>
<h3 id="5-GC日志分析"><a href="#5-GC日志分析" class="headerlink" title="5.GC日志分析"></a>5.GC日志分析</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630572458403-b4543263-d615-451d-b93c-61767e8368f1.png#clientId=ube3d22ce-0f07-4&from=paste&height=177&id=uf68a85cb&originHeight=177&originWidth=1185&originalType=binary&ratio=1&size=135272&status=done&style=none&taskId=u7dd12306-7e2b-4995-b2a4-fbf607ff9e7&width=1185" alt="image.png"><br>GCViewer、<strong>GCEasy</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630572532472-773e2c0f-c3a8-46b0-9ac8-37a2c6298b7d.png#clientId=ube3d22ce-0f07-4&from=paste&height=197&id=ufb2fabd0&originHeight=197&originWidth=1167&originalType=binary&ratio=1&size=100404&status=done&style=none&taskId=ue66df871-e17b-487c-88a4-dfbad66cd25&width=1167" alt="image.png"></p>
<h3 id="6-垃圾回收器发展"><a href="#6-垃圾回收器发展" class="headerlink" title="6.垃圾回收器发展"></a>6.垃圾回收器发展</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630572907016-00982c28-0357-4450-bcda-13e65e2edd5b.png#clientId=ube3d22ce-0f07-4&from=paste&height=206&id=u16ee021f&originHeight=275&originWidth=618&originalType=binary&ratio=1&size=104084&status=done&style=none&taskId=ud1765bd4-1863-4e8b-b3d3-b9ef6703252&width=464" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630573166463-4c0d9aad-4ce3-49b3-81ab-07643daa9735.png#clientId=ube3d22ce-0f07-4&from=paste&height=305&id=u848e6383&originHeight=305&originWidth=1115&originalType=binary&ratio=1&size=164728&status=done&style=none&taskId=u63d16d1b-b378-459b-97ac-e52e1b2cfe8&width=1115" alt="image.png"></p>
<h1 id="字节码与类的加载篇"><a href="#字节码与类的加载篇" class="headerlink" title="字节码与类的加载篇"></a>字节码与类的加载篇</h1><h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1 Class文件结构"></a>1 Class文件结构</h2><p>Java虚拟机：跨平台的语言。可以处理很多不同的语言<br>Java虚拟机官方规范<br>JVM引入JIT即时编译器，效率高了很多<br>栈的局部变量表和操作数栈<br>Integer的范围是-128-127，超出范围返回一个new的Integer对象<br>字节码文件是实现java语言跨平台性的本质</p>
<p>Class文件的标识：魔数</p>
<p>Class文件版本号：主版本一般是会改变的(魔数+主版本+副版本)<br>高版本的虚拟机可以解析低版本的字节码文件</p>
<p><strong>Demo字节码的解析：比较复杂，了解即可—-常量池数据的解读</strong><br>使用jclasslib工具解析会更加方便<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631017910833-7f14dded-6758-4522-8bf0-cd69ee2ed7ed.png#clientId=ue061f95a-63f3-4&from=paste&height=413&id=ua8a3461f&originHeight=413&originWidth=1298&originalType=binary&ratio=1&size=601855&status=done&style=none&taskId=u46eb1211-1dc6-4296-bcea-58ce00e07b5&width=1298" alt="image.png"></p>
<h2 id="2-访问标识"><a href="#2-访问标识" class="headerlink" title="2 访问标识"></a>2 访问标识</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jvm虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk9-17 新特性</title>
    <url>/posts/c1f7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="Java新特性介绍"><a href="#Java新特性介绍" class="headerlink" title="Java新特性介绍"></a>Java新特性介绍</h1><p>Java 8是Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java并没有就此止步，而是继续不断发展壮大，几乎每隔6个月，就会冒出一个新版本，最新的版本已经快要迭代到Java 20了，与Java 8相差了足足十来个版本，但是由于Java 8的稳定和生态完善（目前仍是LTS长期维护版本），依然有很多公司在坚持使用Java 8，不过随着SpringBoot 3.0的到来，现在强制要求使用Java 17版本（同样也是LTS长期维护版本），下一个Java版本的时代，或许已经临近了。</p>
<p>​<span id="more"></span></p>
<h2 id="Java-8-关键特性回顾"><a href="#Java-8-关键特性回顾" class="headerlink" title="Java 8 关键特性回顾"></a>Java 8 关键特性回顾</h2><p>在开始之前，我们先来回顾一下Java 8中学习的Lambda表达式和Optional类，有关Stream API请各位小伙伴回顾一下Java SE篇视频教程，这里不再进行介绍。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来搞事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;   <span class="comment">//创建一个实现Runnable的匿名内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">//具体的实现逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在<code>run()</code>方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p>
<p>在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减，实际上我们进行观察会发现，真正有用的那一部分代码，实际上就是我们对<code>run()</code>方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，那么我们能否针对于这种情况进行优化呢？我们现在只需要一个简短的lambda表达式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//只需留下我们需要具体实现的方法体</span></span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于<code>() ‐&gt; &#123; 代码语句 &#125;</code>的形式进行替换即可。是不是感觉瞬间代码清爽了N倍？</p>
<p>当然这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p>
<blockquote>
<p>但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过<code>invokedynamic</code>指令实现的，不难发现，匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();   <span class="comment">//这里我们拋个异常看看</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pm4fpasnj21e202qdgc.jpg" alt="image-20220529214948350"></p>
<p>可以看到，实际上是Main类中的<code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如Runnable接口需要一个方法体对它的<code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p>
</blockquote>
<p>我们来看一下Lambda表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<p>比如我们之前使用的Runable类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>   <span class="comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;   <span class="comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Runable的的匿名内部类实现，就可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;    &#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以写一个玩玩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;   <span class="comment">//接口类型</span></span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;    <span class="comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的Lambda表达式的实现就可以写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = (Integer i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;  <span class="comment">//这里我们就简单将i转换为字符串形式</span></span><br></pre></td></tr></table></figure>

<p>不过还可以进行优化，首先方法参数类型是可以省略的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = (i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = i -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = i -&gt; i+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，相比我们之前直接去编写一个匿名内部类，是不是简介了很多很多。当然，除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;   <span class="comment">//接口中的定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;   <span class="comment">//现在有一个静态方法，刚好匹配接口中抽象方法的返回值和参数列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来，这也是为什么前面说<code>是我们为所需要的接口提供了一个方法作为它的实现</code>，是不是越来越体会到这句话的精髓了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = Main::impl;    <span class="comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要对一个数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;   <span class="comment">//来个数组</span></span><br><span class="line">    Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;   <span class="comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(array));   <span class="comment">//按从小到大的顺序排列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，Integer类中有一个叫做<code>compare</code>的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是一个静态方法，但是它却和<code>Comparator</code>需要实现的方法返回值和参数定义一模一样，所以，懂的都懂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compare);   <span class="comment">//直接指定一手，效果和上面是一模一样</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么要是不是静态方法而是普通的成员方法呢？我们注意到Comparator要求我们实现的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1 - o2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中o1和o2都是Integer类型的，我们发现Integer类中有一个<code>compareTo</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只不过这个方法并不是静态的，而是对象所有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);   <span class="comment">//这样进行比较也行，和上面效果依然是一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<p>但是此时我们会发现，IDEA提示我们可以缩写，这是为什么呢？实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，<code>o1</code>作为目标对象，<code>o2</code>作为参数，正好匹配了<code>compareTo</code>方法，所以，直接缩写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compareTo);  <span class="comment">//注意这里调用的不是静态方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Main mainObject = <span class="keyword">new</span> Main();</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, mainObject::reserve);  <span class="comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reserve</span><span class="params">(Integer a, Integer b)</span></span>&#123;  <span class="comment">//现在Main类中有一个刚好匹配的方法</span></span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，类的构造方法同样可以作为方法引用传递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(String str)</span></span>;   <span class="comment">//现在我们需要一个参数为String返回值为String的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，String类中刚好有一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;   <span class="comment">//由于String类的构造方法返回的肯定是一个String类型的对象，且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span></span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = original.coder;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是乎：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = String::<span class="keyword">new</span>;   <span class="comment">//没错，构造方法直接使用new关键字就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。</p>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。我们先来看看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;   <span class="comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span></span><br><span class="line">    System.out.println(str.toLowerCase());  <span class="comment">//那太简单了吧，直接转换打印一气呵成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样实现的话，我们少考虑了一个问题，万一给进来的<code>str</code>是<code>null</code>呢？如果是<code>null</code>的话，在调用<code>toLowerCase</code>方法时岂不是直接空指针异常了？所以我们还得判空一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决，这时，Optional来了，我们可以将任何的变量包装进Optional类中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(s -&gt; &#123;   <span class="comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span></span><br><span class="line">                System.out.println(s);   </span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里只有一句打印，所以我们来优化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(System.out::println);  </span><br><span class="line">  	<span class="comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p>
<p>除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).get());</span><br></pre></td></tr></table></figure>

<p>不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).orElse(<span class="string">&quot;VVV&quot;</span>));   <span class="comment">//orElse表示如果为空就返回里面的内容</span></span><br></pre></td></tr></table></figure>

<p>其他操作还请回顾JavaSE篇视频教程。</p>
<h2 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h2><p>这一部分，我们将介绍Java 9为我们带来的新特性，Java 9的主要特性有，全新的模块机制、接口的private方法等。</p>
<h3 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h3><p>在我们之前的开发中，不知道各位有没有发现一个问题，就是当我们导入一个<code>jar</code>包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库，实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。</p>
<p>于是，Java 9引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofan3qvxj21b409qjs3.jpg" alt="image-20220528210803658"></p>
<p>而在引入模块机制之后：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofcn7rt7j219009y3za.jpg" alt="image-20220528210958964"></p>
<p>可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。这里我们创建一个新的项目，并在<code>src</code>目录下，新建<code>module-info.java</code>文件表示此项目采用模块管理机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来创建一个主类：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofzqina8j21lo0bymyz.jpg" alt="image-20220528213210752"></p>
<p>程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2og24c18zj216o07gwf7.jpg" alt="image-20220528213428296"></p>
<p>Java为我们提供的<code>logging</code>相关日志库呢？我们发现现在居然不见了？实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库</span></span><br><span class="line">  	<span class="comment">//当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se;  即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们导入java.logging相关模块后，就可以正常使用Logger了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogarnv3hj21oi0bewgd.jpg" alt="image-20220528214247006"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogb52z1fj214203ejrl.jpg" alt="image-20220528214308194"></p>
<p>是不是瞬间感觉编写代码时清爽了许多，全新的模块化机制提供了另一个级别的Java代码可见性、可访问性的控制，不过，你以为仅仅是做了包的分离吗？我们可以来尝试通过反射获取JDK提供的类中的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java17版本的String类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>,</span></span><br><span class="line"><span class="class">               <span class="title">Constable</span>, <span class="title">ConstantDesc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;  <span class="comment">//自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">    Field field = stringClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);   <span class="comment">//这里我们通过反射来获取String类中的value字段</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//由于是private访问权限，所以我们修改一下</span></span><br><span class="line">    System.out.println(field.get(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，在程序运行之后，修改操作被阻止了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ohbps200j22l008qgpe.jpg" alt="image-20220528221817482"></p>
<p>反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的，看来Unsafe类是玩不成了。</p>
<p>我们现在就来细嗦一下这个模块机制，首先模块具有四种类型：</p>
<ul>
<li><strong>系统模块：</strong>来自JDK和JRE的模块（官方提供的模块，比如我们上面用的），我们也可以直接使用<code>java --list-modules</code>命令来列出所有的模块，不同的模块会导出不同的包供我们使用。</li>
<li><strong>应用程序模块：</strong>我们自己写的Java模块项目。</li>
<li><strong>自动模块：</strong>可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。</li>
<li><strong>未命名模块：</strong>我们自己创建的一个Java项目，如果没有创建<code>module-info.java</code>，那么会按照未命名模块进行处理，未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。不过，由于没有使用Java 9的模块新特性，未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）</li>
</ul>
<p>这里我们就来创建两个项目，看看如何使用模块机制，首先我们在项目A中，添加一个User类，一会项目B需要用到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (&quot;</span>+age+<span class="string">&quot;岁)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们编写一下项目A的模块设置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ois6anujj21mu09075b.jpg" alt="image-20220528230842617"></p>
<p>这里我们将<code>com.test</code>包下所有内容都暴露出去，默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用。</p>
<p>接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2oj4ivmi3j21kw08ujsm.jpg" alt="image-20220528232033318"></p>
<p>现在我们就可以在Main类中使用模块<code>module.a</code>中暴露出来的包内容了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.User;   <span class="comment">//如果模块module.a不暴露，那么将无法导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;lbw&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了普通的<code>exports</code>进行包的暴露之外，我们也可以直接指定将包暴露给指定的模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过现在还有一个问题，如果模块<code>module.a</code>依赖于其他模块，那么会不会传递给依赖于模块<code>module.a</code>的模块呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//这里添加一个模块的依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2njtdxyj21gu09iabi.jpg" alt="image-20220529103614788"></p>
<p>可以看到，在模块<code>module.b</code>中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用，但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> transitive java.logging;   <span class="comment">//使用transitive来向其他模块传递此依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以使用了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2pvizv2j21cu0b275z.jpg" alt="image-20220529103828560"></p>
<p>还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    Class&lt;User&gt; userClass = User.class;</span><br><span class="line">    Field field = userClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//尝试修改访问权限</span></span><br><span class="line">    System.out.println(field.get(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2widxrbj22l608cwip.jpg" alt="image-20220529104451040"></p>
<p>那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;   <span class="comment">//直接添加open关键字开放整个模块的反射权限</span></span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    opens com.test;   <span class="comment">//通过使用opens关键字来为其他模块开放反射权限</span></span><br><span class="line">  	<span class="comment">//也可以指定目标开放反射 opens com.test to module.b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以指定模块需要使用的抽象类或是接口实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    uses com.test.Test;  <span class="comment">//使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在模块B中去实现一下，然后声明我们提供了实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestImpl</span> <span class="keyword">implements</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.b &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.a;   <span class="comment">//导入项目A的模块，此模块暴露了com.test包</span></span><br><span class="line">    provides com.test.Test with com.main.TestImpl;  <span class="comment">//声明此模块提供了Test的实现类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p3zb45vqj225w0qowlb.jpg" alt="image-20220529112208486"></p>
<p>然后我们导入了lombok框架的依赖，如果我们不创建<code>module-info.java</code>文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.java.Log;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//使用lombok提供的注解，可以正常运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好<code>module-info.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，直接报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p44huvl1j21tk0bcmzz.jpg" alt="image-20220529112707958"></p>
<p>明明导入了lombok依赖，却无法使用，这是因为我们还需要去依赖对应的模块才行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">    <span class="keyword">requires</span> lombok;   <span class="comment">//lombok模块</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;    <span class="comment">//JUL日志模块，也需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p46lqnndj21au0fu0ug.jpg" alt="image-20220529112909452"></p>
<p>这样我们就可以正常使用了，之后为了教程演示方便，咱们还是不用模块。</p>
<h3 id="JShell交互式编程"><a href="#JShell交互式编程" class="headerlink" title="JShell交互式编程"></a>JShell交互式编程</h3><p>Java 9为我们通过了一种交互式编程工具JShell，你还别说，真有Python那味。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p8zzjlfdj20v204yaaf.jpg" alt="image-20220529141547082"></p>
<p>环境配置完成后，我们只需要输入<code>jshell</code>命令即可开启交互式编程了，它支持我们一条一条命令进行操作。</p>
<p>比如我们来做一个简单的计算：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p91l5635j212609qt8z.jpg" alt="image-20220529141719363"></p>
<p>我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p949kt5nj20ze06sdg8.jpg" alt="image-20220529141954494"></p>
<p>我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p986jzkdj215608074z.jpg" alt="image-20220529142340030"></p>
<p>除了直接运行我们写进去的代码之外，它还支持使用命令，输入<code>help</code>来查看命令列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p998buwcj217m0a4t9r.jpg" alt="image-20220529142440584"></p>
<p>比如我们可以使用<code>/vars</code>命令来展示当前定义的变量列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9cn6p6qj20wy042t8s.jpg" alt="image-20220529142757286"></p>
<p>当我们不想使用jshell时，直接输入<code>/exit</code>退出即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9dlqiucj20rw03274b.jpg" alt="image-20220529142852920"></p>
<h3 id="接口中的private方法"><a href="#接口中的private方法" class="headerlink" title="接口中的private方法"></a>接口中的private方法</h3><p>在Java 8中，接口中 的方法支持添加<code>default</code>关键字来添加默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9中，接口再次得到强化，现在接口中可以存在私有方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的私有方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。</p>
<h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>在之前，如果我们想要快速创建一个Map只能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//要快速使用Map，需要先创建一个Map对象，然后再添加数据</span></span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9之后，我们可以直接通过<code>of</code>方法来快速创建了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">20</span>);  <span class="comment">//直接一句搞定</span></span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9ymylq6j21k00ggact.jpg" alt="image-20220529144905646"></p>
<p>但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是无法进行修改的。</p>
<p>当然，除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;AAA&quot;</span>);  <span class="comment">//注意Set中元素顺序并不一定你的添加顺序</span></span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;BBB&quot;</span>);   <span class="comment">//好耶，再也不用Arrays了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h3><p>还记得我们之前在JavaSE中学习的Stream流吗？当然这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//这里我们可以直接将一些元素封装到Stream中</span></span><br><span class="line">            .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">            .distinct()   <span class="comment">//去重</span></span><br><span class="line">            .forEach(System.out::println);   <span class="comment">//最后打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成（具体的详细操作请回顾JavaSE篇）</p>
<p>如此方便的框架，在Java 9得到了进一步的增强：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="keyword">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream</span><br><span class="line">            .ofNullable(<span class="keyword">null</span>) <span class="comment">//使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)   <span class="comment">//Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。</span></span><br><span class="line">      			.limit(<span class="number">20</span>)   <span class="comment">//这里限制生成20个</span></span><br><span class="line">            .forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            <span class="comment">//不知道怎么写？参考一下：for (int i = 0;i &lt; 20;i++)</span></span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .takeWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//当i小于10时正常通过，一旦大于等于10直接截断</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .dropWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//和上面相反，上来就是截断状态，只有当满足条件时再开始通过</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他小型变动"><a href="#其他小型变动" class="headerlink" title="其他小型变动"></a>其他小型变动</h3><p>Try-with-resource语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = Files.newInputStream(Paths.get(<span class="string">&quot;pom.xml&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> (inputStream) &#123;   <span class="comment">//单独丢进try中，效果是一样的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) inputStream.read());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 8中引入了Optional类，它很好的解决了判空问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    test(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//比如现在我们想执行 System.out.println(str.toLowerCase())</span></span><br><span class="line">    <span class="comment">//但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常</span></span><br><span class="line">    <span class="comment">//但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装</span></span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(s)</span><br><span class="line">            .ifPresent(str -&gt; System.out.println(str.toLowerCase()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就有点像Kotlin或是JS中的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str : <span class="type">String</span>?)</span></span>&#123;   <span class="comment">//传入的String对象可能为null，这里类型写为String?</span></span><br><span class="line">    println(str?.lowercase())   <span class="comment">// ?.表示只有不为空才进行调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 9新增了一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str).ifPresentOrElse(s -&gt; &#123;  <span class="comment">//通过使用ifPresentOrElse，我们同时处理两种情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为：&quot;</span>+s);     <span class="comment">//第一种情况和ifPresent是一样的</span></span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为null&quot;</span>);   <span class="comment">//第二种情况是如果为null的情况</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>or()</code>方法快速替换为另一个Optional类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str)</span><br><span class="line">      .or(() -&gt; Optional.of(<span class="string">&quot;AAA&quot;</span>))   <span class="comment">//如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装</span></span><br><span class="line">      .ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还支持直接转换为Stream，这里就不多说了。</p>
<p>在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">//这里我们写一个泛型类</span></span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="string">&quot;AAA&quot;</span>) &#123;   <span class="comment">//在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢</span></span><br><span class="line">      <span class="comment">//在Java 9之后，这样的写法终于可以编译通过了</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。</p>
<h2 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h2><p>Java 10主要带来的是一些内部更新，相比Java 9带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了。</p>
<h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>在Java中，我们可以使用自动类型推断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   之前我们定义变量必须指定类型</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在我们使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是注意，<code>var</code>关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe3mpaw5j210u054jrw.jpg" alt="image-20220529171216795"></p>
<p>我们来看看是不是类型也能正常获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(a.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然是有了var关键字进行自动类型推断，但是最终还是会变成String类型，得到的Class也是String类型。但是Java终究不像JS那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pdwq4g2aj218e0b4jsh.jpg" alt="image-20220529170538383"></p>
<p>并且<code>var</code>关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe66iavlj216y0963z1.jpg" alt="image-20220529171444062"></p>
<p>有关Java 10新增的一些其他改进，这里就不提了。</p>
<h2 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h2><p>Java 11 是继Java 8之后的又一个TLS长期维护版本，在Java 17出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于Lambda的形参局部变量语法。</p>
<h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 10我们认识了<code>var</code>关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在lambda中使用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppu61uu4j211w05m3z0.jpg" alt="image-20220529235822891"></p>
<p>但是实际上这里是完全可以进行类型推断的，所以在Java 11，终于是支持了，这样编写就不会报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppvf70n0j213g05m3yu.jpg" alt="image-20220529235935071"></p>
<h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;AB\nC\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str</span><br><span class="line">            .lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>repeat()</code>方法来让字符串重复拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;ABCD&quot;</span>;   <span class="comment">//比如现在我们有一个ABCD，但是现在我们想要一个ABCDABCD这样的基于原本字符串的重复字符串</span></span><br><span class="line">    System.out.println(str.repeat(<span class="number">2</span>));  <span class="comment">//一个repeat就搞定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以快速地进行空格去除操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全新的HttpClient使用"><a href="#全新的HttpClient使用" class="headerlink" title="全新的HttpClient使用"></a>全新的HttpClient使用</h3><p>在Java 9的时候其实就已经引入了全新的Http Client API，用于取代之前比较老旧的HttpURLConnection类，新的API支持最新的HTTP2和WebSocket协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();   <span class="comment">//直接创建一个新的HttpClient</span></span><br><span class="line">  	<span class="comment">//现在我们只需要构造一个Http请求实体，就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似）</span></span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://www.baidu.com&quot;</span>)).build();</span><br><span class="line">  	<span class="comment">//现在我们就可以把请求发送出去了，注意send方法后面还需要一个响应体处理器（内置了很多）这里我们选择ofString直接吧响应实体转换为String字符串</span></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">  	<span class="comment">//来看看响应实体是什么吧</span></span><br><span class="line">    System.out.println(response.body());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用全新的客户端，我们甚至可以轻松地做一个爬虫（仅供学习使用，别去做违法的事情，爬虫玩得好，牢饭吃到饱），比如现在我们想去批量下载某个网站的壁纸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9pg4bvdj22920jcq83.jpg" alt="image-20220530112549225"></p>
<p>网站地址：<a href="https://pic.netbian.com/4kmeinv/">https://pic.netbian.com/4kmeinv/</a></p>
<p>我们随便点击一张壁纸，发现网站的URL格式为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9qp1af0j220s0loaf5.jpg" alt="image-20220530112701156"></p>
<p>并且不同的壁纸似乎都是这样：<a href="https://pic.netbian.com/tupian/%E6%95%B0%E5%AD%97.html%EF%BC%8C%E5%A5%BD%E4%BA%86%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%95%B4%E6%B4%BB%E4%BA%86%EF%BC%9A">https://pic.netbian.com/tupian/数字.html，好了差不多可以开始整活了：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//先不要一次性获取太多，先来10个</span></span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com/tupian/&quot;</span>+(<span class="number">29327</span> + i)+<span class="string">&quot;.html&quot;</span>)).build();  <span class="comment">//这里我们按照规律，批量获取</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());  <span class="comment">//这里打印一下看看网页</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后控制台成功获取到这些图片的网站页面了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9uh6barj21k40b40w3.jpg" alt="image-20220530113039571"></p>
<p>接着我们需要来观察一下网站的HTML具体怎么写的，把图片的地址提取出来：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9vgs183j22b60esdmg.jpg" alt="image-20220530113136156"></p>
<p>好了，知道图片在哪里就好办了，直接字符串截取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        String html = response.body();</span><br><span class="line">        </span><br><span class="line">        String prefix = <span class="string">&quot;&lt;a href=\&quot;\&quot; id=\&quot;img\&quot;&gt;&lt;img src=\&quot;&quot;</span>;  <span class="comment">//先找好我们要截取的前面一段，作为前缀去匹配位置</span></span><br><span class="line">        String suffix = <span class="string">&quot;\&quot; data-pic=&quot;</span>;   <span class="comment">//再找好我们要截取的屁股后面紧接着的位置，作为后缀去匹配位置</span></span><br><span class="line">      	<span class="comment">//直接定位，然后前后截取，得到最终的图片地址</span></span><br><span class="line">        html = html.substring(html.indexOf(prefix) + prefix.length());</span><br><span class="line">        html = html.substring(<span class="number">0</span>, html.indexOf(suffix));</span><br><span class="line">        System.out.println(html);  <span class="comment">//最终的图片地址就有了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">				<span class="comment">//创建请求，把图片取到</span></span><br><span class="line">        HttpRequest imageRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com&quot;</span>+html)).build();</span><br><span class="line">      	<span class="comment">//这里以输入流的方式获取，不过貌似可以直接下载文件，各位小伙伴可以单独试试看</span></span><br><span class="line">        HttpResponse&lt;InputStream&gt; imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream());</span><br><span class="line">      	<span class="comment">//拿到输入流和文件输出流</span></span><br><span class="line">        InputStream imageInput = imageResponse.body();</span><br><span class="line">        FileOutputStream stream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;images/&quot;</span>+i+<span class="string">&quot;.jpg&quot;</span>); <span class="comment">//一会要保存的格式</span></span><br><span class="line">        <span class="keyword">try</span> (stream;imageInput)&#123;  <span class="comment">//直接把要close的变量放进来就行，简洁一些了</span></span><br><span class="line">            <span class="keyword">int</span> size;   <span class="comment">//下面具体保存过程的不用我多说了吧</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">            <span class="keyword">while</span> ((size = imageInput.read(data)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                stream.write(data, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在来看看效果吧，美女的图片已经成功保存到本地了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qacy37g6j22bs0psjwj.jpg" alt="image-20220530114824605"></p>
<p>当然，这仅仅是比较简单的爬虫，不过我们的最终目的还是希望各位能够学会使用新的HttpClient API。</p>
<h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12-16 新特性"></a>Java 12-16 新特性</h2><p>由于Java版本的更新迭代速度自Java 9开始为半年更新一次（Java 8到Java 9隔了整整三年），所以各个版本之间的更新内容比较少，剩余的6个版本，我们就多个版本放在一起进行讲解了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qawt5acvj21ci0u0tcg.jpg" alt="image-20220530120729757"></p>
<p>Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能，12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用，其实就是体验服的那种感觉。</p>
<h3 id="新的switch语法"><a href="#新的switch语法" class="headerlink" title="新的switch语法"></a>新的switch语法</h3><p>在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活，比如我们想要编写一个根据成绩得到等级的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入分数（范围 0 - 100）返回对应的等级：</span></span><br><span class="line"><span class="comment"> *      100-90：优秀</span></span><br><span class="line"><span class="comment"> *      70-80：良好</span></span><br><span class="line"><span class="comment"> *      60-70：及格</span></span><br><span class="line"><span class="comment"> *      0-60：寄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> score 分数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想要使用switch来实现这个功能（不会吧不会吧，不会有人要想半天怎么用switch实现吧），之前的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">  	String res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//不同的分数段就可以返回不同的等级了</span></span><br><span class="line">        		<span class="keyword">break</span>;   <span class="comment">//别忘了break，不然会贯穿到后面</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在我们可以使用新的特性了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了（有时候就容易忘记，这样的话就算忘记也没事了）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过最后编译出来的样子，貌似还是和之前是一样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qsvu3u7dj21zw0nawhc.jpg" alt="image-20220530222918174"></p>
<p>这种全新的switch语法称为<code>switch表达式</code>，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</span></span><br><span class="line">    <span class="keyword">case</span> ...   <span class="comment">//根据不同的分支，可以存在多个case</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;   <span class="comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//我们可以使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//... 我是其他要做的事情</span></span><br><span class="line">        yield  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (args.length) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...]:</span><br><span class="line">        yield <span class="string">&quot;AAA&quot;</span>;   <span class="comment">//传统的:写法，通过yield指定返回结果，同样不需要break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    		System.out.println(<span class="string">&quot;默认情况&quot;</span>);</span><br><span class="line">        yield <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。</p>
<p><strong>注意：</strong>switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。</p>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>如果你学习过Python，一定知道三引号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span></span><br><span class="line">multi_line =  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                nice to meet you!</span></span><br><span class="line"><span class="string">                  nice to meet you!</span></span><br><span class="line"><span class="string">                      nice to meet you!</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> multi_line</span><br></pre></td></tr></table></figure>

<p>没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtu8ym7pj218008w3z2.jpg" alt="image-20220530230225037"></p>
<p>可以看到，Java中也可以使用这样的三引号来表示字符串了，并且我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtvm8z1wj21e008kdgm.jpg" alt="image-20220530230343933"></p>
<p>仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？</p>
<p><strong>注意：</strong>文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。</p>
<h3 id="新的instanceof语法"><a href="#新的instanceof语法" class="headerlink" title="新的instanceof语法"></a>新的instanceof语法</h3><p>在Java 14，instanceof迎来了一波小更新（哈哈，这版本instanceof又加强了，版本强势语法）</p>
<p>比如我们之前要重写一个类的equals方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//首先判断是否为Student类型</span></span><br><span class="line">            Student student = (Student) obj;  <span class="comment">//如果是，那么就类型转换</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//最后比对属性是否一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qufj2gt9j21da0bowg5.jpg" alt="image-20220530232252253"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;   <span class="comment">//在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//下面直接用，是不是贼方便</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用<code>instanceof</code>判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤。</p>
<p><strong>注意：</strong>新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h3 id="空指针异常的改进"><a href="#空指针异常的改进" class="headerlink" title="空指针异常的改进"></a>空指针异常的改进</h3><p>相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = a.length() + b.length();   <span class="comment">//可能给进来的a或是b为null</span></span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为空时，就会直接：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qukskyh6j21a602mgm0.jpg" alt="image-20220530232755797"></p>
<p>但是由于我们这里a和b都调用了<code>length()</code>方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）</p>
<p>但是当我们在Java 14或更高版本运行时：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qunhkgrcj21lc042my7.jpg" alt="image-20220530233031005"></p>
<p>这里会明确指出是哪一个变量调用出现了空指针，是不是感觉特别人性化。</p>
<h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><p>继类、接口、枚举、注解之后的又一新类型来了，它的名字叫”记录”，在Java 14中首次出场，这一出场，Lombok的噩梦来了。</p>
<p>在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据，比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;   <span class="comment">//使用Lombok，一个注解就搞定了</span></span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lombok可以说是简化代码的神器了，他能在编译时自动生成getter和setter、构造方法、toString()方法等实现，在编写这些实体类时，简直不要太好用，而这一波，官方也是看不下去了，于是自己也搞了一个记录类型。</p>
<p>记录类型本质上也是一个普通的类，不过是final类型且继承自java.lang.Record抽象类的，它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，好家伙，这是要逼死Lombok啊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> </span>&#123;  <span class="comment">//直接把字段写在括号中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qve5yx6tj219u086ab5.jpg" alt="image-20220530235609885"></p>
<p>并且toString也是被重写了的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qvfdhp6oj219001s3yo.jpg" alt="image-20220530235719341"></p>
<p><code>equals()</code>方法仅做成员字段之间的值比较，也是帮助我们实现好了的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Account account0 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">Account account1 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);   <span class="comment">//两个属性都是一模一样的</span></span><br><span class="line">System.out.println(account0.equals(account1));  <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>

<p>是不是感觉这种类型就是专门为这种实体类而生的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> implements Runnable </span>&#123;  <span class="comment">//支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h2 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h2><p>Java 17作为新的LTS长期维护版本，我们来看看都更新了什么（不包含预览特性，包括switch第二次增强，哈哈，果然还是强度不够，都连续加强两个版本了）</p>
<h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>密封类型可以说是Java 17正式推出的又一重磅类型，它在Java 15首次提出并测试了两个版本。</p>
<p>在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p>
<p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;   <span class="comment">//添加final关键字后，不允许对此类继承</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。</p>
<p>但是现在我们可以使用密封类型来实现这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>密封类型有以下要求：</p>
<ul>
<li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li>
<li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li>
<li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li>
<li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li>
</ul>
<p>标准的声明格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed [<span class="keyword">abstract</span>] [<span class="class"><span class="keyword">class</span>/<span class="title">interface</span>] 类名 [<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口, ...] <span class="title">permits</span> [子类, ...]</span>&#123;</span><br><span class="line">		<span class="comment">//里面的该咋写咋写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意子类格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/sealed/non-sealed] <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line">			<span class="comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span></span><br><span class="line">  		<span class="comment">//sealed类型：同父类，需要指定由哪些类继承。</span></span><br><span class="line">  		<span class="comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在我们写了这些类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//指定B继承A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;   <span class="comment">//在子类final，彻底封死</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到其他的类无论是继承A还是继承B都无法通过编译：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5p7u49j216i05074q.jpg" alt="image-20220531090136485"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5zg837j2130050jrz.jpg" alt="image-20220531090152743"></p>
<p>但是如果此时我们主动将B设定为<code>non-sealed</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> non-sealed <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正常继承了，因为B指定了<code>non-sealed</code>主动放弃了密封特性，这样就显得非常灵活了。</p>
<p>当然我们也可以通过反射来获取类是否为密封类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());   <span class="comment">//是否为密封</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Java 9 - 17的主要新特性就讲解完毕了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jdk新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程学习</title>
    <url>/posts/3a8b.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="网络编程学习"><a href="#网络编程学习" class="headerlink" title="网络编程学习"></a>网络编程学习</h1><h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><p>在JavaSE的学习中，了解到如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。</p>
<p>NIO框架是在JDK1.4推出的，它的出现就是为了解决传统IO的不足。</p>
<p>​<span id="more"></span></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>一切的一切还要从缓冲区开始讲起，包括源码在内，其实这个不是很难，只是需要理清思路。</p>
<h3 id="Buffer类及其实现"><a href="#Buffer类及其实现" class="headerlink" title="Buffer类及其实现"></a>Buffer类及其实现</h3><p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。</p>
<p>Buffer是一个抽象类，它的核心内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这四个变量的关系: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">  	<span class="comment">// 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接缓冲区实现子类的数据内存地址（之后会讲解）</span></span><br><span class="line">    <span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure>

<p>我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了<code>boolean</code>类型之外）：</p>
<ul>
<li>IntBuffer   -   int类型的缓冲区。</li>
<li>ShortBuffer   -   short类型的缓冲区。</li>
<li>LongBuffer   -   long类型的缓冲区。</li>
<li>FloatBuffer   -   float类型的缓冲区。</li>
<li>DoubleBuffer   -   double类型的缓冲区。</li>
<li>ByteBuffer   -   byte类型的缓冲区。</li>
<li>CharBuffer   -   char类型的缓冲区。</li>
</ul>
<p>（注意我们之前在JavaSE中学习过的StringBuffer虽然也是这种命名方式，但是不属于Buffer体系，这里不会进行介绍）</p>
<p>这里我们以IntBuffer为例，我们来看看如何创建一个Buffer类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：</span></span><br><span class="line">    <span class="comment">//1. 申请一个容量为10的int缓冲区</span></span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据）</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它的内部是本质上如何进行操作的呢？我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)   <span class="comment">//如果申请的容量小于0，那还有啥意思</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(capacity, capacity);   <span class="comment">//可以看到这里会直接创建一个新的IntBuffer实现类</span></span><br><span class="line">  	<span class="comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//可以看到这个也是创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);   <span class="comment">//调用的是上面的wrap方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBuffer又是如何实现的呢，我们接着来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HeapIntBuffer(<span class="keyword">int</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);   <span class="comment">//你会发现这怎么又去调父类的构造方法了，绕来绕去</span></span><br><span class="line">  	<span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又来看看IntBuffer中的构造方法是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] hb;                  <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">             <span class="keyword">int</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);  <span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.hb = hb;    <span class="comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.offset = offset;   <span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看Buffer中的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)  <span class="comment">//容量不能小于0，小于0还玩个锤子</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="keyword">this</span>.capacity = cap;   <span class="comment">//设定缓冲区容量</span></span><br><span class="line">    limit(lim);    <span class="comment">//设定最大position位置</span></span><br><span class="line">    position(pos);   <span class="comment">//设定起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;  <span class="comment">//如果起始标记大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)  <span class="comment">//并且标记位置大于起始位置，那么就抛异常（至于为啥不能大于我们后面再说）</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;   <span class="comment">//否则设定mark位置（mark默认为-1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对源码的观察，我们大致可以得到以下结构了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kkaatg47j21kk0bgmyp.jpg" alt="image-20220424093805677"></p>
<p>现在我们来总结一下上面这些结构的各自职责划分：</p>
<ul>
<li>Buffer：缓冲区的一些基本变量定义，比如当前的位置（position）、容量 (capacity)、最大限制 (limit)、标记 (mark)等，你肯定会疑惑这些变量有啥用，别着急，这些变量会在后面的操作中用到，我们逐步讲解。</li>
<li>IntBuffer等子类：定义了存放数据的数组（只有堆缓冲区实现子类才会用到）、是否只读等，也就是说数据的存放位置、以及对于底层数组的相关操作都在这里已经定义好了，并且已经实现了Comparable接口。</li>
<li>HeapIntBuffer堆缓冲区实现子类：数据存放在堆中，实际上就是用的父类的数组在保存数据，并且将父类定义的所有底层操作全部实现了。</li>
</ul>
<p>这样，我们对于Buffer类的基本结构就有了一个大致的认识。</p>
<h3 id="缓冲区写操作"><a href="#缓冲区写操作" class="headerlink" title="缓冲区写操作"></a>缓冲区写操作</h3><p>前面我们了解了Buffer类的基本操作，现在我们来看一下如何向缓冲区中存放数据以及获取数据，数据的存放包括以下四个方法：</p>
<ul>
<li>public abstract IntBuffer put(int i);   -   在当前position位置插入数据，由具体子类实现</li>
<li>public abstract IntBuffer put(int index, int i);   -   在指定位置存放数据，也是由具体子类实现</li>
<li>public final IntBuffer put(int[] src);   -   直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</li>
<li>public IntBuffer put(int[] src, int offset, int length);   -   直接存放数组中的内容，同上，但是可以指定存放一段范围</li>
<li>public IntBuffer put(IntBuffer src);   -   直接存放另一个缓冲区中的内容</li>
</ul>
<p>我们从最简的开始看，是在当前位置插入一个数据，那么这个当前位置是怎么定义的呢，我们来看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;   <span class="comment">//这个ix和nextPutIndex()很灵性，我们来看看具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以put操作实际上是将底层数组<code>hb</code>在position位置上的数据进行设定。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knn61e76j21ra08it8y.jpg" alt="image-20220424113417640"></p>
<p>设定完成后，position自动后移：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knnkm8omj21ro08gjrs.jpg" alt="image-20220424113440765"></p>
<p>我们可以编写代码来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer</span><br><span class="line">            .put(<span class="number">1</span>)</span><br><span class="line">            .put(<span class="number">2</span>)</span><br><span class="line">            .put(<span class="number">3</span>);   <span class="comment">//我们依次存放三个数据试试看</span></span><br><span class="line">    System.out.println(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过断点调试，我们来看看实际的操作情况：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmdmh8ypj21ks0b8gmx.jpg" alt="image-20220424105031549"></p>
<p>可以看到我们不断地put操作，position会一直向后移动，当然如果超出最大长度，那么会直接抛出异常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmenwakbj21lu04kwfk.jpg" alt="image-20220424105131279"></p>
<p>接着我们来看看第二个put操作是如何进行，它能够在指定位置插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;  <span class="comment">//这里依然会使用ix，但是会检查位置是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;                       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))    <span class="comment">//插入的位置不能小于0并且不能大于等于底层数组最大长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">//没有问题就把i返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个比我们之前的要好理解一些，注意全程不会操作position的值，这里需要注意一下。</p>
<p>我们接着来看第三个put操作，它是直接在IntBuffer中实现的，是基于前两个put方法的子类实现来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);   <span class="comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//接着判断要插入的数据量在缓冲区是否容得下，装不下也不行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;   <span class="comment">//计算出最终读取位置，下面开始for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);   <span class="comment">//注意是直接从postion位置开始插入，直到指定范围结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   <span class="comment">//ojbk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);   <span class="comment">//因为不需要指定范围，所以直接0和length，然后调上面的，多捞哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="keyword">int</span> rem = limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)  <span class="comment">//让我猜猜，看不懂了是吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">  	<span class="comment">//实际上就是看给定的数组能不能截取出指定的这段数据，如果都不够了那肯定不行啊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程如下，首先来了一个数组要取一段数据全部丢进缓冲区：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knmgx4rfj21qy0j6wga.jpg" alt="image-20220424113337189"></p>
<p>在检查没有什么问题并且缓冲区有容量时，就可以开始插入了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knm0wy6bj21rq0jaac6.jpg" alt="Img"></p>
<p>最后我们通过代码来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    buffer.put(arr, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">//从下标3开始，截取4个元素</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));  <span class="comment">//array方法可以直接获取到数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knjeatbjj219y01kmx1.jpg" alt="image-20220424113040485"></p>
<p>当然我们也可以将一个缓冲区的内容保存到另一个缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(IntBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)   <span class="comment">//不会吧不会吧，不会有人保存自己吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())   <span class="comment">//如果是只读的话，那么也是不允许插入操作的（我猜你们肯定会问为啥就这里会判断只读，前面四个呢）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();  <span class="comment">//给进来的src看看容量（注意这里不remaining的结果不是剩余容量，是转换后的，之后会说）</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())    <span class="comment">//这里判断当前剩余容量是否小于src容量</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//也是从position位置开始继续写入</span></span><br><span class="line">        put(src.get());   <span class="comment">//通过get方法一个一个读取数据出来，具体过程后面讲解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果是这样的话，会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);   <span class="comment">//手动插入数据</span></span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，结果和上面的不一样，并没有成功地将数据填到下面的IntBuffer中，这是为什么呢？实际上就是因为<code>remaining()</code>的计算问题，因为这个方法是直接计算postion的位置，但是由于我们在写操作完成之后，position跑到后面去了，也就导致<code>remaining()</code>结果最后算出来为0。</p>
<p>因为这里不是写操作，是接下来需要从头开始进行读操作，所以我们得想个办法把position给退回到一开始的位置，这样才可以从头开始读取，那么怎么做呢？一般我们在写入完成后需要进行读操作时（后面都是这样，不只是这里），会使用<code>flip()</code>方法进行翻转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里，limit的作用开始慢慢体现了</span></span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，再次计算<code>remaining()</code>的结果就是我们需要读取的数量了，这也是为什么put方法中要用<code>remaining()</code>来计算的原因，我们再来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    src.flip();   <span class="comment">//我们可以通过flip来翻转缓冲区</span></span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻转之后再次进行转移，就正常了。</p>
<h3 id="缓冲区读操作"><a href="#缓冲区读操作" class="headerlink" title="缓冲区读操作"></a>缓冲区读操作</h3><p>前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：</p>
<ul>
<li><code>public abstract int get();</code>    -    直接获取当前position位置的数据，由子类实现</li>
<li><code>public abstract int get(int index); </code>  -    获取指定位置的数据，也是子类实现</li>
<li><code>public IntBuffer get(int[] dst)</code>  -   将数据读取到给定的数组中</li>
<li><code>public IntBuffer get(int[] dst, int offset, int length)</code>  -   同上，加了个范围</li>
</ul>
<p>我们还是从最简单的开始看，第一个get方法的实现在IntBuffer类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];    <span class="comment">//直接从数组中取就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// 好家伙，这不跟前面那个一模一样吗</span></span><br><span class="line">  <span class="keyword">int</span> p = position;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">  position = p + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每次读取操作之后，也会将postion+1，直到最后一个位置，如果还要继续读，那么就直接抛出异常。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kph5va26j21ry07ut94.jpg" alt="image-20220424123743020"></p>
<p>我们来看看第二个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];   <span class="comment">//这里依然是使用checkIndex来检查位置是否非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看第三个和第四个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);   <span class="comment">//跟put操作一样，也是需要检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//如果读取的长度比可以读的长度大，那肯定是不行的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;    <span class="comment">//计算出最终读取位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();   <span class="comment">//开始从position把数据读到数组中，注意是在数组的offset位置开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);   <span class="comment">//不指定范围的话，那就直接用上面的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    buffer.get(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kpw3b24fj21d601aq2t.jpg" alt="image-20220424125203822"></p>
<p>可以看到成功地将数据读取到了数组中。</p>
<p>当然如果我们需要直接获取数组，也可以使用<code>array()</code>方法来拿到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)   <span class="comment">//为空那说明底层不是数组实现的，肯定就没法转换了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)   <span class="comment">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;   <span class="comment">//直接返回hb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，既然都已经拿到了底层的<code>hb</code>了，我们来看看如果直接修改之后是不是读取到的就是我们的修改之后的结果了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span>[] arr = buffer.array();</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">99999</span>;   <span class="comment">//拿到数组对象直接改</span></span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这种方式由于是直接拿到的底层数组，所有修改会直接生效在缓冲区中。</p>
<p>当然除了常规的读取方式之外，我们也可以通过<code>mark()</code>来实现跳转读取，这里需要介绍一下几个操作：</p>
<ul>
<li><code>public final Buffer mark()</code>   -   标记当前位置</li>
<li><code>public final Buffer reset()</code>   -   让当前的position位置跳转到mark当时标记的位置</li>
</ul>
<p>我们首先来看标记方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;   <span class="comment">//直接标记到当前位置，mark变量终于派上用场了，当然这里仅仅是标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看重置方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;   <span class="comment">//存一下当前的mark位置</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)    <span class="comment">//因为mark默认是-1，要是没有进行过任何标记操作，那reset个毛</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;   <span class="comment">//直接让position变成mark位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那比如我们在读取到1号位置时进行标记：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krtfdjjxj21qw082t96.jpg" alt="image-20220424135842228"></p>
<p>接着我们使用reset方法就可以直接回退回去了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kru5ys1aj21ru096dgg.jpg" alt="image-20220424135925501"></p>
<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    buffer.get();   <span class="comment">//读取一位，那么position就变成1了</span></span><br><span class="line">    buffer.mark();   <span class="comment">//这时标记，那么mark = 1</span></span><br><span class="line">    buffer.get();   <span class="comment">//又读取一位，那么position就变成2了</span></span><br><span class="line">    buffer.reset();    <span class="comment">//直接将position = mark，也就是变回1</span></span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，读取的位置根据我们的操作进行了变化，有关缓冲区的读操作，就暂时讲到这里。</p>
<h3 id="缓冲区其他操作"><a href="#缓冲区其他操作" class="headerlink" title="缓冲区其他操作"></a>缓冲区其他操作</h3><p>前面我们大致了解了一下缓冲区的读写操作，那么我们接着来看看，除了常规的读写操作之外，还有哪些其他的操作：</p>
<ul>
<li><code>public abstract IntBuffer compact()</code>   -   压缩缓冲区，由具体实现类实现</li>
<li><code>public IntBuffer duplicate()</code>   -   复制缓冲区，会直接创建一个新的数据相同的缓冲区</li>
<li><code>public abstract IntBuffer slice()</code>   -    划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作</li>
<li><code>public final Buffer rewind()</code>  -   重绕缓冲区，其实就是把position归零，然后mark变回-1</li>
<li><code>public final Buffer clear()</code>  -   将缓冲区清空，所有的变量变回最初的状态</li>
</ul>
<p>我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = position();   <span class="comment">//获取当前位置</span></span><br><span class="line">    <span class="keyword">int</span> lim = limit();    <span class="comment">//获取当前最大position位置</span></span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);   <span class="comment">//断言表达式，position必须小于最大位置，肯定的</span></span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);  <span class="comment">//计算pos距离最大位置的长度</span></span><br><span class="line">    System.arraycopy(hb, ix(pos), hb, ix(<span class="number">0</span>), rem);   <span class="comment">//直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间</span></span><br><span class="line">    position(rem);   <span class="comment">//直接将position移动到rem位置</span></span><br><span class="line">    limit(capacity());   <span class="comment">//pos最大位置修改为最大容量</span></span><br><span class="line">    discardMark();   <span class="comment">//mark变回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在的状态是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krvhots6j21s0088aar.jpg" alt="image-20220424140040711"></p>
<p>那么我们在执行<code> compact()</code>方法之后，会进行截取，此时<code>limit - position = 6</code>，那么就会截取第<code>4、5、6、7、8、9</code>这6个数据然后丢到最前面，接着position跑到<code>7</code>表示这是下一个继续的位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krycqrmej21ri080wfb.jpg" alt="image-20220424140326373"></p>
<p>现在我们通过代码来检验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();   <span class="comment">//先正常读4个</span></span><br><span class="line">    buffer.compact();   <span class="comment">//压缩缓冲区</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;压缩之后的情况：&quot;</span>+Arrays.toString(buffer.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+buffer.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+buffer.limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后的结果没有问题：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksetaccij21b603oq35.jpg" alt="image-20220424141916082"></p>
<p>我们接着来看第二个方法，那么如果我们现在需要复制一个内容一模一样的的缓冲区，该怎么做？直接使用<code>duplicate()</code>方法就可以复制了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;   <span class="comment">//直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(hb,</span><br><span class="line">                                    <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                    <span class="keyword">this</span>.position(),</span><br><span class="line">                                    <span class="keyword">this</span>.limit(),</span><br><span class="line">                                    <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                    offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么各位猜想一下，如果通过这种方式创了一个新的IntBuffer，那么下面的例子会出现什么结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer duplicate = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    System.out.println(buffer == duplicate);</span><br><span class="line">    System.out.println(buffer.array() == duplicate.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于buffer是重新new的，所以第一个为false，而底层的数组由于在构造的时候没有进行任何的拷贝而是直接传递，因此实际上两个缓冲区的底层数组是同一个对象。所以，一个发生修改，那么另一个就跟着变了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer duplicate = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="number">0</span>, <span class="number">66666</span>);</span><br><span class="line">    System.out.println(duplicate.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们接着来看下一个方法，<code>slice()</code>方法会将缓冲区进行划分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();   <span class="comment">//获取当前position</span></span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();     <span class="comment">//获取position最大位置</span></span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);   <span class="comment">//求得剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(hb,    <span class="comment">//返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个</span></span><br><span class="line">                                    -<span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>,</span><br><span class="line">                                    rem,    <span class="comment">//新的容量变成了剩余空间的大小</span></span><br><span class="line">                                    rem,</span><br><span class="line">                                    pos + offset);   <span class="comment">//可以看到offset的地址不再是0了，而是当前的position加上原有的offset值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然现在底层依然使用的是之前的数组，但是由于设定了offset值，我们之前的操作似乎变得不太一样了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksmjx76ij21ru07u75a.jpg" alt="image-20220424142642088"></p>
<p>回顾前面我们所讲解的内容，在读取和存放时，会被<code>ix</code>方法进行调整：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//现在offset为4，那么也就是说逻辑上的i是0但是得到真实位置却是4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];   <span class="comment">//最后会经过ix方法转换为真正在数组中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，在逻辑上我们可以认为是这样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksq30gzij21pw08gt9b.jpg" alt="image-20220424143002885"></p>
<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();</span><br><span class="line">    IntBuffer slice = buffer.slice();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的情况：&quot;</span>+Arrays.toString(slice.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的偏移地址：&quot;</span>+slice.arrayOffset());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+slice.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+slice.limit());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slice.hasRemaining()) &#123;   <span class="comment">//将所有的数据全部挨着打印出来</span></span><br><span class="line">        System.out.print(slice.get()+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksqmk9smj21dw05q3yy.jpg" alt="image-20220424143036449"></p>
<p>最后两个方法就比较简单了，我们先来看<code>rewind()</code>，它相当于是对position和mark进行了一次重置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是<code>clear()</code>，它相当于是将整个缓冲区回归到最初的状态了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//同上</span></span><br><span class="line">    limit = capacity;   <span class="comment">//limit变回capacity</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，关于缓冲区的一些其他操作，我们就讲解到此。</p>
<h3 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h3><p>缓冲区之间是可以进行比较的，我们可以看到equals方法和compareTo方法都是被重写了的，我们首先来看看<code>equals</code>方法，注意，它是判断两个缓冲区剩余的内容是否一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == ob)   <span class="comment">//要是两个缓冲区是同一个对象，肯定一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> IntBuffer))  <span class="comment">//类型不是IntBuffer那也不用比了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    IntBuffer that = (IntBuffer)ob;   <span class="comment">//转换为IntBuffer</span></span><br><span class="line">    <span class="keyword">int</span> thisPos = <span class="keyword">this</span>.position();  <span class="comment">//获取当前缓冲区的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> thisLim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">int</span> thatPos = that.position();  <span class="comment">//获取另一个缓冲区的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> thatLim = that.limit();</span><br><span class="line">    <span class="keyword">int</span> thisRem = thisLim - thisPos; </span><br><span class="line">    <span class="keyword">int</span> thatRem = thatLim - thatPos;</span><br><span class="line">    <span class="keyword">if</span> (thisRem &lt; <span class="number">0</span> || thisRem != thatRem)   <span class="comment">//如果剩余容量小于0或是两个缓冲区的剩余容量不一样，也不行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">//注意比较的是剩余的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thisLim - <span class="number">1</span>, j = thatLim - <span class="number">1</span>; i &gt;= thisPos; i--, j--)  <span class="comment">//从最后一个开始倒着往回比剩余的区域</span></span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="keyword">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//只要发现不一样的就不用继续了，直接false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">//上面的比较都没问题，那么就true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们按照它的思路来验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer1 = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    IntBuffer buffer2 = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//直接比较</span></span><br><span class="line">    </span><br><span class="line">    buffer1.position(<span class="number">6</span>);</span><br><span class="line">    buffer2.position(<span class="number">6</span>);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//比较从下标6开始的剩余内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果就是我们所想的那样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktaynv7nj21kw02gglg.jpg" alt="image-20220424145009464"></p>
<p>那么我们接着来看比较，<code>compareTo</code>方法，它实际上是<code>Comparable</code>接口提供的方法，它实际上比较的也是pos开始剩余的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(IntBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisPos = <span class="keyword">this</span>.position();    <span class="comment">//获取并计算两个缓冲区的pos和remain</span></span><br><span class="line">    <span class="keyword">int</span> thisRem = <span class="keyword">this</span>.limit() - thisPos;</span><br><span class="line">    <span class="keyword">int</span> thatPos = that.position();</span><br><span class="line">    <span class="keyword">int</span> thatRem = that.limit() - thatPos;</span><br><span class="line">    <span class="keyword">int</span> length = Math.min(thisRem, thatRem);   <span class="comment">//选取一个剩余空间最小的出来</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>)   <span class="comment">//如果最小的小于0，那就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = thisPos + Math.min(thisRem, thatRem);  <span class="comment">//计算n的值当前的pos加上剩余的最小空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thisPos, j = thatPos; i &lt; n; i++, j++) &#123;  <span class="comment">//从两个缓冲区的当前位置开始，一直到n结束</span></span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));  <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;   <span class="comment">//只要出现不相同的，那么就返回比较出来的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thisRem - thatRem; <span class="comment">//如果没比出来个所以然，那么就比长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就不多做介绍了。</p>
<h3 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h3><p>接着我们来看看只读缓冲区，只读缓冲区就像其名称一样，它只能进行读操作，而不允许进行写操作。</p>
<p>那么我们怎么创建只读缓冲区呢？</p>
<ul>
<li><code>public abstract IntBuffer asReadOnlyBuffer();</code>   -   基于当前缓冲区生成一个只读的缓冲区。</li>
</ul>
<p>我们来看看此方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBufferR(hb,    <span class="comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span></span><br><span class="line">                                 <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                 <span class="keyword">this</span>.position(),</span><br><span class="line">                                 <span class="keyword">this</span>.limit(),</span><br><span class="line">                                 <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                 offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBufferR类跟我们普通的HeapIntBuffer有什么不同之处呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktrvyy39j221e0f8ac2.jpg" alt="image-20220424150625847"></p>
<p>可以看到它是继承自HeapIntBuffer的，那么我们来看看它的实现有什么不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapIntBufferR</span><span class="params">(<span class="keyword">int</span>[] buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(buf, mark, pos, lim, cap, off);</span><br><span class="line">    <span class="keyword">this</span>.isReadOnly = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在其构造方法中，除了直接调用父类的构造方法外，还会将<code>isReadOnly</code>标记修改为true，我们接着来看put操作有什么不同之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(IntBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有的put方法全部凉凉，只要调用就会直接抛出ReadOnlyBufferException异常。但是其他get方法依然没有进行重写，也就是说get操作还是可以正常使用的，但是只要是写操作就都不行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    IntBuffer readBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    System.out.println(readBuffer.isReadOnly());</span><br><span class="line">    System.out.println(readBuffer.get());</span><br><span class="line">    readBuffer.put(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktz4pkhtj21ue04oab1.jpg" alt="image-20220424151322831"></p>
<p>这就是只读状态下的缓冲区。</p>
<h3 id="ByteBuffer和CharBuffer"><a href="#ByteBuffer和CharBuffer" class="headerlink" title="ByteBuffer和CharBuffer"></a>ByteBuffer和CharBuffer</h3><p>通过前面的学习，我们基本上已经了解了缓冲区的使用，但是都是基于IntBuffer进行讲解，现在我们来看看另外两种基本类型的缓冲区ByteBuffer和CharBuffer，因为ByteBuffer底层存放的是很多单个byte字节，所以会有更多的玩法，同样CharBuffer是一系列字节，所以也有很多便捷操作。</p>
<p>我们先来看看ByteBuffer，我们可以直接点进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// Valid only for heap buffers</span></span><br><span class="line">  	....</span><br></pre></td></tr></table></figure>

<p>可以看到如果也是使用堆缓冲区子类实现，那么依然是一个<code>byte[]</code>的形式保存数据。我们来尝试使用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//除了直接丢byte进去之外，我们也可以丢其他的基本类型（注意容量消耗）</span></span><br><span class="line">    buffer.putInt(Integer.MAX_VALUE);  <span class="comment">//丢个int的最大值进去，注意一个int占4字节</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前缓冲区剩余字节数：&quot;</span>+buffer.remaining());  <span class="comment">//只剩6个字节了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们来尝试读取一下，记得先翻转</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println(buffer.get());   <span class="comment">//一共四个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kulzci1zj21cc05kaa3.jpg" alt="image-20220424153520843"></p>
<p>可以看到第一个byte为127、然后三个都是-1，我们来分析一下：</p>
<ul>
<li><code>127</code> 转换为二进制补码形式就是 <code>01111111</code>，而<code>-1</code>转换为二进制补码形式为<code>11111111</code></li>
</ul>
<p>那也就是说，第一个字节是01111111，而后续字节就是11111111，把它们拼接在一起：</p>
<ul>
<li>二进制补码表示<code>01111111 11111111 11111111 11111111</code> 转换为十进制就是<code>2147483647</code>，也就是int的最大值。</li>
</ul>
<p>那么根据我们上面的推导，各位能否计算得到下面的结果呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    buffer.flip();   <span class="comment">//翻转一下</span></span><br><span class="line">    System.out.println(buffer.getInt());  <span class="comment">//以int形式获取，那么就是一次性获取4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的计算，得到的结果就是：</p>
<ul>
<li>上面的数据以二进制补码的形式表示为：<code>00000000 00000000 00000001 11111111</code></li>
<li>将其转换为十进制那么就是：256 + 255 = 511</li>
</ul>
<p>好吧，再来个魔鬼问题，把第一个换成1呢：<code>10000000 00000000 00000001 11111111</code>，自己算。</p>
<p>我们接着来看看CharBuffer，这种缓冲区实际上也是保存一大堆char类型的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CharBuffer buffer = CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);  <span class="comment">//除了可以直接丢char之外，字符串也可以一次性丢进入</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是正是得益于char数组，它包含了很多的字符串操作，可以一次性存放一整个字符串。我们甚至还可以将其当做一个String来进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CharBuffer buffer = CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    buffer.append(<span class="string">&quot;!&quot;</span>);   <span class="comment">//可以像StringBuilder一样使用append来继续添加数据</span></span><br><span class="line">  </span><br><span class="line">  	System.out.println(<span class="string">&quot;剩余容量：&quot;</span>+buffer.remaining());  <span class="comment">//已经用了6个字符了</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;整个字符串为：&quot;</span>+buffer);   <span class="comment">//直接将内容转换为字符串</span></span><br><span class="line">    System.out.println(<span class="string">&quot;第3个字符是：&quot;</span>+buffer.charAt(<span class="number">2</span>));  <span class="comment">//直接像String一样charAt</span></span><br><span class="line"></span><br><span class="line">    buffer   <span class="comment">//也可以转换为IntStream进行操作</span></span><br><span class="line">            .chars()</span><br><span class="line">            .filter(i -&gt; i &lt; <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            .forEach(i -&gt; System.out.print((<span class="keyword">char</span>) i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了一些常规操作之外，我们还可以直接将一个字符串作为参数创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以直接使用wrap包装一个字符串，但是注意，包装出来之后是只读的</span></span><br><span class="line">    CharBuffer buffer = CharBuffer.wrap(<span class="string">&quot;收藏等于学会~&quot;</span>);</span><br><span class="line">    System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="string">&quot;111&quot;</span>);  <span class="comment">//这里尝试进行一下写操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果也是我们预料中的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kvvus5tej219a06c0u1.jpg" alt="image-20220424161925938"></p>
<p>对于这两个比较特殊的缓冲区，我们就暂时讲解到这里。</p>
<h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p><strong>注意：</strong>推荐学习完成JVM篇再来学习这一部分。</p>
<p>最后我们来看一下直接缓冲区，我们前面一直使用的都是堆缓冲区，也就是说实际上数据是保存在一个数组中的，如果你已经完成了JVM篇的学习，一定知道实际上占用的是堆内存，而我们也可以创建一个直接缓冲区，也就是申请堆外内存进行数据保存，采用操作系统本地的IO，相比堆缓冲区会快一些。</p>
<p>那么怎么使用直接缓冲区呢？我们可以通过<code>allocateDirect</code>方法来创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们申请一个直接缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">  	<span class="comment">//使用方式基本和之前是一样的</span></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">66</span>);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看这个<code>allocateDirect</code>方法是如何创建一个直接缓冲区的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法直接创建了一个新的DirectByteBuffer对象，那么这个类又是怎么进行创建的呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kw7cc7vnj223y0f80v0.jpg" alt="image-20220424163028578"></p>
<p>可以看到它并不是直接继承自ByteBuffer，而是MappedByteBuffer，并且实现了接口DirectBuffer，我们先来看看这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">address</span><span class="params">()</span></span>;   <span class="comment">//获取内存地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">attachment</span><span class="params">()</span></span>;   <span class="comment">//附加对象，这是为了保证某些情况下内存不被释放，我们后面细谈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cleaner <span class="title">cleaner</span><span class="params">()</span></span>;   <span class="comment">//内存清理类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//这三个方法目前暂时用不到，后面文件再说</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLoaded</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看DirectByteBuffer类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把Unsafe类取出来</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Bits.unsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中直接创建的内存空间地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> arrayBaseOffset = (<span class="keyword">long</span>)unsafe.arrayBaseOffset(<span class="keyword">byte</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否具有非对齐访问能力，根据CPU架构而定，intel、AMD、AppleSilicon 都是支持的</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unaligned = Bits.unaligned();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接缓冲区的内存地址，为了提升速度就放到Buffer类中去了</span></span><br><span class="line"><span class="comment">//    protected long address;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加对象，一会有大作用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object att;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();   <span class="comment">//是否直接内存分页对齐，需要额外计算</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));   <span class="comment">//计算出最终需要申请的大小</span></span><br><span class="line">  	<span class="comment">//判断堆外内存是否足够，够的话就作为保留内存</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//通过Unsafe申请内存空间，并得到内存地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">      	<span class="comment">//申请失败就取消一开始的保留内存</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//批量将申请到的这一段内存每个字节都设定为0</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//将address变量（在Buffer中定义）设定为base的地址</span></span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//创建一个针对于此缓冲区的Cleaner，由于是堆外内存，所以现在由它来进行内存清理</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在构造方法中，是直接通过Unsafe类来申请足够的堆外内存保存数据，那么当我们不使用此缓冲区时，内存会被如何清理呢？我们来看看这个Cleaner：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt;</span>&#123; <span class="comment">//继承自鬼引用，也就是说此对象会存放一个没有任何引用的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用队列，PhantomReference构造方法需要</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//执行清理的具体流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">private</span> Cleaner first = <span class="keyword">null</span>;  <span class="comment">//Cleaner双向链表，每创建一个Cleaner对象都会添加一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cleaner</span><br><span class="line">        next = <span class="keyword">null</span>,</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Cleaner <span class="title">add</span><span class="params">(Cleaner cl)</span> </span>&#123;   <span class="comment">//添加操作会让新来的变成新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl.next = first;</span><br><span class="line">            first.prev = cl;</span><br><span class="line">        &#125;</span><br><span class="line">        first = cl;</span><br><span class="line">        <span class="keyword">return</span> cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//可以看到创建鬼引用的对象就是传进的缓冲区对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cleaner</span><span class="params">(Object referent, Runnable thunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, dummyQueue);</span><br><span class="line">      	<span class="comment">//清理流程实际上是外面的Deallocator</span></span><br><span class="line">        <span class="keyword">this</span>.thunk = thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//通过此方法创建一个新的Cleaner</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object ob, Runnable thunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thunk == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> add(<span class="keyword">new</span> Cleaner(ob, thunk));   <span class="comment">//调用add方法将Cleaner添加到队列</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//清理操作</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!remove(<span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">//进行清理操作时会从双向队列中移除当前Cleaner，false说明已经移除过了，直接return</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thunk.run();   <span class="comment">//这里就是直接执行具体清理流程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们先来看看具体的清理程序在做些什么，Deallocator是在直接缓冲区中声明的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;   <span class="comment">//内存地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;    <span class="comment">//大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">//申请的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">//具体的清理操作</span></span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);   <span class="comment">//这里是直接调用了Unsafe进行内存释放操作</span></span><br><span class="line">        address = <span class="number">0</span>;   <span class="comment">//内存地址改为0，NULL</span></span><br><span class="line">        Bits.unreserveMemory(size, capacity);   <span class="comment">//取消一开始的保留内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们可以明确在清理的时候实际上也是调用Unsafe类进行内存释放操作，那么，这个清理操作具体是在什么时候进行的呢？首先我们要明确，如果是普通的堆缓冲区，由于使用的数组，那么一旦此对象没有任何引用时，就随时都会被GC给回收掉，但是现在是堆外内存，只能我们手动进行内存回收，那么当DirectByteBuffer也失去引用时，会不会触发内存回收呢？</p>
<p>答案是可以的，还记得我们刚刚看到Cleaner是PhantomReference的子类吗，而DirectByteBuffer是被鬼引用的对象，而具体的清理操作是Cleaner类的clean方法，莫非这两者有什么联系吗？</p>
<p>你别说，还真有，我们直接看到PhantomReference的父类Reference，我们会发现这样一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 预加载并初始化 InterruptedException 和 Cleaner 类</span></span><br><span class="line">        		<span class="comment">// 以避免出现在循环运行过程中时由于内存不足而无法加载</span></span><br><span class="line">            ensureClassInitialized(InterruptedException.class);</span><br><span class="line">            ensureClassInitialized(Cleaner.class);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tryHandlePending(<span class="keyword">true</span>);   <span class="comment">//这里是一个无限循环调用tryHandlePending方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* 会被GC回收的对象，也就是我们给过来被引用的对象 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;  <span class="comment">//引用队列，可以和下面的next搭配使用，形成链表</span></span><br><span class="line"><span class="comment">//Reference对象也是一个一个连起来的节点，这样才能放到ReferenceQueue中形成链表</span></span><br><span class="line"><span class="keyword">volatile</span> Reference next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即将被GC的引用链表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* 由虚拟机操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pending与discovered一起构成了一个pending单向链表，标记为static类所有，pending为链表的头节点，discovered为链表当前</span></span><br><span class="line"><span class="comment">//Reference节点指向下一个节点的引用，这个队列是由JVM构建的，当对象除了被reference引用之外没有其它强引用了，JVM就会将指向</span></span><br><span class="line"><span class="comment">//需要回收的对象的Reference对象都放入到这个队列里面，这个队列会由下面的 Reference Hander 线程来处理。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;    <span class="comment">//Reference类的静态代码块</span></span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">&quot;Reference Handler&quot;</span>);   <span class="comment">//在一开始的时候就会创建</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);   <span class="comment">//以最高优先级启动</span></span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);    <span class="comment">//此线程直接作为一个守护线程</span></span><br><span class="line">    handler.start();    <span class="comment">//也就是说在一开始的时候这个守护线程就会启动</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么也就是说Reference Handler线程是在一开始就启动了，那么我们的关注点可以放在<code>tryHandlePending</code>方法上，看看这玩意到底在做个啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;   <span class="comment">//加锁办事</span></span><br><span class="line">          	<span class="comment">//当Cleaner引用的DirectByteBuffer对象即将被回收时，pending会变成此Cleaner对象</span></span><br><span class="line">          	<span class="comment">//这里判断到pending不为null时就需要处理一下对象销毁了</span></span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// &#x27;instanceof&#x27; 有时会导致内存溢出，所以将r从链表中移除之前就进行类型判断</span></span><br><span class="line">                <span class="comment">// 如果是Cleaner类型就给到c</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将pending更新为链表下一个待回收元素</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="keyword">null</span>;   <span class="comment">//r不再引用下一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//否则就进入等待</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素是Cleaner类型，c在上面就会被赋值，这里就会执行其clean方法（破案了）</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);  <span class="comment">//这个是引用队列，实际上就是我们之前在JVM篇中讲解的入队机制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对源码的解读，我们就了解了直接缓冲区的内存加载释放整个流程。和堆缓冲区一样，当直接缓冲区没有任何强引用时，就有机会被GC正常回收掉并自动释放申请的内存。</p>
<p>我们接着来看看直接缓冲区的读写操作是如何进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));   <span class="comment">//直接通过Unsafe类读取对应地址上的byte数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);   <span class="comment">//ix现在是内存地址再加上i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无论是读取还是写入操作都是通过Unsafe类操作对应的内存地址完成的。</p>
<p>那么它的复制操作是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>,</span><br><span class="line">                                          <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                          <span class="keyword">this</span>.position(),</span><br><span class="line">                                          <span class="keyword">this</span>.limit(),</span><br><span class="line">                                          <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                          <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(DirectBuffer db,         <span class="comment">// 这里给的db是进行复制操作的DirectByteBuffer对象</span></span><br><span class="line">                           <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span><br><span class="line">                           <span class="keyword">int</span> off) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    address = db.address() + off;   <span class="comment">//直接继续使用之前申请的内存空间</span></span><br><span class="line">    cleaner = <span class="keyword">null</span>;   <span class="comment">//因为用的是之前的内存空间，已经有对应的Cleaner了，这里不需要再搞一个</span></span><br><span class="line">    att = db;   <span class="comment">//将att设定为此对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果是进行复制操作，那么会直接会继续使用执行复制操作的DirectByteBuffer申请的内存空间。不知道各位是否能够马上联想到一个问题，我们知道，如果执行复制操作的DirectByteBuffer对象失去了强引用被回收，那么就会触发Cleaner并进行内存释放，但是有个问题就是，这段内存空间可能复制出来的DirectByteBuffer对象还需要继续使用，这时肯定是不能进行回收的，所以说这里使用了att变量将之前的DirectByteBuffer对象进行引用，以防止其失去强引用被垃圾回收，所以只要不是原来的DirectByteBuffer对象和复制出来的DirectByteBuffer对象都失去强引用时，就不会导致这段内存空间被回收。</p>
<p>这样，我们之前的未解之谜为啥有个<code>att</code>也就得到答案了，有关直接缓冲区的介绍，就到这里为止。</p>
<hr>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>前面我们学习了NIO的基石——缓冲区，那么缓冲区具体用在什么地方呢，在本板块我们学习通道之后，相信各位就能知道了。那么，什么是通道呢？</p>
<p>在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。</p>
<h3 id="通道接口层次"><a href="#通道接口层次" class="headerlink" title="通道接口层次"></a>通道接口层次</h3><p>通道的根基接口是<code>Channel</code>，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通道是否处于开启状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看它的一些子接口，首先是最基本的读写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将通道中的数据读取到给定的缓冲区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//将给定缓冲区中的数据写入到通道中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了读写功能后，最后整合为了一个ByteChannel接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lphvijimj223g0lajug.jpg" alt="image-20220425092355354"></p>
<p>在ByteChannel之下，还有更多的派生接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许保留position和更改position的通道，以及对通道连接实体的相关操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeekableByteChannel</span> <span class="keyword">extends</span> <span class="title">ByteChannel</span> </span>&#123;</span><br><span class="line">   	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的position</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前的position</span></span><br><span class="line">    <span class="function">SeekableByteChannel <span class="title">position</span><span class="params">(<span class="keyword">long</span> newPosition)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此通道连接到的实体（比如文件）的当前大小</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此通道连接到的实体截断（比如文件，截断之后，文件后面一半就没了）为给定大小</span></span><br><span class="line">    <span class="function">SeekableByteChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看，除了读写之外，Channel还可以具有响应中断的能力：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterruptibleChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当其他线程调用此方法时，在此通道上处于阻塞状态的线程会直接抛出 AsynchronousCloseException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是InterruptibleChannel的抽象实现，完成了一部分功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title">Channel</span>, <span class="title">InterruptibleChannel</span> </span>&#123;</span><br><span class="line">		<span class="comment">//加锁关闭操作用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</span><br><span class="line">  	<span class="comment">//当前Channel的开启状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> open = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractInterruptibleChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭操作实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;   <span class="comment">//同时只能有一个线程进行此操作，加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!open)   <span class="comment">//如果已经关闭了，那么就不用继续了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            open = <span class="keyword">false</span>;   <span class="comment">//开启状态变成false</span></span><br><span class="line">            implCloseChannel();   <span class="comment">//开始关闭通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法由 close 方法调用，以执行关闭通道的具体操作，仅当通道尚未关闭时才调用此方法，不会多次调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始阻塞（有可能一直阻塞下去）操作之前，需要调用此方法进行标记，</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//阻塞操作结束之后，也需要需要调用此方法，为了防止异常情况导致此方法没有被调用，建议放在finally中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">				...</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而之后的一些实现类，都是基于这些接口定义的方法去进行实现的，比如FileChannel：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1muofbqbmj22520pe0yu.jpg" alt="image-20220426090845530"></p>
<p>这样，我们就大致了解了一下通道相关的接口定义，那么我来看看具体是如何如何使用的。</p>
<p>比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  	<span class="comment">//数组创建好，一会用来存放从流中读取到的数据</span></span><br><span class="line">  	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">  	<span class="comment">//直接使用输入流</span></span><br><span class="line">    InputStream in = System.in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(data)) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//将输入流中的数据一次性读取到数组中</span></span><br><span class="line">            System.out.print(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> String(data, <span class="number">0</span>, len));  <span class="comment">//读取了多少打印多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在我们使用通道之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  	<span class="comment">//缓冲区创建好，一会就靠它来传输数据</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据</span></span><br><span class="line">    ReadableByteChannel readChannel = Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//将通道中的数据写到缓冲区中，缓冲区最多一次装10个</span></span><br><span class="line">        readChannel.read(buffer);</span><br><span class="line">        <span class="comment">//写入操作结束之后，需要进行翻转，以便接下来的读取操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">//最后转换成String打印出来康康</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        <span class="comment">//回到最开始的状态</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。</p>
<h3 id="文件传输FileChannel"><a href="#文件传输FileChannel" class="headerlink" title="文件传输FileChannel"></a>文件传输FileChannel</h3><p>前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        String data = <span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>;</span><br><span class="line">        out.write(data.getBytes());   <span class="comment">//向文件的输出流中写入数据，也就是把数据写到文件中</span></span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(bytes);    <span class="comment">//从文件的输入流中读取文件的信息</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = in.getChannel();</span><br><span class="line">    <span class="comment">//创建一个容量为128的缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过输入流获取的文件通道读取是没有任何问题的，但是写入操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = in.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mx9in88jj21l403mgmo.jpg" alt="image-20220426103818019"></p>
<p>直接报错，说明只支持读取操作，那么输出流呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = out.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到能够正常进行写入，但是读取呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = out.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mxbknxa4j21gg03ijsd.jpg" alt="image-20220426104016649"></p>
<p>可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RandomAccessFile能够支持文件的随机访问，并且实现了数据流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title">DataOutput</span>, <span class="title">DataInput</span>, <span class="title">Closeable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>我们可以通过RandomAccessFile来创建通道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来测试一下它的读写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  <span class="comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span></span><br><span class="line">        FileChannel channel = f.getChannel())&#123;   <span class="comment">//通过RandomAccessFile创建一个通道</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position());  <span class="comment">//注意读取也是从现在的位置开始</span></span><br><span class="line">        channel.position(<span class="number">0</span>);  <span class="comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。</p>
<p>除了基本的读写操作，我们也可以直接对文件进行截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = f.getChannel())&#123;</span><br><span class="line">        <span class="comment">//截断文件，只留前20个字节</span></span><br><span class="line">        channel.truncate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到文件的内容直接被截断了，文件内容就只剩一半了。</p>
<p>当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        inChannel.transferTo(<span class="number">0</span>, inChannel.size(), out.getChannel());   <span class="comment">//直接将test文件通道中的数据转到test2文件的通道中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到执行后，文件的内容全部被复制到另一个文件了。</p>
<p>当然，反向操作也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        out.getChannel().transferFrom(inChannel, <span class="number">0</span>, inChannel.size());   <span class="comment">//直接将从test文件通道中传来的数据转给test2文件的通道</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意一定要是可写的，不然无法进行修改操作</span></span><br><span class="line"><span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过map方法映射文件的某一段内容，创建MappedByteBuffer对象</span></span><br><span class="line">    <span class="comment">//比如这里就是从第四个字节开始，映射10字节内容到内存中</span></span><br><span class="line">  	<span class="comment">//注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件</span></span><br><span class="line">    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容</span></span><br><span class="line">  	<span class="comment">//注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写</span></span><br><span class="line">  	<span class="comment">//注意我们只映射了10个字节，也就是写的内容不能超出10字节了</span></span><br><span class="line">    buffer.put(<span class="string">&quot;yyds&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编辑完成后，通过force方法将数据写回文件的映射区域</span></span><br><span class="line">    buffer.force();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。</p>
<h3 id="文件锁FileLock"><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h3><p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<p>那么我们来看看如何使用文件锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">//创建RandomAccessFile对象，并拿到Channel</span></span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line">  	<span class="comment">//接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里）</span></span><br><span class="line">  	<span class="comment">//加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁</span></span><br><span class="line">  	<span class="comment">//范围锁甚至可以提前加到一个还未写入的位置上</span></span><br><span class="line">    FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//操作完成之后使用release方法进行锁释放</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关共享锁和独占锁：</p>
<ul>
<li>进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。</li>
<li>进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。</li>
</ul>
<p>现在我们来启动两个进程试试看，我们需要在IDEA中配置一下两个启动项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5uyrdjij21t40hsmzt.jpg" alt="image-20220426153541728"></p>
<p>现在我们依次启动它们：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5vwim5ej21hc06ct9x.jpg" alt="image-20220426153636218"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5w43wzxj21ii06igmw.jpg" alt="image-20220426153648363"></p>
<p>可以看到确实是两个进程同一时间只能有一个进行访问，而另一个需要等待锁释放。</p>
<p>那么如果我们申请的是文件的不同部分呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中一个进程锁 0 - 5</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//另一个进程锁 6 - 11</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">6</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，两个进程这时就可以同时进行加锁操作了，因为它们锁的是不同的段落。</p>
<p>那么要是交叉呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中一个进程锁 0 - 5</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//另一个进程锁 3 - 8</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">3</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到交叉的情况下也是会出现阻塞的。</p>
<p>接着我们来看看共享锁，共享锁允许多个进程同时加锁，但是不能进行写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = f.getChannel();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line">        <span class="comment">//现在使用共享锁</span></span><br><span class="line">        FileLock lock = channel.lock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">  			<span class="comment">//进行写操作</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="keyword">new</span> Date().toString().getBytes()));</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">        <span class="comment">//操作完成之后使用release方法进行锁释放</span></span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行写操作时：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ni0yi6vcj21t008ugo8.jpg" alt="image-20220426223636761"></p>
<p>可以看到直接抛出异常，说另一个程序已锁定文件的一部分，进程无法访问（某些系统或是环境实测无效，比如UP主的arm架构MacOS就不生效，这个异常是在Windows环境下运行得到的）</p>
<p>当然，我们也可以测试一下多个进行同时加共享锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileLock lock = channel.lock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果是多个进程都能加共享锁：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niehdyqkj21eg03wgm2.jpg" alt="image-20220426224938834"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nier022vj21go03mwex.jpg" alt="image-20220426224954291"></p>
<p>当然，除了直接使用<code>lock()</code>方法进行加锁之外，我们也可以使用<code>tryLock()</code>方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileLock lock = channel.tryLock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(lock);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line"></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，两个进程都去尝试获取独占锁：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqbuoygj218w02mq39.jpg" alt="image-20220426230102206"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqlky3ij21ek04igma.jpg" alt="image-20220426230117926"></p>
<p>第一个成功加锁的进程获得了对应的锁对象，而第二个进程直接得到的是<code>null</code>。</p>
<p>到这里，有关文件锁的相关内容就差不多了。</p>
<hr>
<h2 id="多路复用网络通信"><a href="#多路复用网络通信" class="headerlink" title="多路复用网络通信"></a>多路复用网络通信</h2><p>前面我们已经介绍了NIO框架的两大核心：Buffer和Channel，我们接着来看看最后一个内容。</p>
<h3 id="传统阻塞I-O网络通信"><a href="#传统阻塞I-O网络通信" class="headerlink" title="传统阻塞I/O网络通信"></a>传统阻塞I/O网络通信</h3><p>说起网络通信，相信各位并不陌生，正是因为网络的存在我们才能走进现代化的社会，在JavaWeb阶段，我们学习了如何使用Socket建立TCP连接进行网络通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>))&#123;    <span class="comment">//将服务端创建在端口8080上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在等待客户端连接...&quot;</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="comment">//通过</span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>);</span><br><span class="line">        System.out.println(reader.readLine());</span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());</span><br><span class="line">        writer.write(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        OutputStream stream = socket.getOutputStream();</span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(stream);  <span class="comment">//通过转换流来帮助我们快速写入内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        writer.write(text+<span class="string">&#x27;\n&#x27;</span>);   <span class="comment">//因为对方是readLine()这里加个换行符</span></span><br><span class="line">        writer.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已发送：&quot;</span>+text);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+reader.readLine());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接失败！&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端断开连接！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用前面讲解的通道来进行通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的ServerSocketChannel，一会直接使用SocketChannel进行网络IO操作</span></span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open())&#123;</span><br><span class="line">        <span class="comment">//依然是将其绑定到8080端口</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//同样是调用accept()方法，阻塞等待新的连接到来</span></span><br><span class="line">        SocketChannel socket = serverChannel.accept();</span><br><span class="line">        <span class="comment">//因为是通道，两端的信息都是可以明确的，这里获取远端地址，当然也可以获取本地地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用缓冲区进行数据接收</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socket.read(buffer);   <span class="comment">//SocketChannel同时实现了读写通道接口，所以可以直接进行双向操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">        socket.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得关</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然可以通过传统的Socket进行网络通信，但是我们发现，如果要进行IO操作，我们需要单独创建一个线程来进行处理，比如现在有很多个客户端，服务端需要同时进行处理，那么如果我们要处理这些客户端的请求，那么我们就只能单独为其创建一个线程来进行处理：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odmx2b3yj21o60dcwgh.jpg" alt="image-20220427165019293"></p>
<p>虽然这样看起来比较合理，但是随着客户端数量的增加，如果要保持持续通信，那么就不能摧毁这些线程，而是需要一直保留（但是实际上很多时候只是保持连接，一直在阻塞等待客户端的读写操作，IO操作的频率很低，这样就白白占用了一条线程，很多时候都是站着茅坑不拉屎），但是我们的线程不可能无限制的进行创建，总有一天会耗尽服务端的资源，那么现在怎么办呢，关键是现在又有很多客户端源源不断地连接并进行操作，这时，我们就可以利用NIO为我们提供的多路复用编程模型。</p>
<p>我们来看看NIO为我们提供的模型：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odzw1dk3j21oi0e2goy.jpg" alt="image-20220427170247004"></p>
<p>服务端不再是一个单纯通过<code>accept()</code>方法来创建连接的机制了，而是根据客户端不同的状态，Selector会不断轮询，只有客户端在对应的状态时，比如真正开始读写操作时，才会创建线程或进行处理（这样就不会一直阻塞等待某个客户端的IO操作了），而不是创建之后需要一直保持连接，即使没有任何的读写操作。这样就不会因为占着茅坑不拉屎导致线程无限制地创建下去了。</p>
<p>通过这种方式，甚至单线程都能做到高效的复用，最典型的例子就是Redis了，因为内存的速度非常快，多线程上下文的开销就会显得有些拖后腿，还不如直接单线程简单高效，这也是为什么Redis单线程也能这么快的原因。</p>
<p>因此，我们就从NIO框架的第三个核心内容：Selector，开始讲起。</p>
<h3 id="选择器与I-O多路复用"><a href="#选择器与I-O多路复用" class="headerlink" title="选择器与I/O多路复用"></a>选择器与I/O多路复用</h3><p>前面我们大概了解了一下选择器，我们知道，选择器是当具体有某一个状态（比如读、写、请求）已经就绪时，才会进行处理，而不是让我们的程序主动地进行等待。</p>
<p>既然我们现在需要实现IO多路复用，那么我们来看看常见的IO多路复用模型，也就是Selector的实现方案，比如现在有很多个用户连接到我们的服务器：</p>
<ul>
<li><strong>select</strong>：当这些连接出现具体的某个状态时，只是知道已经就绪了，但是不知道详具体是哪一个连接已经就绪，每次调用都进行线性遍历所有连接，时间复杂度为<code>O(n)</code>，并且存在最大连接数限制。</li>
<li><strong>poll</strong>：同上，但是由于底层采用链表，所以没有最大连接数限制。</li>
<li><strong>epoll</strong>：采用事件通知方式，当某个连接就绪，能够直接进行精准通知（这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，只要就绪会会直接回调callback函数，实现精准通知，但是只有Linux支持这种方式），时间复杂度<code>O(1)</code>，Java在Linux环境下正是采用的这种模式进行实现的。</li>
</ul>
<p>好了，既然多路复用模型了解完毕了，那么我们就来看看如何让我们的网络通信实现多路复用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">         Selector selector = Selector.open())&#123;   <span class="comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将选择器注册到ServerSocketChannel中，后面是选择需要监听的时间，只有发生对应事件时才会进行选择，多个事件用 | 连接，注意，并不是所有的Channel都支持以下全部四个事件，可能只支持部分</span></span><br><span class="line">        <span class="comment">//因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_CONNECT --- 连接就绪事件，表示客户端与服务器的连接已经建立成功</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_ACCEPT --- 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_READ --- 读 就绪事件，表示通道中已经有了可读的数据，可以执行读操作了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_WRITE --- 写 就绪事件，表示已经可以向通道写数据了（这玩意比较特殊，一般情况下因为都是可以写入的，所以可能会无限循环）</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//无限循环等待新的用户网络操作</span></span><br><span class="line">            <span class="comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">//如果当前ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                    SocketChannel channel = serverChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</span></span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//这样就在连接建立时完成了注册</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;    <span class="comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    <span class="comment">//别关，说不定用户还要继续通信呢</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来编写一下客户客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9h1v29j213w06m74t.jpg" alt="image-20220504155104437"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9ms12cj217005uwet.jpg" alt="image-20220504155116276"></p>
<p>可以看到成功实现了，当然各位也可以跟自己的室友一起开客户端进行测试，现在，我们只用了一个线程，就能够同时处理多个请求，可见多路复用是多么重要。</p>
<h3 id="实现Reactor模式"><a href="#实现Reactor模式" class="headerlink" title="实现Reactor模式"></a>实现Reactor模式</h3><p>前面我们简单实现了多路复用网络通信，我们接着来了解一下Reactor模式，对我们的服务端进行优化。</p>
<p>现在我们来看看如何进行优化，我们首先抽象出两个组件，Reactor线程和Handler处理器：</p>
<ul>
<li>Reactor线程：负责响应IO事件，并分发到Handler处理器。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Handler处理器：执行非阻塞的操作。</li>
</ul>
<p>实际上我们之前编写的算是一种单线程Reactor的朴素模型（面向过程的写法），我们来看看标准的写法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wgietqmhj21fq0c6tah.jpg" alt="image-20220504163417826"></p>
<p>客户端还是按照我们上面的方式连接到Reactor，并通过选择器走到Acceptor或是Handler，Acceptor主要负责客户端连接的建立，Handler负责读写操作，代码如下，首先是Handler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是Acceptor，实际上就是把上面的业务代码搬个位置罢了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acceptor主要用于处理连接操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(ServerSocketChannel serverChannel, Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel channel = serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//这里在注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler了</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> Handler(channel));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在注册时丢了一个附加对象进去，这个附加对象会在选择器选择到此通道上时，可以通过<code>attachment()</code>方法进行获取，对于我们简化代码有大作用，一会展示，我们接着来看看Reactor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册时，将Acceptor作为附加对象存放，当选择器选择后也可以获取到</span></span><br><span class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> Acceptor(serverChannel, selector));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.dispatch(iterator.next());   <span class="comment">//通过dispatch方法进行分发</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此方法进行分发</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        Object att = key.attachment();   <span class="comment">//获取attachment，ServerSocketChannel和对应的客户端Channel都添加了的</span></span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();   <span class="comment">//由于Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span></span><br><span class="line">        &#125;   <span class="comment">//这样就实现了对应的时候调用对应的Handler或是Acceptor了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用了记得关，保持好习惯，就像看完视频要三连一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverChannel.close();</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们编写一下主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Reactor对象，启动，完事</span></span><br><span class="line">    <span class="keyword">try</span> (Reactor reactor = <span class="keyword">new</span> Reactor())&#123;</span><br><span class="line">        reactor.run();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了单线程Reactor模式，注意全程使用到的都只是一个线程，没有创建新的线程来处理任何事情。</p>
<p>但是单线程始终没办法应对大量的请求，如果请求量上去了，单线程还是很不够用，接着我们来看看多线程Reactor模式，它创建了多个线程处理，我们可以将数据读取完成之后的操作交给线程池来执行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1whmt5w1sj21fq0cmac7.jpg" alt="image-20220504171307721"></p>
<p>其实我们只需要稍微修改一下Handler就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="comment">//把线程池给安排了，10个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            POOL.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在数据读出之后，就可以将数据处理交给线程池执行。</p>
<p>但是这样感觉还是划分的不够，一个Reactor需要同时处理来自客户端的所有操作请求，显得有些乏力，那么不妨我们将Reactor做成一主多从的模式，让主Reactor只负责Accept操作，而其他的Reactor进行各自的其他操作：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg" alt="image-20220505131410997"></p>
<p>现在我们来重新设计一下我们的代码，Reactor类就作为主节点，不进行任何修改，我们来修改一下其他的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SubReactor作为从Reactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">		<span class="comment">//每个从Reactor也有一个Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubReactor[] reactors = <span class="keyword">new</span> SubReactor[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> selectedIndex = <span class="number">0</span>;  <span class="comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//在一开始的时候就让4个从Reactor跑起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reactors[i] = <span class="keyword">new</span> SubReactor();</span><br><span class="line">                POOL.submit(reactors[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//轮询获取下一个Selector（Acceptor用）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">nextSelector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Selector selector = reactors[selectedIndex].selector;</span><br><span class="line">        selectedIndex = (selectedIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        Object att = key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来修改一下Acceptor类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;   <span class="comment">//只需要一个ServerSocketChannel就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel channel = serverChannel.accept();   <span class="comment">//还是正常进行Accept操作，得到SocketChannel</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = SubReactor.nextSelector();   <span class="comment">//选取下一个从Reactor的Selector</span></span><br><span class="line">            selector.wakeup();    <span class="comment">//在注册之前唤醒一下防止卡死</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> Handler(channel));  <span class="comment">//注意现在注册的是从Reactor的Selector</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，SocketChannel相关的操作就由从Reactor进行处理了，而不是一律交给主Reactor进行操作。</p>
<p>至此，我们已经了解了NIO的三大组件：<em>Buffer、Channel、Selector</em>，有关NIO基础相关的内容，就讲解到这里。下一章我们将继续讲解基于NIO实现的高性能网络通信框架Netty。</p>
<h1 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h1><p>前面我们学习了Java为我们提供的NIO框架，提供使用NIO提供的三大组件，我们就可以编写更加高性能的客户端/服务端网络程序了，甚至还可以自行规定一种通信协议进行通信。</p>
<h2 id="NIO框架存在的问题"><a href="#NIO框架存在的问题" class="headerlink" title="NIO框架存在的问题"></a>NIO框架存在的问题</h2><p>但是之前我们在使用NIO框架的时候，还是发现了一些问题，我们先来盘点一下。</p>
<h3 id="客户端关闭导致服务端空轮询"><a href="#客户端关闭导致服务端空轮询" class="headerlink" title="客户端关闭导致服务端空轮询"></a>客户端关闭导致服务端空轮询</h3><p>可能在之前的实验中，你发现了这样一个问题：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z0omdbn1j21q60isq70.jpg" alt="image-20220506214320210"></p>
<p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的（上面的图中在空轮询两次后抛出异常了，也有可能是无限的循环下去）所以这里我们得稍微处理一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span></span><br><span class="line">    <span class="keyword">if</span>(channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">        channel.close();   <span class="comment">//直接关闭此通道</span></span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">//继续进行选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以在客户端主动断开时关闭连接了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z1qtxd9nj21cy078jrw.jpg" alt="image-20220506222006550"></p>
<p>当然，除了这种情况可能会导致空轮询之外，实际上还有一种可能，这种情况是NIO框架本身的BUG：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = selector.select();  <span class="comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br></pre></td></tr></table></figure>

<p>详细请看JDK官方BUG反馈：</p>
<ol>
<li><a href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302">JDK-6670302 : (se) NIO selector wakes up with 0 selected keys infinitely</a></li>
<li><a href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933">JDK-6403933 : (se) Selector doesn’t block on Selector.select(timeout) (lnx)</a></li>
</ol>
<p>本质原因也是因为客户端的主动断开导致：</p>
<blockquote>
<p>This is an issue with poll (and epoll) on Linux. If a file descriptor for a connected socket is polled with a request event mask of 0, and if the connection is abruptly terminated (RST) then the poll wakes up with the POLLHUP (and maybe POLLERR) bit set in the returned event set. The implication of this behaviour is that Selector will wakeup and as the interest set for the SocketChannel is 0 it means there aren’t any selected events and the select method returns 0.</p>
</blockquote>
<p>这个问题本质是与操作系统有关的，所以JDK一直都认为是操作系统的问题，不应该由自己来处理，所以这个问题在当时的好几个JDK版本都是存在的，这是一个很严重的空转问题，无限制地进行空转操作会导致CPU资源被疯狂消耗。</p>
<p>不过，这个问题，却被Netty框架巧妙解决了，我们后面再说。</p>
<h3 id="粘包-拆包问题"><a href="#粘包-拆包问题" class="headerlink" title="粘包/拆包问题"></a>粘包/拆包问题</h3><p>除了上面的问题之外，我们接着来看下一个问题。</p>
<p>我们在<code>计算机网络</code>这门课程中学习过，操作系统通过TCP协议发送数据的时候，也会先将数据存放在缓冲区中，而至于什么时候真正地发出这些数据，是由TCP协议来决定的，这是我们无法控制的事情。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2lccfu5j21ii0c60tu.jpg" alt="image-20220506224926169"></p>
<p>也就是说，比如现在我们要发送两个数据包（P1/P2），理想情况下，这两个包应该是依次到达服务端，并由服务端正确读取两次数据出来，但是由于上面的机制，可能会出现下面的情况：</p>
<ol>
<li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li>
<li>可能P1和P2的前半部分合在一起发送给了服务端（拆包现象）</li>
<li>可能P1的前半部分就被单独作为一个部分发给了服务端，后面的和P2一起发给服务端（也是拆包现象）</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2em84c6j21cm0da3z4.jpg" alt="image-20220506224258538"></p>
<p>当然，对于这种问题，也有一些比较常见的解决方案：</p>
<ol>
<li>消息定长，发送方和接收方规定固定大小的消息长度，例如每个数据包大小固定为200字节，如果不够，空位补空格，只有接收了200个字节之后，作为一个完整的数据包进行处理。</li>
<li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>\r\n</code>，这样就一定需要读取到这样的分隔符才能将前面所有的数据作为一个完整的数据包进行处理。</li>
<li>将消息分为头部和本体，在头部中保存有当前整个数据包的长度，只有在读到足够长度之后才算是读到了一个完整的数据包。</li>
</ol>
<p>这里我们就来演示一下第一种解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">         Selector selector = Selector.open())&#123;</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个数据包要求必须塞满30个字节</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">if</span>(buffer.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    channel.write(ByteBuffer.wrap((<span class="string">&quot;已收到 &quot;</span>+size+<span class="string">&quot; 字节的数据！&quot;</span>).getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">               	...</span><br></pre></td></tr></table></figure>

<p>现在，当我们的客户端发送消息时，如果没有达到30个字节，那么会暂时存储起来，等有30个之后再一次性得到，当然如果数据量超过了30，那么最多也只会读取30个字节，其他的放在下一批：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmuamek3j21ou0hmdiq.jpg" alt="image-20220507102955570"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmugj9ztj21l005qt9d.jpg" alt="image-20220507103009255"></p>
<p>这样就可以在一定程度上解决粘包/拆包问题了。</p>
<hr>
<h2 id="走进Netty框架"><a href="#走进Netty框架" class="headerlink" title="走进Netty框架"></a>走进Netty框架</h2><p>前面我们盘点了一下NIO存在的一些问题，而在Netty框架中，这些问题都被巧妙的解决了。</p>
<p>Netty是由JBOSS提供的一个开源的java网络编程框架，主要是对java的nio包进行了再次封装。Netty比java原生的nio包提供了更加强大、稳定的功能和易于使用的api。 netty的作者是Trustin Lee，这是一个韩国人，他还开发了另外一个著名的网络编程框架，mina。二者在很多方面都十分相似，它们的线程模型也是基本一致 。不过netty社区的活跃程度要mina高得多。</p>
<p>Netty实际上应用场景非常多，比如我们的Minecraft游戏服务器：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1znqwr5lqj21wa0pak1k.jpg" alt="image-20220507110120090"></p>
<p>Java版本的Minecraft服务器就是使用Netty框架作为网络通信的基础，正是得益于Netty框架的高性能，我们才能愉快地和其他的小伙伴一起在服务器里面炸服。</p>
<p>学习了Netty框架后，说不定你也可以摸索到部分Minecraft插件/模组开发的底层细节（太折磨了，UP主高中搞了大半年这玩意）</p>
<p>当然除了游戏服务器之外，我们微服务之间的远程调用也可以使用Netty来完成，比如Dubbo的RPC框架，包括最新的SpringWebFlux框架，也抛弃了内嵌Tomcat而使用Netty作为通信框架。既然Netty这么强大，那么现在我们就开始Netty的学习吧！</p>
<p>导包先：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.76.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h3><p>Netty并没有使用NIO中提供的ByteBuffer来进行数据装载，而是自行定义了一个ByteBuf类。</p>
<p>那么这个类相比NIO中的ByteBuffer有什么不同之处呢？</p>
<ul>
<li>写操作完成后无需进行<code>flip()</code>翻转。</li>
<li>具有比ByteBuffer更快的响应速度。</li>
<li>动态扩容。</li>
</ul>
<p>首先我们来看看它的内部结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title">ByteBuf</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> readerIndex;   <span class="comment">//index被分为了读和写，是两个指针在同时工作</span></span><br><span class="line">    <span class="keyword">int</span> writerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;    <span class="comment">//mark操作也分两种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;    <span class="comment">//最大容量，没错，这玩意能动态扩容</span></span><br></pre></td></tr></table></figure>

<p>可以看到，读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writerIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBuffer那样还需要进行翻转了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zwgc0v5ej21fe08m3z1.jpg" alt="image-20220507160235552"></p>
<p>其中<code>readerIndex</code>和<code>writerIndex</code>之间的部分就是是可读的内容，而<code>writerIndex</code>之后到<code>capacity</code>都是可写的部分。</p>
<p>我们来实际使用一下看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个初始容量为10的ByteBuf缓冲区，这里的Unpooled是用于快速生成ByteBuf的工具类</span></span><br><span class="line">    <span class="comment">//至于为啥叫Unpooled是池化的意思，ByteBuf有池化和非池化两种，区别在于对内存的复用，我们之后再讨论</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.writeInt(-<span class="number">888888888</span>);   <span class="comment">//写入一个Int数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入Int后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.readShort();   <span class="comment">//无需翻转，直接读取一个short数据出来</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取Short后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.discardReadBytes();   <span class="comment">//丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span></span><br><span class="line">    System.out.println(<span class="string">&quot;丢弃之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.clear();    <span class="comment">//清空操作，清空之后读写指针都归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;清空之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结合断点调试，我们可以观察读写指针的移动情况，更加清楚的认识一下ByteBuf的底层操作。</p>
<p>我们再来看看划分操作是不是和之前一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//我们也可以将一个byte[]直接包装进缓冲区（和NIO是一样的）不过写指针的值一开始就跑到最后去了，但是这玩意是不是只读的</span></span><br><span class="line">    ByteBuf buf = Unpooled.wrappedBuffer(<span class="string">&quot;abcdefg&quot;</span>.getBytes());</span><br><span class="line">  	<span class="comment">//除了包装，也可以复制数据，copiedBuffer()会完完整整将数据拷贝到一个新的缓冲区中</span></span><br><span class="line">    buf.readByte();   <span class="comment">//读取一个字节</span></span><br><span class="line">    ByteBuf slice = buf.slice();   <span class="comment">//现在读指针位于1，然后进行划分</span></span><br><span class="line"></span><br><span class="line">    System.out.println(slice.arrayOffset());   <span class="comment">//得到划分出来的ByteBuf的偏移地址</span></span><br><span class="line">    System.out.println(Arrays.toString(slice.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，划分也是根据当前读取的位置来进行的。</p>
<p>我们继续来看看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>);    <span class="comment">//容量只有10字节</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">  	<span class="comment">//直接写一个字符串</span></span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);   <span class="comment">//很明显这么多字已经超过10字节了</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们发现，在写入一个超出当前容量的数据时，会进行动态扩容，扩容会从64开始，之后每次触发扩容都会x2，当然如果我们不希望它扩容，可以指定最大容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在生成时指定maxCapacity也为10</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到现在无法再动态扩容了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxvmzz7hj224806sq64.jpg" alt="image-20220507165153381"></p>
<p>我们接着来看一下缓冲区的三种实现模式：堆缓冲区模式、直接缓冲区模式、复合缓冲区模式。</p>
<p>堆缓冲区（数组实现）和直接缓冲区（堆外内存实现）不用多说，前面我们在NIO中已经了解过了，我们要创建一个直接缓冲区也很简单，直接调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.directBuffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的不能直接拿到数组，因为底层压根不是数组实现的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxbvl2y3j21h803st9z.jpg" alt="image-20220507163253662"></p>
<p>我们来看看复合模式，复合模式可以任意地拼凑组合其他缓冲区，比如我们可以：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zygujz9sj21no0c0abg.jpg" alt="image-20220507171216323"></p>
<p>这样，如果我们想要对两个缓冲区组合的内容进行操作，我们就不用再单独创建一个新的缓冲区了，而是直接将其进行拼接操作，相当于是作为多个缓冲区组合的视图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个复合缓冲区</span></span><br><span class="line">CompositeByteBuf buf = Unpooled.compositeBuffer();</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buf.getByte(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们也可以正常操作组合后的缓冲区。</p>
<p>最后我们来看看，池化缓冲区和非池化缓冲区的区别。</p>
<p>我们研究一下Unpooled工具类中具体是如何创建buffer的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unpooled</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;  <span class="comment">//实际上内部是有一个ByteBufAllocator对象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer();   <span class="comment">//缓冲区的创建操作实际上是依靠ByteBufAllocator来进行的</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span></span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;</span><br><span class="line">        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">        EMPTY_BUFFER = ALLOC.buffer(<span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//空缓冲区容量和最大容量都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> EMPTY_BUFFER <span class="keyword">instanceof</span> EmptyByteBuf : <span class="string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们来看看，这个ByteBufAllocator又是个啥，顾名思义，其实就是负责分配缓冲区的。</p>
<p>它有两个具体实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>，一个是非池化缓冲区生成器，还有一个是池化缓冲区生成器，那么池化和非池化有啥区别呢？</p>
<p>实际上池化缓冲区利用了池化思想，将缓冲区通过设置内存池来进行内存块复用，这样就不用频繁地进行内存的申请，尤其是在使用堆外内存的时候，避免多次重复通过底层<code>malloc()</code>函数系统调用申请内存造成的性能损失。Netty的内存管理机制主要是借鉴Jemalloc内存分配策略，感兴趣的小伙伴可以深入了解一下。</p>
<p>所以，由于是复用内存空间，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">    ByteBuf buf = allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//申请一个容量为10的直接缓冲区</span></span><br><span class="line">    buf.writeChar(<span class="string">&#x27;T&#x27;</span>);    <span class="comment">//随便操作操作</span></span><br><span class="line">    System.out.println(buf.readChar());</span><br><span class="line">    buf.release();    <span class="comment">//释放此缓冲区</span></span><br><span class="line"></span><br><span class="line">    ByteBuf buf2 = allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//重新再申请一个同样大小的直接缓冲区</span></span><br><span class="line">    System.out.println(buf2 == buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在我们使用完一个缓冲区之后，我们将其进行资源释放，当我们再次申请一个同样大小的缓冲区时，会直接得到之前已经申请好的缓冲区，所以，PooledByteBufAllocator实际上是将ByteBuf实例放入池中在进行复用。</p>
<h3 id="零拷贝简介"><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h3><p><strong>注意：</strong>此小节作为选学内容，需要掌握<code>操作系统</code>和<code>计算机组成原理</code>才能学习。</p>
<p>零拷贝是一种I/O操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，首先第一个问题，什么是内核空间，什么又是用户空间呢？</p>
<p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25i6lqr4hj21l80gct9n.jpg" alt="image-20220512122211805"></p>
<p>比如我们Java中创建一个新的线程，实际上最终是要交给操作系统来为我们进行分配的，而需要操作系统帮助我们完成任务则需要进行系统调用，是内核在进行处理，不是我们自己的程序在处理，这时就相当于我们的程序处于了内核态，而当操作系统底层分配完成，最后到我们Java代码中返回得到线程对象时，又继续由我们的程序进行操作，所以从内核态转换回了用户态。</p>
<p>而我们的文件操作也是这样，我们实际上也是需要让操作系统帮助我们从磁盘上读取文件数据或是向网络发送数据，比如使用传统IO的情况下，我们要从磁盘上读取文件然后发送到网络上，就会经历以下流程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25ify7168j21s60i4n0f.jpg" alt="image-20220512123113806"></p>
<p>可以看到整个过程中是经历了2次CPU拷贝+2次DMA拷贝，一共四次拷贝，虽然逻辑比较清晰，但是数据老是这样来回进行复制，是不是太浪费时间了点？所以我们就需要寻找一种更好的方式，来实现零拷贝。</p>
<p>实现零拷贝我们这里演示三种方案：</p>
<ol>
<li><p>使用虚拟内存</p>
<p>现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iui62e8j21na0i477f.jpg" alt="image-20220512124512936"></p>
</li>
<li><p>使用mmap/write内存映射</p>
<p>实际上这种方式就是将内核空间中的缓存直接映射到用户空间缓存，比如我们之前在学习NIO中使用的MappedByteBuffer，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iwxop2wj21ky0i0ad1.jpg" alt="image-20220512124732995"></p>
<p>不过这样还是会出现用户态和内核态的切换，我们得再优化优化。</p>
</li>
<li><p>使用sendfile方式</p>
<p>在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝拷贝到Socket上，直接在内核空间中一步到位：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25izbhxnrj21f60hwtb0.jpg" alt="image-20220512124950007"></p>
<p>比如我们之前在NIO中使用的<code>transferTo()</code>方法，就是利用了这种机制来实现零拷贝的。</p>
</li>
</ol>
<h3 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h3><p>前面我们了解了Netty为我们提供的更高级的缓冲区类，我们接着来看看Netty是如何工作的，上一章我们介绍了Reactor模式，而Netty正是以主从Reactor多线程模型为基础，构建出了一套高效的工作模型。</p>
<p>大致工作模型图如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h22hrmmll1j21hg0c040d.jpg" alt="image-20220509215109408"></p>
<p>可以看到，和我们之前介绍的主从Reactor多线程模型非常类似：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg" alt="image-20220505131410997"></p>
<p>所有的客户端需要连接到主Reactor完成Accept操作后，其他的操作由从Reactor去完成，这里也是差不多的思想，但是它进行了一些改进，我们来看一下它的设计：</p>
<ul>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接受客户端的连接, WorkerGroup专门负读写，就像我们前面说的主从Reactor一样。</li>
<li>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环机制，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听的，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop了而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorkerGroup的具体实现。</li>
<li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听。</li>
</ul>
<p>前面我们大致了解了一下Netty的工作模型，接着我们来尝试创建一个Netty服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">//当然还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层Epoll单独编写的一套本地实现，没有使用NIO那套</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务端启动引导类</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">//可链式，就很棒</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取流水线，当我们需要处理客户端的数据时，实际上是像流水线一样在处理，这个流水线上可以有很多Handler</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//添加一个Handler，这里使用ChannelInboundHandlerAdapter</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  <span class="comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span></span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//最后绑定端口，启动</span></span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面写了很多东西，但是你一定会懵逼，这些新来的东西，都是什么跟什么啊，怎么一个也没看明白？没关系，我们可以暂时先将代码写在这里，具体的各个部分，还请听后面细细道来。</p>
<p>我们接着编写一个客户端，客户端可以直接使用我们之前的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过通道正常收发数据即可，这样我们就成功搭建好了一个Netty服务器。</p>
<h3 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h3><p>在学习NIO时，我们就已经接触到Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输。</p>
<p>而在Netty中，也有对应的Channel类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">ChannelOutboundInvoker</span>, <span class="title">Comparable</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">ChannelId <span class="title">id</span><span class="params">()</span></span>;   <span class="comment">//通道ID</span></span><br><span class="line">    <span class="function">EventLoop <span class="title">eventLoop</span><span class="params">()</span></span>;   <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    <span class="function">Channel <span class="title">parent</span><span class="params">()</span></span>;   <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    <span class="function">ChannelConfig <span class="title">config</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;   <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelMetadata <span class="title">metadata</span><span class="params">()</span></span>;   <span class="comment">//通道相关信息</span></span><br><span class="line">    <span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">SocketAddress <span class="title">remoteAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">closeFuture</span><span class="params">()</span></span>;  <span class="comment">//关闭通道，但是会用到ChannelFuture，后面说</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeUnwritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeWritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Unsafe <span class="title">unsafe</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;   <span class="comment">//流水线，之后也会说</span></span><br><span class="line">    <span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;   <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    <span class="function">Channel <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Channel <span class="title">flush</span><span class="params">()</span></span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Netty中的Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p>
<ul>
<li>所有的IO操作都是异步的，并不是在当前线程同步运行，方法调用之后就直接返回了，那怎么获取操作的结果呢？还记得我们在前面JUC篇教程中学习的Future吗，没错，这里的ChannelFuture也是干这事的。</li>
</ul>
<p>我们可以来看一下Channel接口的父接口ChannelOutboundInvoker接口，这里面定义了大量的I/O操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundInvoker</span> </span>&#123;   <span class="comment">//通道出站调用（包含大量的网络出站操作，比如写）</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress var1)</span></span>;  <span class="comment">//Socket绑定、连接、断开、关闭等操作</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, SocketAddress var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span></span>;    <span class="comment">//下面这一系列还有附带ChannelPromise的，ChannelPromise我们后面再说，其实就是ChannelFuture的增强版</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, SocketAddress var2, ChannelPromise var3)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object var1)</span></span>;    <span class="comment">//可以看到这些常见的写操作，都是返回的ChannelFuture，而不是直接给结果</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">ChannelPromise <span class="title">newPromise</span><span class="params">()</span></span>;   <span class="comment">//其他的暂时不提</span></span><br><span class="line">    <span class="function">ChannelProgressivePromise <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newSucceededFuture</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newFailedFuture</span><span class="params">(Throwable var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然它还实现了AttributeMap接口，其实有点类似于Session那种感觉，我们可以添加一些属性之类的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeMap</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">Attribute&lt;T&gt; <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们了解了Netty底层的Channel之后，我们接着来看ChannelHandler，既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前Reactor模式中的Handler，全靠它来处理读写操作。</p>
<p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，我们之后会介绍ChannelPipeline。</p>
<p>比如我们上面就是使用了ChannelInboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  </span><br><span class="line">      	<span class="comment">//ctx是上下文，msg是收到的消息，以ByteBuf形式</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们先从顶层接口开始看起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当ChannelHandler被添加到流水线中时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当ChannelHandler从流水线中移除时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> 已过时那咱就不管了 */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Sharable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶层接口的定义比较简单，就只有一些流水线相关的回调方法，我们接着来看下一级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandler用于处理入站相关事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当Channel已经注册到自己的EventLoop上时调用，前面我们说了，一个Channel只会注册到一个EventLoop上，注册到EventLoop后，这样才会在发生对应事件时被通知。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//从EventLoop上取消注册时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当Channel已经处于活跃状态时被调用，此时Channel已经连接/绑定，并且已经就绪</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//跟上面相反，不再活跃了，并且不在连接它的远程节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当从Channel读取数据时被调用，可以看到数据被自动包装成了一个Object（默认是ByteBuf）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//上一个读取操作完成后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//暂时不介绍</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当Channel的可写状态发生改变时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//出现异常时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们上面用到的ChannelInboundHandlerAdapter实际上就是对这些方法实现的抽象类，相比直接用接口，我们可以只重写我们需要的方法，没有重写的方法会默认向流水线下一个ChannelHandler发送。</p>
<p>我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">        ByteBuf back = ctx.alloc().buffer();</span><br><span class="line">        back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(back);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userEventTriggered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelWritabilityChanged&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">      			<span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//将我们自定义的ChannelHandler添加到流水线</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> TestChannelHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器，让客户端来连接并发送一下数据试试看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231vpff1tj21j60900tp.jpg" alt="image-20220510092703319"></p>
<p>可以看到ChannelInboundHandler的整个生命周期，首先是Channel注册成功，然后才会变成可用状态，接着就差不多可以等待客户端来数据了，当客户端主动断开连接时，会再次触发一次<code>channelReadComplete</code>，然后不可用，最后取消注册。</p>
<p>我们来测试一下出现异常的情况呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    ByteBuf back = ctx.alloc().buffer();</span><br><span class="line">    back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    ctx.writeAndFlush(back);</span><br><span class="line">    System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是自定义异常1&quot;</span>);  <span class="comment">//弄点异常上去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是自定义异常2&quot;</span>);   <span class="comment">//弄点异常上去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到发生异常时，会接着调用<code>exceptionCaught</code>方法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2329bmho8j21g407y75e.jpg" alt="image-20220510094007913"></p>
<p>与ChannelInboundHandler对应的还有ChannelOutboundHandler用于处理出站相关的操作，这里就不进行演示了。</p>
<p>我们接着来看看ChannelPipeline，每一个Channel都对应一个ChannelPipeline（在Channel初始化时就被创建了）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hpuq1sej219i08wgms.jpg" alt="image-20220511152035030"></p>
<p>它就像是一条流水线一样，整条流水线上可能会有很多个Handler（包括入站和出站），整条流水线上的两端还有两个默认的处理器（用于一些预置操作和后续操作，比如释放资源等），我们只需要关心如何安排这些自定义的Handler即可，比如我们现在希望创建两个入站ChannelHandler，一个用于接收请求并处理，还有一个用于处理当前接收请求过程中出现的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler，注意顺序</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//第一个用于处理消息接收</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//第二个用于处理异常</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;我是异常处理：&quot;</span>+cause);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么它是如何运作的呢？实际上如果我们不在ChannelInboundHandlerAdapter中重写对应的方法，它会默认传播到流水线的下一个ChannelInboundHandlerAdapter进行处理，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);   <span class="comment">//通过ChannelHandlerContext来向下传递，ChannelHandlerContext是在Handler添加进Pipeline中时就被自动创建的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要将一个消息在两个Handler中进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);   <span class="comment">//通过ChannelHandlerContext</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看出站相关操作，我们可以使用ChannelOutboundHandlerAdapter来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;   </span><br><span class="line">              <span class="comment">//注意出栈站操作应该在入站操作的前面，当我们使用ChannelHandlerContext的write方法时，是从流水线的当前位置倒着往前找下一个ChannelOutboundHandlerAdapter，而我们之前使用的ChannelInboundHandlerAdapter是从前往后找下一个，如果我们使用的是Channel的write方法，那么会从整个流水线的最后开始倒着往前找ChannelOutboundHandlerAdapter，一定要注意顺序。</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;  <span class="comment">//当执行write操作时，会</span></span><br><span class="line">                    System.out.println(msg);   <span class="comment">//write的是啥，这里就是是啥</span></span><br><span class="line">                  	<span class="comment">//我们将其转换为ByteBuf，这样才能发送回客户端</span></span><br><span class="line">                    ctx.writeAndFlush(Unpooled.wrappedBuffer(msg.toString().getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.writeAndFlush(<span class="string">&quot;不会吧不会吧，不会还有人都看到这里了还没三连吧&quot;</span>);   <span class="comment">//这里可以write任何对象</span></span><br><span class="line">                  	<span class="comment">//ctx.channel().writeAndFlush(&quot;啊对对对&quot;); 或是通过Channel进行write也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来试试看，搞两个出站的Handler，验证一下是不是上面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.channel().writeAndFlush(<span class="string">&quot;伞兵一号卢本伟&quot;</span>);  <span class="comment">//这里我们使用channel的write</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1号出站：&quot;</span>+msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2号出站：&quot;</span>+msg);</span><br><span class="line">                    ctx.write(msg);  <span class="comment">//继续write给其他的出站Handler，不然到这里就断了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，出站操作在流水线上是反着来的，整个流水线操作大概流程如下:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2381nnw6kj21ey0bitam.jpg" alt="image-20220510130021714"></p>
<p>有关Channel及其处理相关操作，就先讲到这里。</p>
<h3 id="EventLoop和任务调度"><a href="#EventLoop和任务调度" class="headerlink" title="EventLoop和任务调度"></a>EventLoop和任务调度</h3><p>前面我们讲解了Channel，那么在EventLoop中具体是如何进行调度的呢？实际上我们之前在编写NIO的时候，就是一个while循环在源源不断地等待新的事件，而EventLoop也正是这种思想，它本质就是一个事件等待/处理线程。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2390nmv60j21es0awta1.jpg" alt="image-20220510133359757"></p>
<p>我们上面使用的就是EventLoopGroup，包含很多个EventLoop，我们每创建一个连接，就需要绑定到一个EventLoop上，之后EventLoop就会开始监听这个连接（只要连接不关闭，一直都是这个EventLoop负责此Channel），而一个EventLoop可以同时监听很多个Channel，实际上就是我们之前学习的Selector罢了。</p>
<p>当然，EventLoop并不只是用于网络操作的，我们前面所说的EventLoop其实都是NioEventLoop，它是专用于网络通信的，除了网络通信之外，我们也可以使用普通的EventLoop来处理一些其他的事件。</p>
<p>比如我们现在编写的服务端，虽然结构上和主从Reactor多线程模型差不多，但是我们发现，Handler似乎是和读写操作在一起进行的，而我们之前所说的模型中，Handler是在读写之外的单独线程中进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    Thread.sleep(<span class="number">10000</span>);   <span class="comment">//这里我们直接卡10秒假装在处理任务</span></span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果在这里卡住了，那么就没办法处理EventLoop绑定的其他Channel了，所以我们这里就创建一个普通的EventLoop来专门处理读写之外的任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    EventLoopGroup handlerGroup = <span class="keyword">new</span> DefaultEventLoopGroup();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                  	System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    handlerGroup.submit(() -&gt; &#123;   </span><br><span class="line">                                <span class="comment">//由于继承自ScheduledExecutorService，我们直接提交任务就行了，是不是感觉贼方便</span></span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以写成一条流水线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    EventLoopGroup handlerGroup = <span class="keyword">new</span> DefaultEventLoopGroup();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).addLast(handlerGroup, <span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;  <span class="comment">//在添加时，可以直接指定使用哪个EventLoopGroup</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就进一步地将EventLoop利用起来了。</p>
<p>按照前面服务端的方式，我们来把Netty版本的客户端也给写了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();   <span class="comment">//客户端也是使用Bootstrap来启动</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())   <span class="comment">//客户端就没那么麻烦了，直接一个EventLoop就行，用于处理发回来的数据</span></span><br><span class="line">            .channel(NioSocketChannel.class)   <span class="comment">//客户端肯定就是使用SocketChannel了</span></span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//这里的数据处理方式和服务端是一样的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   </span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();  <span class="comment">//连接后拿到对应的Channel对象</span></span><br><span class="line">  	<span class="comment">//注意上面连接操作是异步的，调用之后会继续往下走，下面我们就正式编写客户端的数据发送代码了</span></span><br><span class="line">    <span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;    <span class="comment">//还是和之前一样，扫了就发</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));  <span class="comment">//通过Channel对象发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23b2raotjj21a607u3zd.jpg" alt="image-20220510144513303"></p>
<h3 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h3><p>我们接着来看ChannelFuture，前面我们提到，Netty中Channel的相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果，如果需要得到结果，那么我们就必须要利用到Future。</p>
<p>我们先来看看ChannelFutuer接口怎么定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;    <span class="comment">//我们可以直接获取此任务的Channel</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;  <span class="comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;   <span class="comment">//在当前线程同步等待异步任务完成，任务失败会抛出异常</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;   <span class="comment">//同上，但是无法响应中断</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  <span class="comment">//同上，但是任务中断不会抛出异常，需要手动判断</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;    <span class="comment">//不用我说了吧？</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isVoid</span><span class="params">()</span></span>;   <span class="comment">//返回类型是否为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口是继承自Netty中的Future接口的（不是JDK的那个）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;   <span class="comment">//再往上才是JDK的Future</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;    <span class="comment">//用于判断任务是否执行成功的</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;    <span class="comment">//获取导致任务失败的异常</span></span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">getNow</span><span class="params">()</span></span>;  <span class="comment">//立即获取结果，如果还未产生结果，得到null，不过ChannelFuture定义V为Void，就算完成了获取也是null</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;    <span class="comment">//取消任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel的很多操作都是异步完成的，直接返回一个ChannelFuture，比如Channel的write操作，返回的就是一个ChannelFuture对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        ChannelFuture future = ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        System.out.println(<span class="string">&quot;任务完成状态：&quot;</span>+future.isDone());   <span class="comment">//通过ChannelFuture来获取相关信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>包括我们的服务端启动也是返回的ChannelFuture：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">								&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端的启动就比较慢了，所以在一开始直接获取状态会返回<code>false</code>，但是这个时候我们又需要等到服务端启动完成之后做一些事情，这个时候该怎么办呢？现在我们就有两种方案了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    future.sync();   <span class="comment">//让当前线程同步等待任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方案是直接让当前线程同步等待异步任务完成，我们可以使用<code>sync()</code>方法，这样当前线程会一直阻塞直到任务结束。第二种方案是添加一个监听器，等待任务完成时通知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">		<span class="comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span></span><br><span class="line">    future.addListener(f -&gt; System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括客户端的关闭，也是异步进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(text.equals(<span class="string">&quot;exit&quot;</span>)) &#123;   <span class="comment">//输入exit就退出</span></span><br><span class="line">            ChannelFuture future = channel.close();</span><br><span class="line">            future.sync();    <span class="comment">//等待Channel完全关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully();   <span class="comment">//优雅退出EventLoop，其实就是把还没发送的数据之类的事情做完，当然也可以shutdownNow立即关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看Promise接口，它支持手动设定成功和失败的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此接口也是继承自Netty中的Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V var1)</span></span>;    <span class="comment">//手动设定成功</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable var1)</span></span>;  <span class="comment">//手动设定失败</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//这些就和之前的Future是一样的了</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop());</span><br><span class="line">    System.out.println(promise.isSuccess());    <span class="comment">//在一开始肯定不是成功的</span></span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);    <span class="comment">//设定成功</span></span><br><span class="line">    System.out.println(promise.isSuccess());   <span class="comment">//再次获取，可以发现确实成功了</span></span><br><span class="line">    System.out.println(promise.get());    <span class="comment">//获取结果，就是我们刚刚给进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们可以手动指定成功状态，包括ChannelOutboundInvoker中的一些基本操作，都是支持ChannelPromise的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+text);</span><br><span class="line">        ChannelPromise promise = <span class="keyword">new</span> DefaultChannelPromise(channel);</span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()), promise);</span><br><span class="line">        promise.sync();  <span class="comment">//同步等待一下</span></span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后结果就是我们想要的了，当然我们也可以像Future那样添加监听器，当成功时自动通知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop()); </span><br><span class="line">    promise.addListener(f -&gt; System.out.println(promise.get()));   <span class="comment">//注意是在上面的DefaultEventLoop执行的</span></span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关Future和Promise就暂时讲解到这里。</p>
<h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>前面我们已经了解了Netty的大部分基础内容，我们接着来看看Netty内置的一些编码器和解码器。</p>
<p>在前面的学习中，我们的数据发送和接收都是需要以ByteBuf形式传输，但是这样是不是有点太不方便了，咱们能不能参考一下JavaWeb那种搞个Filter，在我们开始处理数据之前，过过滤一次，并在过滤的途中将数据转换成我们想要的类型，也可以将发出的数据进行转换，这就要用到编码解码器了。</p>
<p>我们先来看看最简的，字符串，如果我们要直接在客户端或是服务端处理字符串，可以直接添加一个字符串解码器到我们的流水线中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> StringDecoder())   <span class="comment">//当客户端发送来的数据只是简单的字符串转换的ByteBuf时，我们直接使用内置的StringDecoder即可转换</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//经过StringDecoder转换后，msg直接就是一个字符串，所以打印就行了</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用起来还是非常方便的，我们只需要将其添加到流水线即可，实际上器本质就是一个ChannelInboundHandlerAdapter：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24d0v15dkj21zs0k6ad5.jpg" alt="image-20220511123807650"></p>
<p>我们看到它是继承自MessageToMessageDecoder，用于将传入的Message转换为另一种类型，我们也可以自行编写一个实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们也来搞一个自定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);   <span class="comment">//解码后需要将解析后的数据丢进List中，如果丢进去多个数据，相当于数据被分成了多个，后面的Handler就需要每个都处理一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，可以看到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24db102gqj214o02qq2x.jpg" alt="image-20220511124755974"></p>
<p>当然如果我们在List里面丢很多个数据的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);</span><br><span class="line">        list.add(text+<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(text+<span class="string">&#x27;3&#x27;</span>);   <span class="comment">//一条消息被解码成三条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dcpcdxoj215e04eq2z.jpg" alt="image-20220511124933026"></p>
<p>可以看到，后面的Handler会依次对三条数据都进行处理，当然，除了MessageToMessageDecoder之外，还有其他类型的解码器，比如ByteToMessageDecoder等，这里就不一一介绍了，Netty内置了很多的解码器实现来方便我们开发，比如HTTP（下一节介绍），SMTP、MQTT等，以及我们常用的Redis、Memcached、JSON等数据包。</p>
<p>当然，有了解码器处理发来的数据，那发出去的数据肯定也是需要被处理的，所以编码器就出现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());  <span class="comment">//使用内置的StringEncoder可以直接将出站的字符串数据编码成ByteBuf</span></span><br></pre></td></tr></table></figure>

<p>和上面的StringDecoder一样，StringEncoder本质上就是一个ChannelOutboundHandlerAdapter：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24domthrqj21qe0i8mzp.jpg" alt="image-20220511130100984"></p>
<p>是不是感觉前面学习的Handler和Pipeline突然就变得有用了，直接一条线把数据处理安排得明明白白啊。</p>
<p>现在我们把客户端也改成使用编码、解码器的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioSocketChannel.class)</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> StringDecoder())  <span class="comment">//解码器安排</span></span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);  <span class="comment">//直接接收字符串</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .addLast(<span class="keyword">new</span> StringEncoder());  <span class="comment">//编码器安排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();</span><br><span class="line">    <span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(text);  <span class="comment">//直接发送字符串就行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的代码量又蹭蹭的减少了很多：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dtwy88pj214y04ojrv.jpg" alt="image-20220511130605337"></p>
<p>当然，除了编码器和解码器之外，还有编解码器。？？缝合怪？？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dxlf02nj21qu0fyn0h.jpg" alt="image-20220511130937624"></p>
<p>可以看到它是既继承了ChannelInboundHandlerAdapter也实现了ChannelOutboundHandler接口，又能处理出站也能处理入站请求，实际上就是将之前的给组合到一起了，比如我们也可以实现一个缝合在一起的StringCodec类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要指定两个泛型，第一个是入站的消息类型，还有一个是出站的消息类型，出站是String类型，我们要转成ByteBuf</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCodec</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理出站数据...&quot;</span>);</span><br><span class="line">        list.add(Unpooled.wrappedBuffer(buf.getBytes()));   <span class="comment">//同样的，添加的数量就是出站的消息数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理入站数据...&quot;</span>);</span><br><span class="line">        list.add(buf.toString(StandardCharsets.UTF_8));  <span class="comment">//和之前一样，直接一行解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上就是需要我们同时去实现编码和解码方法，继承MessageToMessageCodec类即可。</p>
<p>当然，如果整条流水线上有很多个解码器或是编码器，那么也可以多次进行编码或是解码，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是预处理编码器，就要皮这一下。&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;[已处理] &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder())    <span class="comment">//最后再转成ByteBuf</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringToStringEncoder());  <span class="comment">//先从我们自定义的开始</span></span><br></pre></td></tr></table></figure>

<p>可以看到，数据在流水线上一层一层处理最后再回到的客户端：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24ej8u6cqj219m04cq3f.jpg" alt="image-20220511133025492"></p>
<p>我们在一开始提到的粘包/拆包问题，也可以使用一个解码器解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">10</span>))  </span><br><span class="line">        <span class="comment">//第一种解决方案，使用定长数据包，每个数据包都要是指定长度</span></span><br><span class="line">  			...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, Unpooled.wrappedBuffer(<span class="string">&quot;!&quot;</span>.getBytes())))</span><br><span class="line">        <span class="comment">//第二种，就是指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span></span><br><span class="line">  			<span class="comment">//在收到分隔符之前的所有数据，都作为同一个数据包的内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment">//第三种方案，就是在头部添加长度信息，来确定当前发送的数据包具体长度是多少</span></span><br><span class="line">        <span class="comment">//offset是从哪里开始，length是长度信息占多少字节，这里是从0开始读4个字节表示数据包长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>))   <span class="comment">//客户端在发送时也需要将长度拼到前面去</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure>

<p>有关编码器和解码器的内容就先介绍到这里。</p>
<h3 id="实现HTTP协议通信"><a href="#实现HTTP协议通信" class="headerlink" title="实现HTTP协议通信"></a>实现HTTP协议通信</h3><p>前面我们介绍了Netty为我们提供的编码器和解码器，这里我们就来使用一下支持HTTP协议的编码器和解码器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  <span class="comment">//看看是个啥类型</span></span><br><span class="line">              	<span class="comment">//收到浏览器请求后，我们需要给一个响应回去</span></span><br><span class="line">                FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);  <span class="comment">//HTTP版本为1.1，状态码就OK（200）即可</span></span><br><span class="line">              	<span class="comment">//直接向响应内容中写入数据</span></span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);   <span class="comment">//发送响应</span></span><br><span class="line">                ctx.channel().close();   <span class="comment">//HTTP请求是一次性的，所以记得关闭</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());   <span class="comment">//响应记得也要编码后发送哦</span></span><br></pre></td></tr></table></figure>

<p>现在我们用浏览器访问一下我们的服务器吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24fzjztiyj22ac0k2gox.jpg" alt="image-20220511142040941"></p>
<p>可以看到浏览器成功接收到服务器响应，然后控制台打印了以下类型：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24g08odmrj21e604kmyh.jpg" alt="image-20220511142121619"></p>
<p>可以看到一次请求是一个DefaultHttpRequest+LastHttpContent$1，这里有两组是因为浏览器请求了一个地址之后紧接着请求了我们网站的favicon图标。</p>
<p>这样把数据分开处理肯定是不行的，要是直接整合成一个多好，安排：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                FullHttpRequest request = (FullHttpRequest) msg;</span><br><span class="line">                System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">                FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br></pre></td></tr></table></figure>

<p>再次访问，我们发现可以正常读取请求路径了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gcntjzbj210c02e74b.jpg" alt="image-20220511143318500"></p>
<p>我们来试试看搞个静态页面代理玩玩，拿出我们的陈年老模板：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gjzm12aj214i0k842b.jpg" alt="image-20220511144020424"></p>
<p>全部放进Resource文件夹，一会根据浏览器的请求路径，我们就可以返回对应的页面了，先安排一个解析器，用于解析路径然后将静态页面的内容返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResolver</span> </span>&#123;</span><br><span class="line">		<span class="comment">//直接单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PageResolver INSTANCE = <span class="keyword">new</span> PageResolver();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PageResolver</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageResolver <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FullHttpResponse <span class="title">resolveResource</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;/&quot;</span>))  &#123;  <span class="comment">//判断一下是不是正常的路径请求</span></span><br><span class="line">            path = path.equals(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;index.html&quot;</span> : path.substring(<span class="number">1</span>);    <span class="comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span></span><br><span class="line">            <span class="keyword">try</span>(InputStream stream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stream != <span class="keyword">null</span>) &#123;   <span class="comment">//拿到文件输入流之后，才可以返回页面</span></span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                    stream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.packet(HttpResponseStatus.OK, bytes);  <span class="comment">//数据先读出来，然后交给下面的方法打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//其他情况一律返回404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.packet(HttpResponseStatus.NOT_FOUND, <span class="string">&quot;404 Not Found!&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//包装成FullHttpResponse，把状态码和数据写进去</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FullHttpResponse <span class="title">packet</span><span class="params">(HttpResponseStatus status, <span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status);</span><br><span class="line">        response.content().writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的静态资源解析就写好了，接着：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                FullHttpRequest request = (FullHttpRequest) msg;</span><br><span class="line">              	<span class="comment">//请求进来了直接走解析</span></span><br><span class="line">                PageResolver resolver = PageResolver.getInstance();</span><br><span class="line">                ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器来试试看吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hbzfrozj21dy0u0jw2.jpg" alt="image-20220511150714100"></p>
<p>可以看到页面可以正常展示了，是不是有Tomcat哪味了。</p>
<h3 id="其他内置Handler介绍"><a href="#其他内置Handler介绍" class="headerlink" title="其他内置Handler介绍"></a>其他内置Handler介绍</h3><p>Netty也为我们内置了一些其他比较好用的Handler，比如我们要打印日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))   <span class="comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>日志级别我们选择INFO，现在我们用浏览器访问一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25j8p1xc2j22ig0sutk2.jpg" alt="image-20220512125851248"></p>
<p>可以看到每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p>
<p>我们也可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> RuleBasedIpFilter(<span class="keyword">new</span> IpFilterRule() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="string">&quot;127.0.0.1&quot;</span>);  </span><br><span class="line">              	<span class="comment">//进行匹配，返回false表示匹配失败</span></span><br><span class="line">              	<span class="comment">//如果匹配失败，那么会根据下面的类型决定该干什么，比如我们这里判断是不是本地访问的，如果是那就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> IpFilterRuleType <span class="title">ruleType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> IpFilterRuleType.REJECT;   <span class="comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>现在我们浏览器访问一下看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jjq53pvj21r40m8abh.jpg" alt="image-20220512130926968"></p>
<p>我们也可以对那些长期处于空闲的进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>))  <span class="comment">//IdleStateHandler能够侦测连接空闲状态</span></span><br><span class="line">        <span class="comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，第三个是读写操作都算，0表示禁用</span></span><br><span class="line">        <span class="comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//没想到吧，这个方法原来是在这个时候用的</span></span><br><span class="line">                <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                    IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">                    <span class="keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;好久都没写了，看视频的你真的有认真在跟着敲吗&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经很久很久没有读事件发生了，好寂寞&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们超过一段时间不发送数据时，就会这样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jteal4rj21eo07qabh.jpg" alt="image-20220512131845296"></p>
<p>通过这种机制，我们就可以直接关掉那些占着茅坑不拉屎的连接。</p>
<h3 id="启动流程源码解读"><a href="#启动流程源码解读" class="headerlink" title="启动流程源码解读"></a>启动流程源码解读</h3><p>前面我们完成了对Netty基本功能的讲解，我们最后就来看一下，Netty到底是如何启动以及进行数据处理的。</p>
<p>首先我们知道，整个服务端是在bind之后启动的，那么我们就从这里开始下手，不多BB直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(<span class="keyword">new</span> InetSocketAddress(inetPort));   <span class="comment">//转换成InetSocketAddress对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进来之后发现是调用的其他绑定方法，继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.validate();   <span class="comment">//再次验证一下，看看EventLoopGroup和Channel指定了没</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister();   <span class="comment">//上来第一句初始化然后注册</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看是怎么注册的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = <span class="keyword">this</span>.channelFactory.newChannel();    <span class="comment">//通过channelFactory创建新的Channel，实际上就是我们在一开始设定的NioServerSocketChannel</span></span><br><span class="line">        <span class="keyword">this</span>.init(channel);    <span class="comment">//接着对创建好的NioServerSocketChannel进行初始化</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel); <span class="comment">//将通道注册到bossGroup中的一个EventLoop中</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看是如何对创建好的ServerSocketChannel进行初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, <span class="keyword">this</span>.newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, <span class="keyword">this</span>.newAttributesArray());</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在流水线上添加一个Handler，在Handler初始化的时候向EventLoop中提交一个任务，将ServerBootstrapAcceptor添加到流水线上</span></span><br><span class="line">    <span class="comment">//这样我们的ServerSocketChannel在客户端连接时就能Accept了</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  	<span class="comment">//这里提交一个任务，将ServerBootstrapAcceptor添加到ServerSocketChannel的pipeline中</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下，ServerBootstrapAcceptor怎么处理的，直接看到它的<code>channelRead</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当底层NIO的ServerSocketChannel的Selector有OP_ACCEPT事件到达时，NioEventLoop会接收客户端连接，创建SocketChannel，并触发channelRead回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//此时msg就是Accept连接创建之后的Channel对象</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel)msg;</span><br><span class="line">  	<span class="comment">//这里直接将我们之前编写的childHandler添加到新创建的客户端连接的流水线中（是不是感觉突然就通了）</span></span><br><span class="line">    child.pipeline().addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">this</span>.childHandler&#125;);</span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, <span class="keyword">this</span>.childOptions, ServerBootstrap.logger);</span><br><span class="line">    AbstractBootstrap.setAttributes(child, <span class="keyword">this</span>.childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//直接向workGroup中的一个EventLoop注册新创建好的客户端连接Channel，等待读写事件</span></span><br><span class="line">        <span class="keyword">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          	<span class="comment">//异步操作完成后，如果没有注册成功，就强制关闭这个Channel</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                	...</span><br></pre></td></tr></table></figure>

<p>所以，实际上就是我们之前讲解的主从Reactor多线程模型，只要前面理解了，这里其实很好推断。</p>
<p>初始化完成之后，我们来看看注册，在之前NIO阶段我们也是需要将Channel注册到对应的Selector才可以开始选择：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));  <span class="comment">//转换成ChannelPromise继续</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);   <span class="comment">//调用Channel的Unsafe接口实现进行注册</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续向下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.register0(promise);    <span class="comment">//这里是继续调用register0方法在进行注册</span></span><br><span class="line">        &#125;</span><br><span class="line">  	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = <span class="keyword">this</span>.neverRegistered;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doRegister();    <span class="comment">//这里开始执行AbstractNioChannel中的doRegister方法进行注册</span></span><br><span class="line">      	AbstractChannel.<span class="keyword">this</span>.registered = <span class="keyword">true</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="keyword">this</span>.safeSetSuccess(promise);</span><br><span class="line">      	<span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelActive();   <span class="comment">//这里是关键</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.config().isAutoRead()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到最后一级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//可以看到在这里终于是真正的进行了注册，javaChannel()得到NIO的Channel对象，然后调用register方法</span></span><br><span class="line">          	<span class="comment">//这里就和我们之前NIO一样了，将Channel注册到Selector中，可以看到Selector也是EventLoop中的</span></span><br><span class="line">          	<span class="comment">//但是注意，这里的ops参数是0，也就是不监听任何事件</span></span><br><span class="line">            <span class="keyword">this</span>.selectionKey = <span class="keyword">this</span>.javaChannel().register(<span class="keyword">this</span>.eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到上一级，在doRegister完成之后，会拿到selectionKey，但是注意这时还没有监听任何事件，我们接着看到下面的fireChannelActive方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(<span class="keyword">this</span>.head);   <span class="comment">//传的是流水线上的默认头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();   <span class="comment">//继续向下</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler)<span class="keyword">this</span>.handler()).channelActive(<span class="keyword">this</span>);   <span class="comment">//依然是调用的头结点的channelActive方法进行处理</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeExceptionCaught(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;   <span class="comment">//这里是头结点的</span></span><br><span class="line">    ctx.fireChannelActive();    </span><br><span class="line">    <span class="keyword">this</span>.readIfIsAutoRead();   <span class="comment">//继续向下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DefaultChannelPipeline.<span class="keyword">this</span>.channel.config().isAutoRead()) &#123;</span><br><span class="line">        DefaultChannelPipeline.<span class="keyword">this</span>.channel.read();    <span class="comment">//继续不断向下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.unsafe.beginRead();   <span class="comment">//最后这里会调用beginRead方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doBeginRead();    <span class="comment">//这里就是调用AbstractNioChannel的doBeginRead方法了</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception var2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireExceptionCaught(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;    <span class="comment">//先拿到之前注册好的selectionKey</span></span><br><span class="line">    <span class="keyword">if</span> (selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> interestOps = selectionKey.interestOps();   <span class="comment">//把监听的操作取出来</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; <span class="keyword">this</span>.readInterestOp) == <span class="number">0</span>) &#123;    <span class="comment">//如果没有监听任何操作</span></span><br><span class="line">            selectionKey.interestOps(interestOps | <span class="keyword">this</span>.readInterestOp);   <span class="comment">//那就把readInterestOp事件进行监听，这里的readInterestOp实际上就是OP_ACCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，Channel在初始化完成之后也完成了底层的注册，已经可以开始等待事件了。</p>
<p>我们现在回到之前的<code>doBind</code>方法的注册位置，现在注册完成之后，基本上整个主从Reactor结构就已经出来了，我们来看看还要做些什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister();  <span class="comment">//目前初始化和注册都已经成功了</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();    <span class="comment">//由于是异步操作，我们通过ChannelFuture拿到对应的ServerSocketChannel对象</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;   <span class="comment">//如果说初始化已经完成了</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);   <span class="comment">//直接开始进行进一步的绑定</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//如果还没搞完，那就创Promis继续等待任务完成</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后都会走到<code>doBind0</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(<span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//最后会向Channel已经注册到的EventLoop中提交一个新的任务</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">              	<span class="comment">//这里才是真正调用Channel底层进行绑定操作</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，服务端的启动流程结束。我们前面还提到了NIO的空轮询问题，这里我们来看看Netty是如何解决的，我们直接定位到NioEventLoop中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于代码太多，这里省略大部分代码</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> var34;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	...</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasTasks()) &#123;</span><br><span class="line">                                strategy = <span class="keyword">this</span>.select(curDeadlineNanos);   <span class="comment">//首先会在这里进行Selector.select()操作，跟NIO是一样的</span></span><br><span class="line">                            &#125;</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">            ++selectCnt;    <span class="comment">//每次唤醒都会让selectCnt自增</span></span><br><span class="line">            <span class="keyword">this</span>.cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">          	...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ranTasks &amp;&amp; strategy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.unexpectedSelectorWakeup(selectCnt)) &#123;   <span class="comment">//这里会进行判断是否出现空轮询BUG</span></span><br><span class="line">           	...</span><br></pre></td></tr></table></figure>

<p>我们来看看是怎么进行判断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unexpectedSelectorWakeup</span><span class="params">(<span class="keyword">int</span> selectCnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Selector.select() returned prematurely because Thread.currentThread().interrupt() was called. Use NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果selectCnt大于等于SELECTOR_AUTO_REBUILD_THRESHOLD（默认为512）那么会直接重建Selector</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, <span class="keyword">this</span>.selector);</span><br><span class="line">        <span class="keyword">this</span>.rebuildSelector();   <span class="comment">//当前的Selector出现BUG了，得重建一个Selector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，当每次空轮询发生时会有专门的计数器+1，如果空轮询的次数超过了512次，就认为其触发了空轮询bug，触发bug后，Netty直接重建一个Selector，将原来的Channel重新注册到新的 Selector上，将旧的 Selector关掉，这样就防止了无限循环。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程学习</title>
    <url>/posts/1197.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="并发编程学习"><a href="#并发编程学习" class="headerlink" title="并发编程学习"></a>并发编程学习</h1><h1 id="一、认识多线程"><a href="#一、认识多线程" class="headerlink" title="一、认识多线程"></a>一、认识多线程</h1><p>在我们的操作系统之上，可以同时运行很多个进程，并且每个进程之间相互隔离互不干扰。我们的CPU会通过时间片轮转算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式来实现宏观上的多个程序同时运行。</p>
<p>由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么有没有一种更好地方案呢？</p>
<p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p>
<span id="more"></span>

<p>现在有这样一个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//请将上面的数组按升序输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照正常思维，我们肯定是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">		<span class="comment">//直接排序吧</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们学习了多线程之后，可以换个思路来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(i * <span class="number">1000</span>);   <span class="comment">//越小的数休眠时间越短，优先被打印</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接触过的很多框架都在使用多线程，比如Tomcat服务器，所有用户的请求都是通过不同的线程来进行处理的，这样我们的网站才可以同时响应多个用户的请求，要是没有多线程，可想而知服务器的处理效率会有多低。</p>
<p>虽然多线程能够为我们解决很多问题，但是，如何才能正确地使用多线程，如何才能将多线程的资源合理使用，这都是我们需要关心的问题。</p>
<p>在Java 5的时候，新增了java.util.concurrent（JUC）包，其中包括大量用于多线程编程的工具类，目的是为了更好的支持高并发任务，让开发者进行多线程编程时减少竞争条件和死锁的问题！通过使用这些工具类，我们的程序会更加合理地使用多线程。而我们这一系列视频的主角，正是<code>JUC</code>。</p>
<p>但是我们先不着急去看这些内容，第一章，我们先来补点基础知识。</p>
<hr>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>我们经常听到并发编程，那么这个并发代表的是什么意思呢？而与之相似的并行又是什么意思？它们之间有什么区别？</p>
<p>比如现在一共有三个工作需要我们去完成。</p>
<h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>顺序执行其实很好理解，就是我们依次去将这些任务完成了：</p>
<p>实际上就是我们同一时间只能处理一个任务，所以需要前一个任务完成之后，才能继续下一个任务，依次完成所有任务。</p>
<h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>并发执行也是我们同一时间只能处理一个任务，但是我们可以每个任务轮着做（时间片轮转）：</p>
<p>只要我们单次处理分配的时间足够的短，在宏观看来，就是三个任务在同时进行。</p>
<p>而我们Java中的线程，正是这种机制，当我们需要同时处理上百个上千个任务时，很明显CPU的数量是不可能赶得上我们的线程数的，所以说这时就要求我们的程序有良好的并发性能，来应对同一时间大量的任务处理。学习Java并发编程，能够让我们在以后的实际场景中，知道该如何应对高并发的情况。</p>
<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>并行执行就突破了同一时间只能处理一个任务的限制，我们同一时间可以做多个任务：</p>
<p>比如我们要进行一些排序操作，就可以用到并行计算，只需要等待所有子任务完成，最后将结果汇总即可。包括分布式计算模型MapReduce，也是采用的并行计算思路。</p>
<hr>
<h2 id="再谈锁机制"><a href="#再谈锁机制" class="headerlink" title="再谈锁机制"></a>再谈锁机制</h2><p>谈到锁机制，相信各位应该并不陌生了，我们在JavaSE阶段，通过使用<code>synchronized</code>关键字来实现锁，这样就能够很好地解决线程之间争抢资源的情况。那么，<code>synchronized</code>底层到底是如何实现的呢？</p>
<p>我们知道，使用<code>synchronized</code>，一定是和某个对象相关联的，比如我们要对某一段代码加锁，那么我们就需要提供一个对象来作为锁本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Main.class) &#123;</span><br><span class="line">        <span class="comment">//这里使用的是Main类的Class对象作为锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看，它变成字节码之后会用到哪些指令：</p>
<p>其中最关键的就是<code>monitorenter</code>指令了，可以看到之后也有<code>monitorexit</code>与之进行匹配（注意这里有2个），<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p>
<p>在代码执行完成之后，我们可以看到，一共有两个<code>monitorexit</code>在等着我们，那么为什么这里会有两个呢，按理说<code>monitorenter</code>和<code>monitorexit</code>不应该一一对应吗，这里为什么要释放锁两次呢？</p>
<p>首先我们来看第一个，这里在释放锁之后，会马上进入到一个goto指令，跳转到15行，而我们的15行对应的指令就是方法的返回指令，其实正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。而第二个，其实是用来处理异常的，可以看到，它的位置是在12行，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常，而不是直接跳转到15行正常运行下去。</p>
<p>实际上<code>synchronized</code>使用的锁就是存储在Java对象头中的，我们知道，对象是存放在堆内存中的，而每个对象内部，都有一部分空间用于存储对象头信息，而对象头信息中，则包含了Mark Word用于存放<code>hashCode</code>和对象的锁信息，在不同状态下，它存储的数据结构有一些不同。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。我们先从最原始的重量级锁开始：</p>
<p>我们说了，每个对象都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下机制：</p>
<p>ObjectWaiter首先会进入 Entry Set等着，当线程获取到对象的<code>monitor</code>后进入 The Owner 区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count</code>加1，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count</code>自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>。</p>
<p>虽然这样的设计思路非常合理，但是在大多数应用上，每一个线程占用同步代码块的时间并不是很长，我们完全没有必要将竞争中的线程挂起然后又唤醒，并且现代CPU基本都是多核心运行的，我们可以采用一种新的思路来实现锁。</p>
<p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制。</p>
<p>在JDK6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote>
<p>从JDK 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。</p>
</blockquote>
<p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗（并不是为了代替重量级锁，实际上就是赌一手同一时间只有一个线程在占用资源），包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。它不像是重量级锁那样，需要向操作系统申请互斥量。它的运作机制如下：</p>
<p>在即将开始执行同步代码块中的内容时，会首先检查对象的Mark Word，查看锁对象是否被其他线程占用，如果没有任何线程占用，那么会在当前线程中所处的栈帧中建立一个名为锁记录（Lock Record）的空间，用于复制并存储对象目前的Mark Word信息（官方称为Displaced Mark Word）。</p>
<p>接着，虚拟机将使用CAS操作将对象的Mark Word更新为轻量级锁状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）</p>
<blockquote>
<p>CAS（Compare And Swap）是一种无锁算法（我们之前在Springboot阶段已经讲解过了），它并不会为对象加锁，而是在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p>
<p>在CPU中，CAS操作使用的是<code>cmpxchg</code>指令，能够从最底层硬件层面得到效率的提升。</p>
</blockquote>
<p>如果CAS操作失败了的话，那么说明可能这时有线程已经进入这个同步代码块了，这时虚拟机会再次检查对象的Mark Word，是否指向当前线程的栈帧，如果是，说明不是其他线程，而是当前线程已经有了这个对象的锁，直接放心大胆进同步代码块即可。如果不是，那确实是被其他线程占用了。</p>
<p>这时，轻量级锁一开始的想法就是错的（这时有对象在竞争资源，已经赌输了），所以说只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p>
<p>所以，轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p>
<p>解锁过程同样采用CAS算法，如果对象的MarkWord仍然指向线程的锁记录，那么就用CAS操作把对象的MarkWord和复制到栈帧中的Displaced Mark Word进行交换。如果替换失败，说明其他线程尝试过获取该锁，在释放锁的同时，需要唤醒被挂起的线程。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁相比轻量级锁更纯粹，干脆就把整个同步都消除掉，不需要再进行CAS操作了。它的出现主要是得益于人们发现某些情况下某个锁频繁地被同一个线程获取，这种情况下，我们可以对轻量级锁进一步优化。</p>
<p>偏向锁实际上就是专门为单个线程而生的，当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作。</p>
<p>可以从之前的MarkWord结构中看到，偏向锁也会通过CAS操作记录线程的ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的CAS操作。当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到未锁定或是膨胀为轻量级锁。</p>
<p>如果我们需要使用偏向锁，可以添加<code>-XX:+UseBiased</code>参数来开启。</p>
<p>所以，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p>
<p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p>
<h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>锁消除和锁粗化都是在运行时的一些优化方案，比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。锁粗化则是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p>
<hr>
<h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p>注意这里提到的内存模型和我们在JVM中介绍的内存模型不在同一个层次，JVM中的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型，是在JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型实现的，我们会在后面介绍。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>我们在<code>计算机组成原理</code>中学习过，在我们的CPU中，一般都会有高速缓存，而它的出现，是为了解决内存的速度跟不上处理器的处理速度的问题，所以CPU内部会添加一级或多级高速缓存来提高处理器的数据获取效率，但是这样也会导致一个很明显的问题，因为现在基本都是多核心处理器，每个处理器都有一个自己的高速缓存，那么又该怎么去保证每个处理器的高速缓存内容一致呢？</p>
<p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p>而Java也采用了类似的模型来实现支持多线程的内存模型：</p>
<p>JMM（Java Memory Model）内存模型规定如下：</p>
<ul>
<li>所有的变量全部存储在主内存（注意这里包括下面提到的变量，指的都是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li>
<li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据。</li>
<li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存。</li>
</ul>
<p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p>
<p>那么各位肯定会好奇，这个内存模型，结合之前JVM所讲的内容，具体是怎么实现的呢？</p>
<ul>
<li>主内存：对应堆中存放对象的实例的部分。</li>
<li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中。</li>
</ul>
<p>前面我们提到，在CPU中可能会遇到缓存不一致的问题，而Java中，也会遇到，比如下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) i++;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) i++;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//等上面两个线程结束</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里是两个线程同时对变量<code>i</code>各自进行100000次自增操作，但是实际得到的结果并不是我们所期望的那样。</p>
<p>那么为什么会这样呢？在之前学习了JVM之后，相信各位应该已经知道，自增操作实际上并不是由一条指令完成的（注意一定不要理解为一行代码就是一个指令完成的）：</p>
<p>包括变量<code>i</code>的获取、修改、保存，都是被拆分为一个一个的操作完成的，那么这个时候就有可能出现在修改完保存之前，另一条线程也保存了，但是当前线程是毫不知情的。</p>
<p>所以说，我们当时在JavaSE阶段讲解这个问题的时候，是通过<code>synchronized</code>关键字添加同步代码块解决的，当然，我们后面还会讲解另外的解决方案（原子类）</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p>
<ol>
<li>编译器重排序：Java编译器通过对Java代码语义的理解，根据优化规则对代码指令进行重排序。</li>
<li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序。</li>
</ol>
<p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们其实可以交换第一行和第二行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使发生交换，但是我们程序最后的运行结果是不会变的，当然这里只通过代码的形式演示，实际上JVM在执行字节码指令时也会进行优化，可能两个指令并不会按照原有的顺序进行。</p>
<p>虽然单线程下指令重排确实可以起到一定程度的优化作用，但是在多线程下，似乎会导致一些问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，在正常情况下，按照我们的正常思维，是不可能输出<code>A</code>的，因为只要b等于1，那么a肯定也是1才对，因为a是在b之前完成的赋值。但是，如果进行了重排序，那么就有可能，a和b的赋值发生交换，b先被赋值为1，而恰巧这个时候，线程1开始判定b是不是1了，这时a还没来得及被赋值为1，可能线程1就已经走到打印那里去了，所以，是有可能输出<code>A</code>的。</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>好久好久都没有认识新的关键字了，今天我们来看一个新的关键字<code>volatile</code>，开始之前我们先介绍三个词语：</p>
<ul>
<li>原子性：其实之前讲过很多次了，就是要做什么事情要么做完，要么就不做，不存在做一半的情况。</li>
<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p>我们之前说了，如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作，下面这个操作看起来是一个有限循环，但是是无限的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;   <span class="comment">//很明显，按照我们的逻辑来说，a的值被修改那么另一个线程将不再循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这就是我们之前说的，虽然我们主线程中修改了a的值，但是另一个线程并不知道a的值发生了改变，所以循环中依然是使用旧值在进行判断，因此，普通变量是不具有可见性的。</p>
<p>要解决这种问题，我们第一个想到的肯定是加锁，同一时间只能有一个线程使用，这样总行了吧，确实，这样的话肯定是可以解决问题的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main.class)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Main.class)&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，除了硬加一把锁的方案，我们也可以使用<code>volatile</code>关键字来解决，此关键字的第一个作用，就是保证变量的可见性。当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写会操作会导致其他线程中的<code>volatile</code>变量缓存无效，这样，另一个线程修改了这个变时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p>
<p>那么我们就来试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果还真的如我们所说的那样，当a发生改变时，循环立即结束。</p>
<p>当然，虽然说<code>volatile</code>能够保证可见性，但是不能保证原子性，要解决我们上面的<code>i++</code>的问题，以我们目前所学的知识，还是只能使用加锁来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) a++;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务完成！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待线程执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不对啊，<code>volatile</code>不是能在改变变量的时候其他线程可见吗，那为什么还是不能保证原子性呢？还是那句话，自增操作是被瓜分为了多个步骤完成的，虽然保证了可见性，但是只要手速够快，依然会出现两个线程同时写同一个值的问题（比如线程1刚刚将a的值更新为100，这时线程2可能也已经执行到更新a的值这条指令了，已经刹不住车了，所以依然会将a的值再更新为一次100）</p>
<p>那要是真的遇到这种情况，那么我们不可能都去写个锁吧？后面，我们会介绍原子类来专门解决这种问题。</p>
<p>最后一个功能就是<code>volatile</code>会禁止指令重排，也就是说，如果我们操作的是一个<code>volatile</code>变量，它将不会出现重排序的情况，也就解决了我们最上面的问题。那么它是怎么解决的重排序问题呢？若用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p>
<blockquote>
<p> 内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p>
<ol>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</li>
</ol>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzwtkeydk7j2194068jsd.jpg" alt="image-20220303172519404"></p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1的读取操作在Load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
</blockquote>
<p>所以<code>volatile</code>能够保证，之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。</p>
<p>最后我们来总结一下<code>volatile</code>关键字的三个特性：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>防止指令重排</li>
</ul>
<p>在之后我们的设计模式系列视频中，还会讲解单例模式下<code>volatile</code>的运用。</p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>经过我们前面的讲解，相信各位已经了解了JMM内存模型以及重排序等机制带来的优点和缺点，综上，JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p>
<ul>
<li><strong>程序次序规则：</strong>同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。<ul>
<li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li>
</ul>
</li>
<li><strong>监视器锁规则：</strong>对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。<ul>
<li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li>
</ul>
</li>
<li><strong>volatile变量规则：</strong>对一个volatile变量的写操作happens-before后续对这个变量的读操作。<ul>
<li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li>
</ul>
</li>
<li><strong>线程启动规则：</strong>主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。<ul>
<li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li>
</ul>
</li>
<li><strong>线程加入规则：</strong>如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li>
<li><strong>传递性规则：</strong>如果A happens-before B，B happens-before C，那么A happens-before C。</li>
</ul>
<p>那么我们来从happens-before原则的角度，来解释一下下面的程序结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span>(b &gt; <span class="number">10</span>) System.out.println(a); </span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们定义以上出现的操作：</p>
<ul>
<li><strong>A：</strong>将变量<code>a</code>的值修改为<code>10</code></li>
<li><strong>B：</strong>将变量<code>b</code>的值修改为<code>a + 1</code></li>
<li><strong>C：</strong>主线程启动了一个新的线程，并在新的线程中获取<code>b</code>，进行判断，如果为<code>true</code>那么就打印<code>a</code></li>
</ul>
<p>首先我们来分析，由于是同一个线程，并且<strong>B</strong>是一个赋值操作且读取了<strong>A</strong>，那么按照<strong>程序次序规则</strong>，A happens-before B，接着在B之后，马上执行了C，按照<strong>线程启动规则</strong>，在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C，最后根据<strong>传递性规则</strong>，由于A happens-before B，B happens-before C，所以A happens-before C，因此在新的线程中会输出<code>a</code>修改后的结果<code>10</code>。</p>
<h1 id="二、多线程编程核心"><a href="#二、多线程编程核心" class="headerlink" title="二、多线程编程核心"></a>二、多线程编程核心</h1><p>在前面，我们了解了多线程的底层运作机制，我们终于知道，原来多线程环境下存在着如此之多的问题。在JDK5之前，我们只能选择<code>synchronized</code>关键字来实现锁，而JDK5之后，由于<code>volatile</code>关键字得到了升级（具体功能就是上一章所描述的），所以并发框架包便出现了，相比传统的<code>synchronized</code>关键字，我们对于锁的实现，有了更多的选择。</p>
<blockquote>
<p>Doug Lea — JUC并发包的作者</p>
<p>如果IT的历史，是以人为主体串接起来的话，那么肯定少不了Doug Lea。这个鼻梁挂着眼镜，留着德王威廉二世的胡子，脸上永远挂着谦逊腼腆笑容，服务于纽约州立大学Oswego分校计算机科学系的老大爷。</p>
<p>说他是这个世界上对Java影响力最大的一个人，一点也不为过。因为两次Java历史上的大变革，他都间接或直接的扮演了举足轻重的角色。2004年所推出的Tiger。Tiger广纳了15项JSRs(Java Specification Requests)的语法及标准，其中一项便是JSR-166。JSR-166是来自于Doug编写的util.concurrent包。</p>
</blockquote>
<p>那么，从这章开始，就让我们来感受一下，JUC为我们带来了什么。</p>
<hr>
<h2 id="锁框架"><a href="#锁框架" class="headerlink" title="锁框架"></a>锁框架</h2><p>在JDK 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</p>
<h3 id="Lock和Condition接口"><a href="#Lock和Condition接口" class="headerlink" title="Lock和Condition接口"></a>Lock和Condition接口</h3><p>使用并发包中的锁和我们传统的<code>synchronized</code>锁不太一样，这里的锁我们可以认为是一把真正意义上的锁，每个锁都是一个对应的锁对象，我只需要向锁对象获取锁或是释放锁即可。我们首先来看看，此接口中定义了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//同上，但是等待过程中会响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以演示一下，如何使用Lock类来进行加锁和释放锁操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock testLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//可重入锁ReentrantLock类是Lock类的一个实现，我们后面会进行介绍</span></span><br><span class="line">        Runnable action = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;   <span class="comment">//还是以自增操作为例</span></span><br><span class="line">                testLock.lock();    <span class="comment">//加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放</span></span><br><span class="line">                i++;</span><br><span class="line">                testLock.unlock();  <span class="comment">//解锁，释放锁之后其他线程就可以获取这把锁了（注意在这之前一定得加锁，不然报错）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(action).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(action).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);   <span class="comment">//等上面两个线程跑完</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和我们之前使用<code>synchronized</code>相比，我们这里是真正在操作一个”锁”对象，当我们需要加锁时，只需要调用<code>lock()</code>方法，而需要释放锁时，只需要调用<code>unlock()</code>方法。程序运行的最终结果和使用<code>synchronized</code>锁是一样的。</p>
<p>那么，我们如何像传统的加锁那样，调用对象的<code>wait()</code>和<code>notify()</code>方法呢，并发包提供了Condition接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（感觉就是和普通对象的wait和notify是对应的）同时，等待状态下是可以响应中断的</span></span><br><span class="line"> 		<span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//同上，但不响应中断（看名字都能猜到）</span></span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span><br><span class="line">  	<span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  	<span class="comment">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">//同上，但是是唤醒所有等待线程</span></span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们通过一个简单的例子来演示一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Lock testLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = testLock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        testLock.lock();   <span class="comment">//和synchronized一样，必须持有锁的情况下才能使用await</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程1进入等待状态！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();   <span class="comment">//进入等待状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1等待结束！&quot;</span>);</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>); <span class="comment">//防止线程2先跑</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">        condition.signal();   <span class="comment">//唤醒线程1，但是此时线程1还必须要拿到锁才能继续运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">        testLock.unlock();   <span class="comment">//这里释放锁之后，线程1就可以拿到锁继续运行了</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，Condition对象使用方法和传统的对象使用差别不是很大。</p>
<p><strong>思考：</strong>下面这种情况跟上面有什么不同？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Lock testLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1进入等待状态！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testLock.newCondition().await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1等待结束！&quot;</span>);</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">        testLock.newCondition().signal();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析可以得到，在调用<code>newCondition()</code>后，会生成一个新的Condition对象，并且同一把锁内是可以存在多个Condition对象的（实际上原始的锁机制等待队列只能有一个，而这里可以创建很多个Condition来实现多等待队列），而上面的例子中，实际上使用的是不同的Condition对象，只有对同一个Condition对象进行等待和唤醒操作才会有效，而不同的Condition对象是分开计算的。</p>
<p>最后我们再来讲解一下时间单位，这是一个枚举类，也是位于<code>java.util.concurrent</code>包下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TimeUnit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time unit representing one thousandth of a microsecond</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NANOSECONDS &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toNanos</span><span class="params">(<span class="keyword">long</span> d)</span>   </span>&#123; <span class="keyword">return</span> d; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMicros</span><span class="params">(<span class="keyword">long</span> d)</span>  </span>&#123; <span class="keyword">return</span> d/(C1/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMillis</span><span class="params">(<span class="keyword">long</span> d)</span>  </span>&#123; <span class="keyword">return</span> d/(C2/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toSeconds</span><span class="params">(<span class="keyword">long</span> d)</span> </span>&#123; <span class="keyword">return</span> d/(C3/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMinutes</span><span class="params">(<span class="keyword">long</span> d)</span> </span>&#123; <span class="keyword">return</span> d/(C4/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toHours</span><span class="params">(<span class="keyword">long</span> d)</span>   </span>&#123; <span class="keyword">return</span> d/(C5/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toDays</span><span class="params">(<span class="keyword">long</span> d)</span>    </span>&#123; <span class="keyword">return</span> d/(C6/C0); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">convert</span><span class="params">(<span class="keyword">long</span> d, TimeUnit u)</span> </span>&#123; <span class="keyword">return</span> u.toNanos(d); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">excessNanos</span><span class="params">(<span class="keyword">long</span> d, <span class="keyword">long</span> m)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)(d - (m*C2)); &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  	<span class="comment">//....</span></span><br></pre></td></tr></table></figure>

<p>可以看到时间单位有很多的，比如<code>DAY</code>、<code>SECONDS</code>、<code>MINUTES</code>等，我们可以直接将其作为时间单位，比如我们要让一个线程等待3秒钟，可以像下面这样编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Lock testLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待是否未超时：&quot;</span>+testLock.newCondition().await(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，Lock类的tryLock方法也是支持使用时间单位的，各位可以自行进行测试。TimeUnit除了可以作为时间单位表示以外，还可以在不同单位之间相互转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;60秒 = &quot;</span>+TimeUnit.SECONDS.toMinutes(<span class="number">60</span>) +<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;365天 = &quot;</span>+TimeUnit.DAYS.toSeconds(<span class="number">365</span>) +<span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以更加便捷地使用对象的<code>wait()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Main.class) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.timedWait(Main.class, <span class="number">3</span>);   <span class="comment">//直接等待3秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接使用它来进行休眠操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);  <span class="comment">//休眠1秒钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>前面，我们讲解了锁框架的两个核心接口，那么我们接着来看看锁接口的具体实现类，我们前面用到了ReentrantLock，它其实是锁的一种，叫做可重入锁，那么这个可重入代表的是什么意思呢？简单来说，就是同一个线程，可以反复进行加锁操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();   <span class="comment">//连续加锁2次</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2想要获取锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2成功获取到锁&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1释放了一次锁&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1再次释放了一次锁&quot;</span>);  <span class="comment">//释放两次后其他线程才能加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，主线程连续进行了两次加锁操作（此操作是不会被阻塞的），在当前线程持有锁的情况下继续加锁不会被阻塞，并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁。我们可以使用<code>getHoldCount()</code>方法查看当前线程的加锁次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="string">&quot;，是否被锁：&quot;</span>+lock.isLocked());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="string">&quot;，是否被锁：&quot;</span>+lock.isLocked());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前加锁次数：&quot;</span>+lock.getHoldCount()+<span class="string">&quot;，是否被锁：&quot;</span>+lock.isLocked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当锁不再被任何线程持有时，值为<code>0</code>，并且通过<code>isLocked()</code>方法查询结果为<code>false</code>。</p>
<p>实际上，如果存在线程持有当前的锁，那么其他线程在获取锁时，是会暂时进入到等待队列的，我们可以通过<code>getQueueLength()</code>方法获取等待中线程数量的预估值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(lock::lock), t2 = <span class="keyword">new</span> Thread(lock::lock);;</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前等待锁释放的线程数：&quot;</span>+lock.getQueueLength());</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1是否在等待队列中：&quot;</span>+lock.hasQueuedThread(t1));</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2是否在等待队列中：&quot;</span>+lock.hasQueuedThread(t2));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程是否在等待队列中：&quot;</span>+lock.hasQueuedThread(Thread.currentThread()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>hasQueuedThread()</code>方法来判断某个线程是否正在等待获取锁状态。</p>
<p>同样的，Condition也可以进行判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    condition.signal();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>getWaitQueueLength()</code>方法能够查看同一个Condition目前有多少线程处于等待状态。</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>前面我们了解了如果线程之间争抢同一把锁，会暂时进入到等待队列中，那么多个线程获得锁的顺序是不是一定是根据线程调用<code>lock()</code>方法时间来定的呢，我们可以看到，<code>ReentrantLock</code>的构造方法中，是这样写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();   <span class="comment">//看名字貌似是非公平的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实锁分为公平锁和非公平锁，默认我们创建出来的ReentrantLock是采用的非公平锁作为底层锁机制。那么什么是公平锁什么又是非公平锁呢？</p>
<ul>
<li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
</ul>
<p>简单来说，公平锁不让插队，都老老实实排着；非公平锁让插队，但是排队的人让不让你插队就是另一回事了。</p>
<p>我们可以来测试一下公平锁和非公平锁的表现情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们选择使用第二个构造方法，可以选择是否为公平锁实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Runnable action = () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 开始获取锁...&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 成功获取锁！&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   <span class="comment">//建立10个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(action, <span class="string">&quot;T&quot;</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需要对比<code>将在1秒后开始获取锁...</code>和<code>成功获取锁！</code>的顺序是否一致即可，如果是一致，那说明所有的线程都是按顺序排队获取的锁，如果不是，那说明肯定是有线程插队了。</p>
<p>运行结果可以发现，在公平模式下，确实是按照顺序进行的，而在非公平模式下，一般会出现这种情况：线程刚开始获取锁马上就能抢到，并且此时之前早就开始的线程还在等待状态，很明显的插队行为。</p>
<p>那么，接着下一个问题，公平锁在任何情况下都一定是公平的吗？有关这个问题，我们会留到队列同步器中再进行讨论。</p>
<hr>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。</p>
<p>读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的。</p>
<ul>
<li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li>
<li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li>
</ul>
<p>读写锁也有一个专门的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取读锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//获取写锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> Thread(lock.readLock()::lock).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们对读锁加锁，可以看到可以多个线程同时对读锁加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> Thread(lock.writeLock()::lock).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有读锁状态下无法加写锁，反之亦然：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> Thread(lock.readLock()::lock).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平/非公平机制，比如同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取到写锁！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第一层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第二层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过之前的例子来验证公平和非公平：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Runnable action = () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 将在1秒后开始获取锁...&quot;</span>);</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 成功获取锁！&quot;</span>);</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   <span class="comment">//建立10个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(action, <span class="string">&quot;T&quot;</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，结果是一致的。</p>
<h4 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h4><p>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;成功加读锁！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果我们在同时加了写锁和读锁的情况下，释放写锁，是否其他的线程就可以一起加读锁了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加读锁！&quot;</span>);</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;读锁添加成功！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.writeLock().unlock();    <span class="comment">//如果释放写锁，会怎么样？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，一旦写锁被释放，那么主线程就只剩下读锁了，因为读锁可以被多个线程共享，所以这时第二个线程也添加了读锁。而这种操作，就被称之为”锁降级”（注意不是先释放写锁再加读锁，而是持有写锁的情况下申请读锁再释放写锁）</p>
<p>注意在仅持有读锁的情况下去申请写锁，属于”锁升级”，ReentrantReadWriteLock是不支持的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;所升级成功！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到线程直接卡在加写锁的那一句了。</p>
<h3 id="队列同步器AQS"><a href="#队列同步器AQS" class="headerlink" title="队列同步器AQS"></a>队列同步器AQS</h3><p><strong>注意：</strong>难度巨大，如果对锁的使用不是很熟悉建议之后再来看！</p>
<p>前面我们了解了可重入锁和读写锁，那么它们的底层实现原理到底是什么样的呢？又是大家看到就想跳过的套娃解析环节。</p>
<p>比如我们执行了ReentrantLock的<code>lock()</code>方法，那它的内部是怎么在执行的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它的内部实际上啥都没做，而是交给了Sync对象在进行，并且，不只是这个方法，其他的很多方法都是依靠Sync对象在进行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个Sync对象是干什么的呢？可以看到，公平锁和非公平锁都是继承自Sync，而Sync是继承自AbstractQueuedSynchronizer，简称队列同步器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>所以，要了解它的底层到底是如何进行操作的，还得看队列同步器，我们就先从这里下手吧！</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>AbstractQueuedSynchronizer（下面称为AQS）是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列。</p>
<p>一个锁（排他锁为例）的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由双向链表数据结构实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的，它像这样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h008jltp0zj212k0b4tac.jpg" alt="image-20220306162015545"></p>
<p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。我们先来了解一下每个结点都包含了哪些内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//等待状态，这里都定义好了</span></span><br><span class="line">   	<span class="comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  	<span class="comment">//此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;	</span><br><span class="line">  	<span class="comment">//在条件队列中的节点才是这个状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">  	<span class="comment">//传播，一般用于共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;    <span class="comment">//等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;   <span class="comment">//双向链表基操</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">//每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter;   <span class="comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>不用担心双向链表不会进行初始化，初始化是在实际使用时才开始的，先不管，我们接着来看其他的初始化内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接使用Unsafe类进行操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;   <span class="comment">//这里对应的就是AQS类中的state成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;    <span class="comment">//这里对应的就是AQS类中的head头结点成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块，在类加载的时候就会自动获取偏移地址</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过CAS操作来修改头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p>
<p>现在我们大致了解了一下它的底层运作机制，我们接着来看这个类是如何进行使用的，它提供了一些可重写的方法（根据不同的锁类型和机制，可以自由定制规则，并且为独占式和非独占式锁都提供了对应的方法），以及一些已经写好的模板方法（模板方法会调用这些可重写的方法），使用此类只需要将可重写的方法进行重写，并调用提供的模板方法，从而实现锁功能（学习过设计模式会比较好理解一些）</p>
<p>我们首先来看可重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式获取同步状态，返回值大于0表示成功，否则失败</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//加锁操作调用了模板方法acquire</span></span><br><span class="line">  	<span class="comment">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span> <span class="comment">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   <span class="comment">//节点为独占模式Node.EXCLUSIVE</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用<code>tryAcquire()</code>方法（这里是由FairSync类实现的），如果尝试加独占锁失败（返回false了）说明可能这个时候有其他线程持有了此独占锁，所以当前线程得先等着，那么会调用<code>addWaiter()</code>方法将线程加入等待队列中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//此方法是CAS快速入队失败时调用</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//自旋形式入队，可以看到这里是一个无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;  <span class="comment">//这种情况只能说明头结点和尾结点都还没初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))   <span class="comment">//初始化头结点和尾结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;   <span class="comment">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了<code>addWaiter()</code>方法会将节点加入等待队列之后，我们接着来看，<code>addWaiter()</code>会返回已经加入的节点，<code>acquireQueued()</code>在得到返回的节点时，也会进入自旋状态，等待唤醒（也就是开始进入到拿锁的环节了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span><br><span class="line">                setHead(node);    <span class="comment">//新的头结点设置为当前结点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 原有的头结点没有存在的意义了</span></span><br><span class="line">                failed = <span class="keyword">false</span>;   <span class="comment">//没有失败</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;   <span class="comment">//直接返回等待过程中是否被中断</span></span><br><span class="line">            &#125;	</span><br><span class="line">          	<span class="comment">//依然没获取成功，</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span><br><span class="line">                parkAndCheckInterrupt())   <span class="comment">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);   <span class="comment">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">//已经是SIGNAL，直接true</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">//不能是已经取消的节点，必须找到一个没被取消的</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;   <span class="comment">//直接抛弃被取消的节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是SIGNAL，先CAS设置为SIGNAL（这里没有返回true因为CAS不一定成功，需要下一轮再判断一次）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//返回false，马上开启下一轮循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>acquire()</code>中的if条件如果为true，那么只有一种情况，就是等待过程中被中断了，其他任何情况下都是成功获取到独占锁，所以当等待过程被中断时，会调用<code>selfInterrupt()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是直接向当前线程发送中断信号了。</p>
<p>上面提到了LockSupport类，它是一个工具类，我们也可以来玩一下这个<code>park</code>和<code>unpark</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">//先拿到主线程的Thread对象</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程可以继续运行了！&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t);</span><br><span class="line">          	<span class="comment">//t.interrupt();   发送中断信号也可以恢复运行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程被挂起！&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程继续运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就把公平锁的<code>lock()</code>方法实现讲解完毕了（让我猜猜，已经晕了对吧，越是到源码越考验个人的基础知识掌握，基础不牢地动山摇）接着我们来看公平锁的<code>tryAcquire()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//可重入独占锁的公平实现</span></span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();   <span class="comment">//先获取当前线程的Thread对象</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();     <span class="comment">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;       <span class="comment">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span></span><br><span class="line">                setExclusiveOwnerThread(current);    <span class="comment">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">//占用锁成功，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   <span class="comment">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;    <span class="comment">//多次加锁会将状态值进行增加，状态值就是加锁次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)   <span class="comment">//加到int值溢出了？</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);   <span class="comment">//设置为新的加锁次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//其他任何情况都是加锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p>
<p>加锁过程已经OK，我们接着来看，它的解锁过程，<code>unlock()</code>方法是在AQS中实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);    <span class="comment">//直接调用了AQS中的release方法，参数为1表示解锁一次state值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;   <span class="comment">//和tryAcquire一样，也得子类去重写，释放锁操作</span></span><br><span class="line">        Node h = head;    <span class="comment">//释放锁成功后，获取新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span></span><br><span class="line">            unparkSuccessor(h);   <span class="comment">//唤醒头节点下一个节点中的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将等待状态waitStatus设置为初始值0</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下一个结点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;   <span class="comment">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)   <span class="comment">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)   <span class="comment">//要是找到了，就直接unpark，要是还是没找到，那就算了</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;   <span class="comment">//先计算本次解锁之后的状态值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())   <span class="comment">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   <span class="comment">//否则直接抛异常</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">//如果解锁之后的值为0，表示已经完全释放此锁</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);  <span class="comment">//将独占锁持有线程设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);   <span class="comment">//状态值设定为c</span></span><br><span class="line">    <span class="keyword">return</span> free;  <span class="comment">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们来画一个完整的流程图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h004uzeni8j224k0ca0w9.jpg" alt="image-20220306141248030"></p>
<p>这里我们只讲解了公平锁，有关非公平锁和读写锁，还请各位观众根据我们之前的思路，自行解读。</p>
<h4 id="公平锁一定公平吗？"><a href="#公平锁一定公平吗？" class="headerlink" title="公平锁一定公平吗？"></a>公平锁一定公平吗？</h4><p>前面我们讲解了公平锁的实现原理，那么，我们尝试分析一下，在并发的情况下，公平锁一定公平吗？</p>
<p>我们再次来回顾一下<code>tryAcquire()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   <span class="comment">//注意这里，公平锁的机制是，一开始会查看是否有节点处于等待</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>hasQueuedPredecessors()</code>这个环节容不得半点闪失，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p>
<p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为 <code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 线程2进来之后，肯定是要先走这里的，因为head和tail都是null</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;   <span class="comment">//这里就将tail直接等于head了，注意这里完了之后还没完，这里只是初始化过程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;   <span class="comment">//由于一开始head和tail都是null，所以线程2直接就进enq()了</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);   <span class="comment">//请看上面</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而碰巧不巧，这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，而在此方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">  	<span class="comment">//这里直接判断h != t，而此时线程2才刚刚执行完 tail = head，所以直接就返回false了</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在插入节点状态，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。</p>
<p>一张图就是：</p>
<p>因此公不公平全看<code>hasQueuedPredecessors()</code>，而此方法只有在等待队列中存在节点时才能保证不会出现问题。所以公平锁，只有在等待队列存在节点时，才是真正公平的。</p>
<h4 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h4><p>通过前面的学习，我们知道Condition类实际上就是用于代替传统对象的wait/notify操作的，同样可以实现等待/通知模式，并且同一把锁下可以创建多个Condition对象。那么我们接着来看看，它又是如何实现的呢，我们先从单个Condition对象进行分析：</p>
<p>在AQS中，Condition有一个实现类ConditionObject，而这里也是使用了链表实现了条件队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** 条件队列的头结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** 条件队列的尾结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p>
<p>我们知道，当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p>
<p>我们先来看看最关键的<code>await()</code>方法是如何实现的，为了防止一会绕晕，在开始之前，我们先明确此方法的目标：</p>
<ul>
<li>只有已经持有锁的线程才可以使用此方法</li>
<li>当调用此方法后，会直接释放锁，无论加了多少次锁</li>
<li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li>
<li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li>
</ul>
<p>好了，差不多可以上源码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    Node node = addConditionWaiter();    <span class="comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);    <span class="comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;     <span class="comment">//用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);   <span class="comment">//如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)   <span class="comment">//看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">  	<span class="comment">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();  <span class="comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)   <span class="comment">//依然是响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">  	<span class="comment">//OK，接着该干嘛干嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p>
<ul>
<li>只有持有锁的线程才能唤醒锁所属的Condition等待的线程</li>
<li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li>
<li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li>
<li>拿到锁之后，线程才能恢复运行</li>
</ul>
<p>好了，上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">//先看看当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   <span class="comment">//不是？那你不配唤醒别人</span></span><br><span class="line">    Node first = firstWaiter;    <span class="comment">//获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)    <span class="comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)   <span class="comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;   <span class="comment">//所以这里相当于是直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;   <span class="comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;   <span class="comment">//接着往下看</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);   <span class="comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span><br><span class="line">  	<span class="comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;   <span class="comment">//保存前驱结点的等待状态</span></span><br><span class="line">  	<span class="comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);  <span class="comment">//直接唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p>
<p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p>
<ul>
<li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li>
<li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt;<br>0之后!compareAndSetWaitStatus(p, ws,<br>Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws,<br>Node.SIGNAL) == false</li>
</ul>
<p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。</p>
<p>所以，大致流程下：</p>
<p>只要把整个流程理清楚，还是很好理解的。</p>
<h4 id="自行实现锁类"><a href="#自行实现锁类" class="headerlink" title="自行实现锁类"></a>自行实现锁类</h4><p>既然前面了解了那么多AQS的功能，那么我就仿照着这些锁类来实现一个简单的锁：</p>
<ul>
<li>要求：同一时间只能有一个线程持有锁，不要求可重入（反复加锁无视即可）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自行实现一个最普通的独占锁</span></span><br><span class="line"><span class="comment">     * 要求：同一时间只能有一个线程持有锁，不要求可重入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设计思路：</span></span><br><span class="line"><span class="comment">         * 1. 锁被占用，那么exclusiveOwnerThread应该被记录，并且state = 1</span></span><br><span class="line"><span class="comment">         * 2. 锁没有被占用，那么exclusiveOwnerThread为null，并且state = 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(isHeldExclusively()) <span class="keyword">return</span> <span class="keyword">true</span>;     <span class="comment">//无需可重入功能，如果是当前线程直接返回true</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, arg))&#123;    <span class="comment">//CAS操作进行状态替换</span></span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());    <span class="comment">//成功后设置当前的所有者线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(getState() == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   <span class="comment">//没加锁情况下是不能直接解锁的</span></span><br><span class="line">                <span class="keyword">if</span>(isHeldExclusively())&#123;     <span class="comment">//只有持有锁的线程才能解锁</span></span><br><span class="line">                    setExclusiveOwnerThread(<span class="keyword">null</span>);    <span class="comment">//设置所有者线程为null</span></span><br><span class="line">                    setState(<span class="number">0</span>);    <span class="comment">//状态变为0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();    <span class="comment">//直接用现成的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们对应队列同步器AQS的讲解就先到此为止了，当然，AQS的全部机制并非仅仅只有我们讲解的内容，一些我们没有提到的内容，还请各位观众自行探索，会有满满的成就感哦~</p>
<hr>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>前面我们讲解了锁框架的使用和实现原理，虽然比较复杂，但是收获还是很多的（主要是观摩大佬写的代码）这一部分我们就来讲一点轻松的。</p>
<p>前面我们说到，如果要保证<code>i++</code>的原子性，那么我们的唯一选择就是加锁，那么，除了加锁之外，还有没有其他更好的解决方法呢？JUC为我们提供了原子类，底层采用CAS算法，它是一种用法简单、性能高效、线程安全地更新变量的方式。</p>
<p>所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p>
<h3 id="原子类介绍"><a href="#原子类介绍" class="headerlink" title="原子类介绍"></a>原子类介绍</h3><p>常用基本数据类，有对应的原子类封装：</p>
<ul>
<li>AtomicInteger：原子更新int</li>
<li>AtomicLong：原子更新long</li>
<li>AtomicBoolean：原子更新boolean</li>
</ul>
<p>那么，原子类和普通的基本类在使用上有没有什么区别呢？我们先来看正常情况下使用一个基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们使用int类型对应的原子类，要实现同样的代码该如何编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.getAndIncrement());  <span class="comment">//如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta 值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增，乍一看，这不就是基本类型包装类嘛，有啥高级的。确实，还真有包装类那味，但是它可不仅仅是简单的包装，它的自增操作是具有原子性的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++)</span><br><span class="line">                i.getAndIncrement();</span><br><span class="line">            System.out.println(<span class="string">&quot;自增完成！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是直接进行自增操作，我们发现，使用原子类是可以保证自增操作原子性的，就跟我们前面加锁一样。怎么会这么神奇？我们来看看它的底层是如何实现的，直接从构造方法点进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它的底层是比较简单的，其实本质上就是封装了一个<code>volatile</code>类型的int值，这样能够保证可见性，在CAS操作的时候不会出现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最上面是和AQS采用了类似的机制，因为要使用CAS算法更新value的值，所以得先计算出value字段在对象中的偏移地址，CAS直接修改对应位置的内存即可（可见Unsafe类的作用巨大，很多的底层操作都要靠它来完成）</p>
<p>接着我们来看自增操作是怎么在运行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了<code>unsafe.getAndAddInt()</code>，套娃时间到，我们接着看看Unsafe里面写了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;  <span class="comment">//delta就是变化的值，++操作就是自增1</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      	<span class="comment">//volatile版本的getInt()</span></span><br><span class="line">      	<span class="comment">//能够保证可见性</span></span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));  <span class="comment">//这里是开始cas替换int的值，每次都去拿最新的值去进行替换，如果成功则离开循环，不成功说明这个时候其他线程先修改了值，就进下一次循环再获取最新的值然后再cas一次，直到成功为止</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个<code>do-while</code>循环，那么这个循环在做一个什么事情呢？感觉就和我们之前讲解的AQS队列中的机制差不多，也是采用自旋形式，来不断进行CAS操作，直到成功。</p>
<p>可见，原子类底层也是采用了CAS算法来保证的原子性，包括<code>getAndSet</code>、<code>getAndAdd</code>等方法都是这样。原子类也直接提供了CAS操作方法，我们可以直接使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line">    System.out.println(integer.compareAndSet(<span class="number">30</span>, <span class="number">20</span>));</span><br><span class="line">    System.out.println(integer.compareAndSet(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想以普通变量的方式来设定值，那么可以使用<code>lazySet()</code>方法，这样就不采用<code>volatile</code>的立即可见机制了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">integer.lazySet(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p>
<ul>
<li>AtomicIntegerArray：原子更新int数组</li>
<li>AtomicLongArray：原子更新long数组</li>
<li>AtomicReferenceArray：原子更新引用数组</li>
</ul>
<p>其实原子数组和原子类型一样的，不过我们可以对数组内的元素进行原子操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            array.getAndAdd(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();   <span class="comment">//100个线程</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(adder.sum());   <span class="comment">//最后求和即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于底层源码比较复杂，这里就不做讲解了。两者的性能对比（这里用到了CountDownLatch，建议学完之后再来看）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用AtomicLong的时间消耗：&quot;</span>+test2()+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用LongAdder的时间消耗：&quot;</span>+test1()+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        <span class="keyword">long</span> timeStart = System.currentTimeMillis();</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">                adder.add(<span class="number">1</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - timeStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        <span class="keyword">long</span> timeStart = System.currentTimeMillis();</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">                atomicLong.incrementAndGet();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - timeStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了对基本数据类型支持原子操作外，对于引用类型，也是可以实现原子操作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;(a);</span><br><span class="line">    reference.compareAndSet(a, b);</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（注意字段必须添加volatile关键字）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(fieldUpdater.incrementAndGet(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了这么多原子类，是不是感觉要实现保证原子性的工作更加轻松了？</p>
<h3 id="ABA问题及解决方案"><a href="#ABA问题及解决方案" class="headerlink" title="ABA问题及解决方案"></a>ABA问题及解决方案</h3><p>我们来想象一下这种场景：</p>
<p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p>
<p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题（无锁虽好，但是问题多多），它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p>
<p>那么如何解决这种<code>ABA</code>问题呢，JUC提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复，那么就可以解决ABA问题了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(a, <span class="number">1</span>);  <span class="comment">//在构造时需要指定初始值和对应的版本号</span></span><br><span class="line">    reference.attemptStamp(a, <span class="number">2</span>);   <span class="comment">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span><br><span class="line">    System.out.println(reference.compareAndSet(a, b, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，有关原子类的讲解就到这里。</p>
<hr>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>简单的讲完了，又该讲难一点的了。</p>
<p><strong>注意：</strong>本版块的重点在于探究并发容器是如何利用锁机制和算法实现各种丰富功能的，我们会忽略一些常规功能的实现细节（比如链表如何插入元素删除元素），而更关注并发容器应对并发场景算法上的实现（比如在多线程环境下的插入操作是按照什么规则进行的）</p>
<p>在单线程模式下，集合类提供的容器可以说是非常方便了，几乎我们每个项目中都能或多或少的用到它们，我们在JavaSE阶段，为各位讲解了各个集合类的实现原理，我们了解了链表、顺序表、哈希表等数据结构，那么，在多线程环境下，这些数据结构还能正常工作吗？</p>
<h3 id="传统容器线程安全吗"><a href="#传统容器线程安全吗" class="headerlink" title="传统容器线程安全吗"></a>传统容器线程安全吗</h3><p>我们来测试一下，100个线程同时向ArrayList中添加元素会怎么样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">                list.add(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">      	TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出意外的话，肯定是会报错的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.ArrayIndexOutOfBoundsException: 73</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:465)</span><br><span class="line">	at com.test.Main.lambda$main$0(Main.java:13)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">Exception in thread &quot;Thread-19&quot; java.lang.ArrayIndexOutOfBoundsException: 1851</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:465)</span><br><span class="line">	at com.test.Main.lambda$main$0(Main.java:13)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">9773</span><br></pre></td></tr></table></figure>

<p>那么我们来看看报的什么错，从栈追踪信息可以看出，是add方法出现了问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;   <span class="comment">//这一句出现了数组越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，同一时间其他线程也在疯狂向数组中添加元素，那么这个时候有可能在<code>ensureCapacityInternal</code>（确认容量足够）执行之后，<code>elementData[size++] = e;</code>执行之前，其他线程插入了元素，导致size的值超出了数组容量。这些在单线程的情况下不可能发生的问题，在多线程下就慢慢出现了。</p>
<p>我们再来看看比较常用的HashMap呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                map.put(finalI * <span class="number">1000</span> + j, <span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试发现，虽然没有报错，但是最后的结果并不是我们期望的那样，实际上它还有可能导致Entry对象出现环状数据结构，引起死循环。</p>
<p>所以，在多线程环境下，要安全地使用集合类，我们得找找解决方案了。</p>
<h3 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a>并发容器介绍</h3><p>怎么才能解决并发情况下的容器问题呢？我们首先想到的肯定是给方法前面加个<code>synchronzed</code>关键字，这样总不会抢了吧，在之前我们可以使用Vector或是Hashtable来解决，但是它们的效率实在是太低了，完全依靠锁来解决问题，因此现在已经很少再使它们了，这里也不会再去进行讲解。</p>
<p>JUC提供了专用于并发场景下的容器，比如我们刚刚使用的ArrayList，在多线程环境下是没办法使用的，我们可以将其替换为JUC提供的多线程专用集合类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();  <span class="comment">//这里使用CopyOnWriteArrayList来保证线程安全</span></span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            list.add(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，使用了<code>CopyOnWriteArrayList</code>之后，再没出现过上面的问题。</p>
<p>那么它是如何实现的呢，我们先来看看它是如何进行<code>add()</code>操作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">//直接加锁，保证同一时间只有一个线程进行添加操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();  <span class="comment">//获取当前存储元素的数组</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">//直接复制一份数组</span></span><br><span class="line">        newElements[len] = e;   <span class="comment">//修改复制出来的数组</span></span><br><span class="line">        setArray(newElements);   <span class="comment">//将元素数组设定为复制出来的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）接着我们来看读操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于我们前面讲解的读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题。</p>
<p>接着我们来看对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                map.put(finalI * <span class="number">100</span> + j, <span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的ConcurrentHashMap就没有出现之前HashMap的问题了。因为线程之间会争抢同一把锁，我们之前在讲解LongAdder的时候学习到了一种压力分散思想，既然每个线程都想抢锁，那我就干脆多搞几把锁，让你们每个人都能拿到，这样就不会存在等待的问题了，而JDK7之前，ConcurrentHashMap的原理也比较类似，它将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p>
<p>这里我们重点讲解JDK8之后它是怎么实现的，它采用了CAS算法配合锁机制实现，我们先来回顾一下JDK8下的HashMap是什么样的结构：</p>
<p><img data-src="https://img-blog.csdnimg.cn/img_convert/3ad05990ed9e29801b1992030c030a00.png" alt="img"></p>
<p>HashMap就是利用了哈希表，哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p>
<p>又是基础不牢地动山摇环节，由于ConcurrentHashMap的源码比较复杂，所以我们先从最简单的构造方法开始下手：</p>
<p>我们发现，它的构造方法和HashMap的构造方法有很大的出入，但是大体的结构和HashMap是差不多的，也是维护了一个哈希表，并且哈希表中存放的是链表或是红黑树，所以我们直接来看<code>put()</code>操作是如何实现的，只要看明白这个，基本上就懂了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有点小乱，如果看着太乱，可以在IDEA中折叠一下代码块，不然有点难受</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">//键值不能为空，基操</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//计算键的hash值，用于确定在哈希表中的位置</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;   <span class="comment">//一会用来记录链表长度的，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//无限循环，而且还是并发包中的类，盲猜一波CAS自旋锁</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();    <span class="comment">//如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;   <span class="comment">//如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))  </span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)   <span class="comment">//头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span><br><span class="line">            tab = helpTransfer(tab, f);   <span class="comment">//帮助进行迁移，完事之后再来下一次循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">//特殊情况都完了，这里就该是正常情况了，</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;   <span class="comment">//在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    <span class="comment">//头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span><br><span class="line">                        ...实现细节略</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;   <span class="comment">//肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作</span></span><br><span class="line">                      	<span class="comment">//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span><br><span class="line">                        ...实现细节略</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//根据链表长度决定是否要进化为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);   <span class="comment">//注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么样，是不是感觉看着挺复杂，其实也还好，总结一下就是：</p>
<p>我们接着来看看<code>get()</code>操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());   <span class="comment">//计算哈希值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果头结点就是我们要找的，那直接返回值就行了</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//要么是正在扩容，要么就是红黑树，负数只有这两种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">//确认无误，肯定在列表里，开找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//没找到只能null了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p>
<p>其实这里也只是简单地介绍了一下它的运行机制，ConcurrentHashMap真正的难点在于扩容和迁移操作，我们主要了解的是他的并发执行机制，有关它的其他实现细节，这里暂时不进行讲解。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>除了我们常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p>
<p>阻塞队列本身也是队列，但是它是适用于多线程环境下的，基于ReentrantLock实现的，它的接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，返回false否则返回true（非阻塞）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队为止</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队为止</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p>
<p>利用阻塞队列，我们可以轻松地实现消费者和生产者模式，还记得我们在JavaSE中的实战吗？</p>
<blockquote>
<p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p>
</blockquote>
<p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒，窗口上只能放一个菜。</p>
<p>我们来看看，使用阻塞队列如何实现，这里我们就使用<code>ArrayBlockingQueue</code>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        Runnable supplier = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.err.println(time()+<span class="string">&quot;生产者 &quot;</span>+name+<span class="string">&quot; 正在准备餐品...&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    System.err.println(time()+<span class="string">&quot;生产者 &quot;</span>+name+<span class="string">&quot; 已出餐！&quot;</span>);</span><br><span class="line">                    queue.put(<span class="keyword">new</span> Object());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(time()+<span class="string">&quot;消费者 &quot;</span>+name+<span class="string">&quot; 正在等待出餐...&quot;</span>);</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(time()+<span class="string">&quot;消费者 &quot;</span>+name+<span class="string">&quot; 取到了餐品。&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">                    System.out.println(time()+<span class="string">&quot;消费者 &quot;</span>+name+<span class="string">&quot; 已经将饭菜吃完了！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="keyword">new</span> Thread(supplier, <span class="string">&quot;Supplier-&quot;</span>+i).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">new</span> Thread(consumer, <span class="string">&quot;Consumer-&quot;</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">time</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>+format.format(<span class="keyword">new</span> Date()) + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，阻塞队列在多线程环境下的作用是非常明显的，算上ArrayBlockingQueue，一共有三种常用的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：有界带缓冲阻塞队列（就是队列是有容量限制的，装满了肯定是不能再装的，只能阻塞，数组实现）</li>
<li>SynchronousQueue：无缓冲阻塞队列（相当于没有容量的ArrayBlockingQueue，因此只有阻塞的情况）</li>
<li>LinkedBlockingQueue：无界带缓冲阻塞队列（没有容量限制，也可以限制容量，也会阻塞，链表实现）</li>
</ul>
<p>这里我们以ArrayBlockingQueue为例进行源码解读，我们先来看看构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);   <span class="comment">//底层采用锁机制保证线程安全性，这里我们可以选择使用公平锁或是非公平锁</span></span><br><span class="line">    notEmpty = lock.newCondition();   <span class="comment">//这里创建了两个Condition（都属于lock）一会用于入队和出队的线程阻塞控制</span></span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看<code>put</code>和<code>offer</code>方法是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;    <span class="comment">//可以看到这里也是使用了类里面的ReentrantLock进行加锁操作</span></span><br><span class="line">    lock.lock();    <span class="comment">//保证同一时间只有一个线程进入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)   <span class="comment">//直接看看队列是否已满，如果没满则直接入队，如果已满则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;    <span class="comment">//同样的，需要进行加锁操作</span></span><br><span class="line">    lock.lockInterruptibly();    <span class="comment">//注意这里是可以响应中断的</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();    <span class="comment">//可以看到当队列已满时会直接挂起当前线程，在其他线程出队操作时会被唤醒</span></span><br><span class="line">        enqueue(e);   <span class="comment">//直到队列有空位才将线程入队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();    <span class="comment">//出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看出队操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">//出队同样进行加锁操作，保证同一时间只能有一个线程执行</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();   <span class="comment">//如果队列不为空则出队，否则返回null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();    <span class="comment">//可以响应中断进行加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();    <span class="comment">//和入队相反，也是一直等直到队列中有元素之后才可以出队，在入队时会唤醒此线程</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();    <span class="comment">//对notEmpty的signal唤醒操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，如果各位对锁的使用非常熟悉的话，那么在阅读这些源码的时候，就会非常轻松了。</p>
<p>接着我们来看一个比较特殊的队列SynchronousQueue，它没有任何容量，也就是说正常情况下出队必须和入队操作成对出现，我们先来看它的内部，可以看到内部有一个抽象类Transferer，它定义了一个<code>transfer</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以是put也可以是take操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者</span></span><br><span class="line"><span class="comment">     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 是否可以超时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，有点迷惑，难不成还要靠这玩意去实现put和take操作吗？实际上它是直接以生产者消费者模式进行的，由于不需要依靠任何容器结构来暂时存放数据，所以我们可以直接通过<code>transfer</code>方法来对生产者和消费者之间的数据进行传递。</p>
<p>比如一个线程put一个新的元素进入，这时如果没有其他线程调用take方法获取元素，那么会持续被阻塞，直到有线程取出元素，而<code>transfer</code>正是需要等生产者消费者双方都到齐了才能进行交接工作，单独只有其中一方都需要进行等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;   <span class="comment">//直接使用transfer方法进行数据传递</span></span><br><span class="line">        Thread.interrupted();    <span class="comment">//为空表示要么被中断要么超时</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在公平和非公平模式下，有两个实现，这里我们来看公平模式下的SynchronousQueue是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">     <span class="comment">//尾结点</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点有生产者和消费者角色之分 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// 存储的元素</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;         <span class="comment">// 是生产者节点还是消费者节点</span></span><br></pre></td></tr></table></figure>

<p>公平模式下，Transferer的实现是TransferQueue，是以先进先出的规则的进行的，内部有一个QNode类来保存等待的线程。</p>
<p>好了，我们直接上<code>transfer()</code>方法的实现（这里再次提醒各位，多线程环境下的源码分析和单线程的分析不同，我们需要时刻关注当前代码块的加锁状态，如果没有加锁，一定要具有多线程可能会同时运行的意识，这个意识在以后你自己处理多线程问题伴随着你，才能保证你的思路在多线程环境下是正确的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;   <span class="comment">//注意这里面没加锁，肯定会多个线程之间竞争</span></span><br><span class="line">    QNode s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);   <span class="comment">//e为空表示消费者，不为空表示生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// 头结点尾结点任意为空（但是在构造的时候就已经不是空了）</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// 自旋</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 头结点等于尾结点表示队列中只有一个头结点，肯定是空，或者尾结点角色和当前节点一样，这两种情况下，都需要进行入队操作</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// 如果这段时间内t被其他线程修改了，如果是就进下一轮循环重新来</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// 继续校验是否为队尾，如果tn不为null，那肯定是其他线程改了队尾，可以进下一轮循环重新来了</span></span><br><span class="line">                advanceTail(t, tn);					<span class="comment">// CAS将新的队尾节点设置为tn，成不成功都无所谓，反正这一轮肯定没戏了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 超时返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);   <span class="comment">//构造当前结点，准备加入等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// CAS添加当前节点为尾结点的下一个，如果失败肯定其他线程又抢先做了，直接进下一轮循环重新来</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// 上面的操作基本OK了，那么新的队尾元素就修改为s</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);   <span class="comment">//开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// 如果返回s本身说明等待状态下被取消</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// 如果s操作完成之后没有离开队列，那么这里将其手动丢弃</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// 删除s内的其他信息</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;   <span class="comment">//假如当前是消费者，直接返回x即可，x就是从生产者那里拿来的元素</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 这种情况下就是与队列中结点类型匹配的情况了（注意队列要么为空要么只会存在一种类型的节点，因为一旦出现不同类型的节点马上会被交接掉）</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// 获取头结点的下一个接口，准备进行交接工作</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// 判断其他线程是否先修改，如果修改过那么开下一轮</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// 判断节点类型，如果是相同的操作，那肯定也是有问题的</span></span><br><span class="line">                x == m ||                   <span class="comment">// 或是当前操作被取消</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// 上面都不是？那么最后再进行CAS替换m中的元素，成功表示交接成功，失败就老老实实重开吧</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// 成功交接，新的头结点可以改为m了，原有的头结点直接不要了</span></span><br><span class="line">            LockSupport.unpark(m.waiter);   <span class="comment">// m中的等待交接的线程可以继续了，已经交接完成</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;  <span class="comment">// 同上，该返回什么就返回什么</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，总结为以下流程：</p>
<p>对于非公平模式下的SynchronousQueue，则是采用的栈结构来存储等待节点，但是思路也是与这里的一致，需要等待并进行匹配操作，各位如果感兴趣可以继续了解一下非公平模式下的SynchronousQueue实现。</p>
<p>在JDK7的时候，基于SynchronousQueue产生了一个更强大的TransferQueue，它保留了SynchronousQueue的匹配交接机制，并且与等待队列进行融合。</p>
<p>我们知道，SynchronousQueue并没有使用锁，而是采用CAS操作保证生产者与消费者的协调，但是它没有容量，而LinkedBlockingQueue虽然是有容量且无界的，但是内部基本都是基于锁实现的，性能并不是很好，这时，我们就可以将它们各自的优点单独拿出来，揉在一起，就成了性能更高的LinkedTransferQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LinkedTransferQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span><br><span class="line">    queue.put(<span class="string">&quot;1&quot;</span>);  <span class="comment">//插入时，会先检查是否有其他线程等待获取，如果是，直接进行交接，否则插入到存储队列中</span></span><br><span class="line">   	queue.put(<span class="string">&quot;2&quot;</span>);  <span class="comment">//不会像SynchronousQueue那样必须等一个匹配的才可以</span></span><br><span class="line">    queue.forEach(System.out::println);   <span class="comment">//直接打印所有的元素，这在SynchronousQueue下只能是空，因为单独的入队或出队操作都会被阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比 <code>SynchronousQueue</code> ，它多了一个可以存储的队列，我们依然可以像阻塞队列那样获取队列中所有元素的值，简单来说，<code>LinkedTransferQueue</code>其实就是一个多了存储队列的<code>SynchronousQueue</code>。</p>
<p>接着我们来了解一些其他的队列：</p>
<ul>
<li>PriorityBlockingQueue - 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定。</li>
<li>DelayQueue - 它能够实现延迟获取元素，同样支持优先级。</li>
</ul>
<p>我们先来看优先级阻塞队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    PriorityBlockingQueue&lt;Integer&gt; queue =</span><br><span class="line">            <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;(<span class="number">10</span>, Integer::compare);   <span class="comment">//可以指定初始容量（可扩容）和优先级比较规则，这里我们使用升序</span></span><br><span class="line">    queue.add(<span class="number">3</span>);</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line">    queue.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(queue);    <span class="comment">//注意保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果</span></span><br><span class="line">    System.out.println(queue.poll());   <span class="comment">//但是出队顺序一定是按照优先级进行的</span></span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的重点是DelayQueue，它能实现延时出队，也就是说当一个元素插入后，如果没有超过一定时间，那么是无法让此元素出队的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>

<p>可以看到此类只接受Delayed的实现类作为元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;  <span class="comment">//注意这里继承了Comparable，它支持优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们手动实现一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> time;   <span class="comment">//延迟时间，这里以毫秒为单位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(<span class="keyword">long</span> time, <span class="keyword">int</span> priority, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = TimeUnit.SECONDS.toMillis(time);   <span class="comment">//秒转换为毫秒</span></span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis();   <span class="comment">//这里我们以毫秒为单位</span></span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> leftTime = time - (System.currentTimeMillis() - startTime); <span class="comment">//计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)</span></span><br><span class="line">        <span class="keyword">return</span> unit.convert(leftTime, TimeUnit.MILLISECONDS);   <span class="comment">//注意进行单位转换，单位由队列指定（默认是纳秒单位）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Test)</span><br><span class="line">            <span class="keyword">return</span> priority - ((Test) o).priority;   <span class="comment">//优先级越小越优先</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们在主方法中尝试使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    DelayQueue&lt;Test&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> Test(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;2号&quot;</span>));   <span class="comment">//1秒钟延时</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Test(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;1号&quot;</span>));   <span class="comment">//1秒钟延时，优先级最高</span></span><br><span class="line"></span><br><span class="line">    System.out.println(queue.take());    <span class="comment">//注意出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期</span></span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来研究一下DelayQueue是如何实现的，首先来看<code>add()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);   <span class="comment">//注意这里是向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;   <span class="comment">//如果入队后队首就是当前元素，那么直接进行一次唤醒操作（因为有可能之前就有其他线程等着take了）</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无论是哪种入队操作，都会加锁进行，属于常规操作。我们接着来看<code>take()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;   <span class="comment">//出队也要先加锁，基操</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环，常规操作</span></span><br><span class="line">            E first = q.peek();    <span class="comment">//获取队首元素</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)     <span class="comment">//如果为空那肯定队列为空，先等着吧，等有元素进来</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);    <span class="comment">//获取延迟，这里传入的时间单位是纳秒</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();     <span class="comment">//如果获取到延迟时间已经小于0了，那说明ok，可以直接出队返回</span></span><br><span class="line">                first = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)   <span class="comment">//这里用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待</span></span><br><span class="line">                    available.await();   <span class="comment">//如果其他线程已经在等元素了，那么当前线程直接进永久等待状态</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;    <span class="comment">//没有线程等待就将leader设定为当前线程</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);     <span class="comment">//获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();   <span class="comment">//当前take结束之后唤醒一个其他永久等待状态下的线程</span></span><br><span class="line">        lock.unlock();   <span class="comment">//解锁，完事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，有关并发容器的讲解就到这里。</p>
<h1 id="三、并发编程进阶"><a href="#三、并发编程进阶" class="headerlink" title="三、并发编程进阶"></a>三、并发编程进阶</h1><p>下面总结线程池以及并发工具类。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在我们的程序中，多多少少都会用到多线程技术，而我们以往都是使用Thread类来创建一个新的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用多线程，我们的程序可以更加合理地使用CPU多核心资源，在同一时间完成更多的工作。但是，如果我们的程序频繁地创建线程，由于线程的创建和销毁也需要占用系统资源，因此这样会降低我们整个程序的性能，那么怎么做，才能更高效地使用多线程呢？</p>
<p>我们其实可以将已创建的线程复用，利用池化技术，就像数据库连接池一样，我们也可以创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p>
<p>虽然听起来这个想法比较新颖，但是实际上线程池早已利用到各个地方，比如我们的Tomcat服务器，要在同一时间接受和处理大量的请求，那么就必须要在短时间内创建大量的线程，结束后又进行销毁，这显然会导致很大的开销，因此这种情况下使用线程池显然是更好的解决方案。</p>
<p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，实际上这里就会用到我们之前讲解的阻塞队列。</p>
<p>所以我们可以暂时得到下面一个样子：</p>
<p>当然，JUC提供的线程池肯定没有这么简单，接下来就让我们深入进行了解。</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>我们可以直接创建一个新的线程池对象，它已经提前帮助我们实现好了线程的调度机制，我们先来看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数稍微有一点多，这里我们依次进行讲解：</p>
<ul>
<li>corePoolSize：<strong>核心线程池大小</strong>，我们每向线程池提交一个多线程任务时，都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。当然也可以在一开始就全部初始化好，调用<code> prestartAllCoreThreads()</code>即可。</li>
<li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且等待队列已满，那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小。</li>
<li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li>
<li>unit：<strong>线程最大空闲时间的时间单位</strong></li>
<li>workQueue：<strong>线程等待队列</strong>，当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列。</li>
<li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li>
<li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理。</li>
</ul>
<p>最为重要的就是线程池大小的限定了，这个也是很有学问的，合理地分配大小会使得线程池的执行效率事半功倍：</p>
<ul>
<li>首先我们可以分析一下，线程池执行任务的特性，是CPU 密集型还是 IO 密集型<ul>
<li><strong>CPU密集型：</strong>主要是执行计算任务，响应时间很快，CPU一直在运行，这种任务CPU的利用率很高，那么线程数应该是根据 CPU 核心数来决定，CPU 核心数 = 最大同时执行线程数，以 i5-9400F 处理器为例，CPU 核心数为 6，那么最多就能同时执行 6 个线程。</li>
<li><strong>IO密集型：</strong>主要是进行 IO 操作，因为执行 IO 操作的时间比较较长，比如从硬盘读取数据之类的，CPU就得等着IO操作，很容易出现空闲状态，导致 CPU 的利用率不高，这种情况下可以适当增加线程池的大小，让更多的线程可以一起进行IO操作，一般可以配置为CPU核心数的2倍。</li>
</ul>
</li>
</ul>
<p>这里我们手动创建一个新的线程池看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>,   <span class="comment">//2个核心线程，最大线程数为4个</span></span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,        <span class="comment">//最大空闲时间为3秒钟</span></span><br><span class="line">                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>));     <span class="comment">//这里使用容量为2的ArrayBlockingQueue队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;   <span class="comment">//开始6个任务</span></span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 开始执行！（&quot;</span>+ finalI);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 已结束！（&quot;</span>+finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="comment">//看看当前线程池中的线程数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);     <span class="comment">//等到超过空闲时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line"></span><br><span class="line">    executor.shutdownNow();    <span class="comment">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span><br><span class="line">  	<span class="comment">//executor.shutdown();     同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们创建了一个核心容量为2，最大容量为4，等待队列长度为2，空闲时间为3秒的线程池，现在我们向其中执行6个任务，每个任务都会进行1秒钟休眠，那么当线程池中2个核心线程都被占用时，还有4个线程就只能进入到等待队列中了，但是等待队列中只有2个容量，这时紧接着的2个任务，线程池将直接尝试创建线程，由于不大于最大容量，因此可以成功创建。最后所有线程完成之后，在等待5秒后，超过了线程池的最大空闲时间，<code>非核心线程</code>被回收了，所以线程池中只有2个线程存在。</p>
<p>那么要是等待队列设定为没有容量的SynchronousQueue呢，这个时候会发生什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 开始执行！（<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 开始执行！（<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 开始执行！（<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 开始执行！（<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task com.test.Main$$Lambda$<span class="number">1</span>/<span class="number">1283928880</span>@682a0b20 rejected from java.util.concurrent.ThreadPoolExecutor@3d075dc0[Running, pool size = <span class="number">4</span>, active threads = <span class="number">4</span>, queued tasks = <span class="number">0</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2063</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">830</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1379</span>)</span><br><span class="line">	at com.test.Main.main(Main.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，前4个任务都可以正常执行，但是到第五个任务时，直接抛出了异常，这其实就是因为等待队列的容量为0，相当于没有容量，那么这个时候，就只能拒绝任务了，拒绝的操作会根据拒绝策略决定。</p>
<p>线程池的拒绝策略默认有以下几个：</p>
<ul>
<li>AbortPolicy(默认)：像上面一样，直接抛异常。</li>
<li>CallerRunsPolicy：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行。</li>
<li>DiscardOldestPolicy：丢弃队列中最近的一个任务，替换为当前任务。</li>
<li>DiscardPolicy：什么也不用做。</li>
</ul>
<p>这里我们进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());   <span class="comment">//使用另一个构造方法，最后一个参数传入策略，比如这里我们使用了CallerRunsPolicy策略</span></span><br></pre></td></tr></table></figure>

<p>CallerRunsPolicy策略是谁提交的谁自己执行，所以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 开始执行！（<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 开始执行！（<span class="number">1</span></span><br><span class="line">main 开始执行！（<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 开始执行！（<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 开始执行！（<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 已结束！（<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 已结束！（<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 已结束！（<span class="number">0</span></span><br><span class="line">main 已结束！（<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 已结束！（<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 开始执行！（<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 已结束！（<span class="number">5</span></span><br><span class="line">线程池中线程数量：<span class="number">4</span></span><br><span class="line">线程池中线程数量：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，当队列塞不下时，直接在主线程运行任务，运行完之后再继续向下执行。</p>
<p>我们吧策略修改为DiscardOldestPolicy试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>),    <span class="comment">//这里设置为ArrayBlockingQueue，长度为1</span></span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());   </span><br></pre></td></tr></table></figure>

<p>它会移除等待队列中的最近的一个任务，所以可以看到有一个任务实际上是被抛弃了的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool-1-thread-1 开始执行！（0</span><br><span class="line">pool-1-thread-4 开始执行！（4</span><br><span class="line">pool-1-thread-3 开始执行！（3</span><br><span class="line">pool-1-thread-2 开始执行！（1</span><br><span class="line">pool-1-thread-1 已结束！（0</span><br><span class="line">pool-1-thread-4 已结束！（4</span><br><span class="line">pool-1-thread-1 开始执行！（5</span><br><span class="line">线程池中线程数量：4</span><br><span class="line">pool-1-thread-3 已结束！（3</span><br><span class="line">pool-1-thread-2 已结束！（1</span><br><span class="line">pool-1-thread-1 已结束！（5</span><br><span class="line">线程池中线程数量：2</span><br></pre></td></tr></table></figure>

<p>比较有意思的是，如果选择没有容量的SynchronousQueue作为等待队列会爆栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 开始执行！（<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 开始执行！（<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 开始执行！（<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 开始执行！（<span class="number">3</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at java.util.concurrent.SynchronousQueue.offer(SynchronousQueue.java:<span class="number">912</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1371</span>)	</span><br><span class="line">	...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 已结束！（<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 已结束！（<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 已结束！（<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 已结束！（<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这是为什么呢？我们来看看这个拒绝策略的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();   <span class="comment">//会先执行一次出队操作，但是这对于SynchronousQueue来说毫无意义</span></span><br><span class="line">            e.execute(r);     <span class="comment">//这里会再次调用execute方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它会先对等待队列进行出队操作，但是由于SynchronousQueue压根没容量，所有这个操作毫无意义，然后就会递归执行<code>execute</code>方法，而进入之后，又发现没有容量不能插入，于是又重复上面的操作，这样就会无限的递归下去，最后就爆栈了。</p>
<p>当然，除了使用官方提供的4种策略之外，我们还可以使用自定义的策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class="line">                    (r, executor1) -&gt; &#123;   <span class="comment">//比如这里我们也来实现一个就在当前线程执行的策略</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;哎呀，线程池和等待队列都满了，你自己耗子尾汁吧&quot;</span>);</span><br><span class="line">                        r.run();   <span class="comment">//直接运行</span></span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure>

<p>接着我们来看线程创建工厂，我们可以自己决定如何创建新的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class="line">                    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;我的自定义线程-&quot;</span>+counter++);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        executor.execute(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 开始执行！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的Runnable对象就是我们提交的任务，可以看到需要我们返回一个Thread对象，其实就是线程池创建线程的过程，而如何创建这个对象，以及它的一些属性，就都由我们来决定。</p>
<p>各位有没有想过这样一个情况，如果我们的任务在运行过程中出现异常了，那么是不是会导致线程池中的线程被销毁呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,   <span class="comment">//最大容量和核心容量锁定为1</span></span><br><span class="line">            <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是异常！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，出现异常之后，再次提交新的任务，执行的线程是一个新的线程了。</p>
<p>除了我们自己创建线程池之外，官方也提供了很多的线程池定义，我们可以使用<code>Executors</code>工具类来快速创建线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);   <span class="comment">//直接创建一个固定容量的线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的内部实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接将最大线程和核心线程数量设定为一样的，并且等待时间为0，因为压根不需要，并且采用的是一个无界的LinkedBlockingQueue作为等待队列。</p>
<p>使用newSingleThreadExecutor来创建只有一个线程的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">//创建一个只有一个线程的线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里并不是直接创建的一个ThreadPoolExecutor对象，而是套了一层FinalizableDelegatedExecutorService，那么这个又是什么东西呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizableDelegatedExecutorService</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">DelegatedExecutorService</span> </span>&#123;</span><br><span class="line">    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;    <span class="comment">//在GC时，会执行finalize方法，此方法中会关闭掉线程池，释放资源</span></span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;    <span class="comment">//被委派对象</span></span><br><span class="line">    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;   <span class="comment">//实际上所以的操作都是让委派对象执行的，有点像代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; e.shutdown(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.shutdownNow(); &#125;</span><br></pre></td></tr></table></figure>

<p>所以，下面两种写法的区别在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor1 = Executors.newSingleThreadExecutor();</span><br><span class="line">    ExecutorService executor2 = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前者实际上是被代理了，我们没办法直接修改前者的相关属性，显然使用前者创建只有一个线程的线程池更加专业和安全（可以防止属性被修改）一些。</p>
<p>最后我们来看<code>newCachedThreadPool</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//它是一个会根据需要无限制创建新线程的线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看它的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，核心线程数为0，那么也就是说所有的线程都是<code>非核心线程</code>，也就是说线程空闲时间超过1秒钟，一律销毁。但是它的最大容量是<code>Integer.MAX_VALUE</code>，也就是说，它可以无限制地增长下去，所以这玩意一定要慎用。</p>
<h3 id="执行带返回值的任务"><a href="#执行带返回值的任务" class="headerlink" title="执行带返回值的任务"></a>执行带返回值的任务</h3><p>一个多线程任务不仅仅可以是void无返回值任务，比如我们现在需要执行一个任务，但是我们需要在任务执行之后得到一个结果，这个时候怎么办呢？</p>
<p>这里我们就可以使用到Future了，它可以返回任务的计算结果，我们可以通过它来获取任务的结果以及任务当前是否完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();   <span class="comment">//直接用Executors创建，方便就完事了</span></span><br><span class="line">    Future&lt;String&gt; future = executor.submit(() -&gt; <span class="string">&quot;我是字符串!&quot;</span>);     <span class="comment">//使用submit提交任务，会返回一个Future对象，注意提交的对象可以是Runable也可以是Callable，这里使用的是Callable能够自定义返回值</span></span><br><span class="line">    System.out.println(future.get());    <span class="comment">//如果任务未完成，get会被阻塞，任务完成返回Callable执行结果返回值</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然结果也可以一开始就定义好，然后等待Runnable执行完之后再返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;我是字符串！&quot;</span>);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过传入FutureTask对象的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; <span class="string">&quot;我是字符串！&quot;</span>);</span><br><span class="line">    service.submit(task);</span><br><span class="line">    System.out.println(task.get());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以还通过Future对象获取当前任务的一些状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;String&gt; future = executor.submit(() -&gt; <span class="string">&quot;都看到这里了，不赏UP主一个一键三连吗？&quot;</span>);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务是否执行完成：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务是否被取消：&quot;</span>+future.isCancelled());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试看在任务执行途中取消任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这次一定！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.cancel(<span class="keyword">true</span>));</span><br><span class="line">    System.out.println(future.isCancelled());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行定时任务"><a href="#执行定时任务" class="headerlink" title="执行定时任务"></a>执行定时任务</h3><p>既然线程池怎么强大，那么线程池能不能执行定时任务呢？我们之前如果需要执行一个定时任务，那么肯定会用到Timer和TimerTask，但是它只会创建一个线程处理我们的定时任务，无法实现多线程调度，并且它无法处理异常情况一旦抛出未捕获异常那么会直接终止，显然我们需要一个更加强大的定时器。</p>
<p>JDK5之后，我们可以使用ScheduledThreadPoolExecutor来提交定时任务，它继承自ThreadPoolExecutor，并且所有的构造方法都必须要求最大线程池容量为Integer.MAX_VALUE，并且都是采用的DelayedWorkQueue作为等待队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下它的方法，这个方法可以提交一个延时任务，只有到达指定时间之后才会开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">//直接设定核心线程数为1</span></span><br><span class="line">    ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里我们计划在3秒后执行</span></span><br><span class="line">    executor.schedule(() -&gt; System.out.println(<span class="string">&quot;HelloWorld!&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以像之前一样，传入一个Callable对象，用于接收返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>);</span><br><span class="line">  	<span class="comment">//这里使用ScheduledFuture</span></span><br><span class="line">    ScheduledFuture&lt;String&gt; future = executor.schedule(() -&gt; <span class="string">&quot;????&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务剩余等待时间：&quot;</span>+future.getDelay(TimeUnit.MILLISECONDS) / <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务执行结果：&quot;</span>+future.get());</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>schedule</code>方法返回了一个ScheduledFuture对象，和Future一样，它也支持返回值的获取、包括对任务的取消同时还支持获取剩余等待时间。</p>
<p>那么如果我们希望按照一定的频率不断执行任务呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>);</span><br><span class="line">    executor.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>),</span><br><span class="line">            <span class="number">3</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  	<span class="comment">//三秒钟延迟开始，之后每隔一秒钟执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executors也为我们预置了newScheduledThreadPool方法用于创建线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    service.schedule(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p>前面我们了解了线程池的使用，那么接着我们来看看它的详细实现过程，结构稍微有点复杂，坐稳，发车了。</p>
<p>这里需要首先介绍一下ctl变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span></span><br><span class="line"><span class="comment">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量（那要是工作线程数量29位装不下不就GG？）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;    <span class="comment">//29位，线程数量位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;   <span class="comment">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运行状态，注意都是只占用前3位，不会占用后29位</span></span><br><span class="line"><span class="comment">// 接收新任务，并等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//111 | 0000... (后29数量位，下同)</span></span><br><span class="line"><span class="comment">// 不接收新任务，但是依然等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">//000 | 数量位</span></span><br><span class="line"><span class="comment">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//001 | 数量位</span></span><br><span class="line"><span class="comment">// 所有的任务都已结束，线程数量为0，即将完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">//010 | 数量位</span></span><br><span class="line"><span class="comment">// 完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">//011 | 数量位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装和解析ctl变量的一些方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;   <span class="comment">//对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//同上，这里是为了得到后29位的结果，所以这里是取线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   </span><br><span class="line"><span class="comment">// 比如上面的RUNNING, 0，进行与运算之后：</span></span><br><span class="line"><span class="comment">// 111 | 0000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>我们先从最简单的入手，看看在调用<code>execute</code>方法之后，线程池会做些什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个就是我们指定的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次提醒，这里没加锁！！该有什么意识不用我说了吧，所以说ctl才会使用原子类。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();     <span class="comment">//如果任务为null，那执行个寂寞，所以说直接空指针</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();      <span class="comment">//获取ctl的值，一会要读取信息的</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;   <span class="comment">//判断工作线程数量是否小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))    <span class="comment">//如果是，那不管三七二十一，直接加新的线程执行，然后返回即可</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();    <span class="comment">//如果线程添加失败（有可能其他线程也在对线程池进行操作），那就更新一下c的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   <span class="comment">//继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();   <span class="comment">//再次获取ctl的值</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))   <span class="comment">//这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span><br><span class="line">            reject(command);   <span class="comment">//然后直接拒绝当前任务的提交（会根据我们的拒绝策略决定如何进行拒绝操作）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)   <span class="comment">//如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);   <span class="comment">//添加一个新的非核心线程，但是注意没添加任务</span></span><br><span class="line">      	<span class="comment">//其他情况就啥也不用做了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))   <span class="comment">//这种情况要么就是线程池没有运行，要么就是队列满了，按照我们之前的规则，核心线程数已满且队列已满，那么会直接添加新的非核心线程，但是如果已经添加到最大数量，这里肯定是会失败的</span></span><br><span class="line">        reject(command);   <span class="comment">//确实装不下了，只能拒绝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉思路还挺清晰的，我们接着来看<code>addWorker</code>是怎么创建和执行任务的，又是一大堆代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//这里给最外层循环打了个标签，方便一会的跳转操作</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环，老套路了，注意这里全程没加锁</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();     <span class="comment">//获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);    <span class="comment">//解析当前的运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;   <span class="comment">//判断线程池是否不是处于运行状态</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;   <span class="comment">//如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span></span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;   </span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;   <span class="comment">//内层又一轮无限循环，这个循环是为了将线程计数增加，然后才可以真正地添加一个新的线程</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);    <span class="comment">//解析当前的工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))    <span class="comment">//判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))    <span class="comment">//CAS自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span><br><span class="line">                <span class="keyword">break</span> retry;    <span class="comment">//注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// 如果CAS失败，更新一下c的值</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)    <span class="comment">//如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span><br><span class="line">                <span class="keyword">continue</span> retry;    <span class="comment">//注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            <span class="comment">// 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//好了，线程计数自增也完了，接着就是添加新的工作线程了</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;   <span class="comment">//工作线程是否已启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;    <span class="comment">//工作线程是否已添加</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;     <span class="comment">//暂时理解为工作线程，别急，我们之后会解读Worker类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);     <span class="comment">//创建新的工作线程，传入我们提交的任务</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;    <span class="comment">//拿到工作线程中封装的Thread对象</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;      <span class="comment">//如果线程不为null，那就可以安排干活了</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;      <span class="comment">//又是ReentrantLock加锁环节，这里开始就是只有一个线程能进入了</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());    <span class="comment">//获取当前线程的运行状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;    <span class="comment">//只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 检查一下线程是否正在运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();   <span class="comment">//如果是那肯定是不能运行我们的任务的</span></span><br><span class="line">                    workers.add(w);    <span class="comment">//直接将新创建的Work丢进 workers 集合中</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();   <span class="comment">//看看当前workers的大小</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)   <span class="comment">//这里是记录线程池运行以来，历史上的最多线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;   <span class="comment">//工作线程已添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();   <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();   <span class="comment">//启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;  <span class="comment">//工作线程已启动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)    <span class="comment">//如果线程在上面的启动过程中失败了</span></span><br><span class="line">            addWorkerFailed(w);    <span class="comment">//将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;   <span class="comment">//返回是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看Worker类是如何实现的，它继承自AbstractQueuedSynchronizer，时隔两章，居然再次遇到AQS，那也就是说，它本身就是一把锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用来干活的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//要执行的第一个任务，构造时就确定了的</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//干活数量计数器，也就是这个线程完成了多少个任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 执行Task之前不让中断，将AQS的state设定为-1</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">//通过预定义或是我们自定义的线程工厂创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);   <span class="comment">//真正开始干活，包括当前活干完了又要等新的活来，就从这里开始，一会详细介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//0就是没加锁，1就是已加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看一个Worker到底是怎么在进行任务的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();   <span class="comment">//获取当前线程</span></span><br><span class="line">    Runnable task = w.firstTask;    <span class="comment">//取出要执行的任务</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;   <span class="comment">//然后把Worker中的任务设定为null</span></span><br><span class="line">    w.unlock(); <span class="comment">// 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();    <span class="comment">//对当前Worker加锁，这里其实并不是防其他线程，而是在shutdown时保护此任务的运行</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||   <span class="comment">//只要线程池是STOP及以上的状态，那肯定是不能开始新任务的</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;    					 <span class="comment">//线程是否已经被打上中断标记并且线程一定是STOP及以上</span></span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())   <span class="comment">//再次确保线程被没有打上中断标记</span></span><br><span class="line">                wt.interrupt();     <span class="comment">//打中断标记</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);  <span class="comment">//开始之前的准备工作，这里暂时没有实现</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();    <span class="comment">//OK，开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);    <span class="comment">//执行之后的工作，也没实现</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;    <span class="comment">//任务已完成，不需要了</span></span><br><span class="line">                w.completedTasks++;   <span class="comment">//任务完成数++</span></span><br><span class="line">                w.unlock();    <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了</span></span><br><span class="line">      	<span class="comment">//所以这里会直接将 Worker 从 workers 里删除掉</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它是怎么从阻塞队列里面获取任务的呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环获取</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();   <span class="comment">//获取ctl </span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);      <span class="comment">//解析线程池运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;      <span class="comment">//判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span><br><span class="line">            decrementWorkerCount();     <span class="comment">//直接减少一个工作线程数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//返回null，这样上面的runWorker就直接结束了，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);   <span class="comment">//如果线程池运行正常，那就获取当前的工作线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;   <span class="comment">//如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))   <span class="comment">//如果CAS减少工作线程成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//返回null</span></span><br><span class="line">            <span class="keyword">continue</span>;   <span class="comment">//否则开下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">//如果可超时，那么最多等到超时时间</span></span><br><span class="line">                workQueue.take();    <span class="comment">//如果不可超时，那就一直等着拿任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)    <span class="comment">//如果成功拿到任务，ok，返回</span></span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;   <span class="comment">//否则就是超时了，下一轮循环将直接返回null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//开下一轮循环吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们的源码解读越来越深，但是只要各位的思路不断，依然是可以继续往下看的。到此，有关<code>execute()</code>方法的源码解读，就先到这里。</p>
<p>接着我们来看当线程池关闭时会做什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//判断是否有权限终止</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      	<span class="comment">//CAS将线程池运行状态改为SHUTDOWN状态，还算比较温柔，详细过程看下面</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">       	<span class="comment">//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程，详细过程请看下面</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();   <span class="comment">//最后尝试终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();    <span class="comment">//获取ctl</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||    <span class="comment">//是否大于等于指定的状态</span></span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))   <span class="comment">//CAS设置ctl的值</span></span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//任意一个条件OK就可以结束了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;    <span class="comment">//拿到Worker中的线程</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;   <span class="comment">//先判断一下线程是不是没有被中断然后尝试加锁，但是通过前面的runWorker()源代码我们得知，开始之后是让Worker加了锁的，所以如果线程还在执行任务，那么这里肯定会false</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();    <span class="comment">//如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断吧</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();    <span class="comment">//解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)   <span class="comment">//如果只针对一个Worker，那么就结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>shutdownNow()</code>方法也差不多，但是这里会更直接一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      	<span class="comment">//这里就是直接设定为STOP状态了，不再像shutdown那么温柔</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">      	<span class="comment">//直接中断所有工作线程，详细过程看下面</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">      	<span class="comment">//取出仍处于阻塞队列中的线程</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;   <span class="comment">//最后返回还没开始的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)   <span class="comment">//遍历所有Worker</span></span><br><span class="line">            w.interruptIfStarted();   <span class="comment">//无差别对待，一律加中断标记</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的最后，我们再来看看<code>tryTerminate()</code>是怎么完完全全终止掉一个线程池的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;     <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();    <span class="comment">//上来先获取一下ctl值</span></span><br><span class="line">      	<span class="comment">//只要是正在运行 或是 线程池基本上关闭了 或是 处于SHUTDOWN状态且工作队列不为空，那么这时还不能关闭线程池，返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//走到这里，要么处于SHUTDOWN状态且等待队列为空或是STOP状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 如果工作线程数不是0，这里也会中断空闲状态下的线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);   <span class="comment">//这里最多只中断一个空闲线程，然后返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//走到这里，工作线程也为空了，可以终止线程池了</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;   <span class="comment">//先CAS将状态设定为TIDYING表示基本终止，正在做最后的操作</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();   <span class="comment">//终止，暂时没有实现</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));   <span class="comment">//最后将状态设定为TERMINATED，线程池结束了它年轻的生命</span></span><br><span class="line">                    termination.signalAll();    <span class="comment">//如果有线程调用了awaitTermination方法，会等待当前线程池终止，到这里差不多就可以唤醒了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;   <span class="comment">//结束</span></span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//注意如果CAS失败会直接进下一轮循环重新判断</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，有关线程池的实现原理，我们就暂时先介绍到这里，关于更高级的定时任务线程池，这里就不做讲解了。</p>
<hr>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="计数器锁-CountDownLatch"><a href="#计数器锁-CountDownLatch" class="headerlink" title="计数器锁 CountDownLatch"></a>计数器锁 CountDownLatch</h3><p>多任务同步神器。它允许一个或多个线程，等待其他线程完成工作，比如现在我们有这样的一个需求：</p>
<ul>
<li>有20个计算任务，我们需要先将这些任务的结果全部计算出来，每个任务的执行时间未知</li>
<li>当所有任务结束之后，立即整合统计最终结果</li>
</ul>
<p>要实现这个需求，那么有一个很麻烦的地方，我们不知道任务到底什么时候执行完毕，那么可否将最终统计延迟一定时间进行呢？但是最终统计无论延迟多久进行，要么不能保证所有任务都完成，要么可能所有任务都完成了而这里还在等。</p>
<p>所以说，我们需要一个能够实现子任务同步的工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);  <span class="comment">//创建一个初始值为10的计数器锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> Random().nextDouble()));</span><br><span class="line">                System.out.println(<span class="string">&quot;子任务&quot;</span>+ finalI +<span class="string">&quot;执行完成！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();   <span class="comment">//每执行一次计数器都会-1</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始等待所有的线程完成，当计数器为0时，恢复运行</span></span><br><span class="line">    latch.await();   <span class="comment">//这个操作可以同时被多个线程执行，一起等待，这里只演示了一个</span></span><br><span class="line">    System.out.println(<span class="string">&quot;所有子任务都完成！任务完成！！！&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在调用<code>await()</code>方法之后，实际上就是一个等待计数器衰减为0的过程，而进行自减操作则由各个子线程来完成，当子线程完成工作后，那么就将计数器-1，所有的子线程完成之后，计数器为0，结束等待。</p>
<p>那么它是如何实现的呢？实现 原理非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//同样是通过内部类实现AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;   <span class="comment">//这里直接使用AQS的state作为计数器（可见state能被玩出各种花样），也就是说一开始就加了count把共享锁，当线程调用countdown时，就解一层锁</span></span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//采用共享锁机制，因为可以被不同的线程countdown，所以实现的tryAcquireShared和tryReleaseShared</span></span><br><span class="line">      	<span class="comment">//获取这把共享锁其实就是去等待state被其他线程减到0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 每次执行都会将state值-1，直到为0</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//如果已经是0了，那就false</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))   <span class="comment">//CAS设置state值，失败直接下一轮循环</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;    <span class="comment">//返回c-1之后，是不是0，如果是那就true，否则false，也就是说只有刚好减到0的时候才会返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);  <span class="comment">//count那肯定不能小于0啊</span></span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);   <span class="comment">//构造Sync对象，将count作为state初始值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//通过acquireSharedInterruptibly方法获取共享锁，但是如果state不为0，那么会被持续阻塞，详细原理下面讲</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上，但是会超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//countDown其实就是解锁一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的计数，也就是AQS中state的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个就不说了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot;[Count = &quot;</span> + sync.getCount() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在深入讲解之前，我们先大致了解一下CountDownLatch的基本实现思路：</p>
<ul>
<li>利用共享锁实现</li>
<li>在一开始的时候就是已经上了count层锁的状态，也就是<code>state = count</code></li>
<li><code>await()</code>就是加共享锁，但是必须<code>state</code>为<code>0</code>才能加锁成功，否则按照AQS的机制，会进入等待队列阻塞，加锁成功后结束阻塞</li>
<li><code>countDown()</code>就是解<code>1</code>层锁，也就是靠这个方法一点一点把<code>state</code>的值减到<code>0</code></li>
</ul>
<p>由于我们前面只对独占锁进行了讲解，没有对共享锁进行讲解，这里还是稍微提一下它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)   <span class="comment">//上来就调用tryAcquireShared尝试以共享模式获取锁，小于0则失败，上面判断的是state==0返回1，否则-1，也就是说如果计数器不为0，那么这里会判断成功</span></span><br><span class="line">        doAcquireShared(arg);   <span class="comment">//计数器不为0的时候，按照它的机制，那么会阻塞，所以我们来看看doAcquireShared中是怎么进行阻塞的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);   <span class="comment">//向等待队列中添加一个新的共享模式结点</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">//获取当前节点的前驱的结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;    <span class="comment">//如果p就是头结点，那么说明当前结点就是第一个等待节点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);    <span class="comment">//会再次尝试获取共享锁</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;      <span class="comment">//要是获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);   <span class="comment">//那么就将当前节点设定为新的头结点，并且会继续唤醒后继节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">//和独占模式下一样的操作，这里不多说了</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);   <span class="comment">//如果最后都还是没获取到，那么就cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实感觉大体上和独占模式的获取有点像，但是它多了个传播机制，会继续唤醒后续节点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 取出头结点并将当前节点设定为新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//因为一个线程成功获取到共享锁之后，有可能剩下的等待中的节点也有机会拿到共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;   <span class="comment">//如果propagate大于0（表示共享锁还能继续获取）或是h.waitStatus &lt; 0，这是由于在其他线程释放共享锁时，doReleaseShared会将状态设定为PROPAGATE表示可以传播唤醒，后面会讲</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();   <span class="comment">//继续唤醒下一个等待节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看，它的countdown过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;   <span class="comment">//直接尝试释放锁，如果成功返回true（在CountDownLatch中只有state减到0的那一次，会返回true）</span></span><br><span class="line">        doReleaseShared();    <span class="comment">//这里也会调用doReleaseShared继续唤醒后面的结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//其他情况false</span></span><br><span class="line">  									<span class="comment">//不过这里countdown并没有用到这些返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;   <span class="comment">//无限循环</span></span><br><span class="line">        Node h = head;    <span class="comment">//获取头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;    <span class="comment">//如果头结点不为空且头结点不是尾结点，那么说明等待队列中存在节点</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;    <span class="comment">//取一下头结点的等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;    <span class="comment">//如果是SIGNAL，那么就CAS将头结点的状态设定为初始值</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">//失败就开下一轮循环重来</span></span><br><span class="line">                unparkSuccessor(h);    <span class="comment">//和独占模式一样，当锁被释放，都会唤醒头结点的后继节点，doAcquireShared循环继续，如果成功，那么根据setHeadAndPropagate，又会继续调用当前方法，不断地传播下去，让后面的线程一个一个地获取到共享锁，直到不能再继续获取为止</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))   <span class="comment">//如果等待状态是默认值0，那么说明后继节点已经被唤醒，直接将状态设定为PROPAGATE，它代表在后续获取资源的时候，够向后面传播</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">//失败就开下一轮循环重来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// 如果头结点发生了变化，不会break，而是继续循环，否则直接break退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能看完之后还是有点乱，我们再来理一下：</p>
<ul>
<li>共享锁是线程共享的，同一时刻能有多个线程拥有共享锁。</li>
<li>如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁，所以得传播下去继续尝试唤醒后面的结点，不像独占锁，独占的压根不需要考虑这些。</li>
<li>如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒后续等待结点的线程。</li>
</ul>
<p>回到CountDownLatch，再结合整个AQS共享锁的实现机制，进行一次完整的推导，看明白还是比较简单的。</p>
<h3 id="循环屏障-CyclicBarrier"><a href="#循环屏障-CyclicBarrier" class="headerlink" title="循环屏障 CyclicBarrier"></a>循环屏障 CyclicBarrier</h3><p>好比一场游戏，我们必须等待房间内人数足够之后才能开始，并且游戏开始之后玩家需要同时进入游戏以保证公平性。</p>
<p>假如现在游戏房间内一共5人，但是游戏开始需要10人，所以我们必须等待剩下5人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入，那么怎么实现这个功能呢？我们可以使用CyclicBarrier，翻译过来就是循环屏障，那么这个屏障正式为了解决这个问题而出现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>,   <span class="comment">//创建一个初始值为10的循环屏障</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;</span>));   <span class="comment">//人等够之后执行的任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> Random().nextDouble()));</span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入房间进行等待... (&quot;</span>+barrier.getNumberWaiting()+<span class="string">&quot;/10)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                barrier.await();    <span class="comment">//调用await方法进行等待，直到等待的线程足够多为止</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//开始游戏，所有玩家一起进入游戏</span></span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入游戏！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，循环屏障会不断阻挡线程，直到被阻挡的线程足够多时，才能一起冲破屏障，并且在冲破屏障时，我们也可以做一些其他的任务。这和人多力量大的道理是差不多的，当人足够多时方能冲破阻碍，到达美好的明天。当然，屏障由于是可循环的，所以它在被冲破后，会重新开始计数，继续阻挡后续的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);  <span class="comment">//创建一个初始值为5的循环屏障</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   <span class="comment">//创建5个线程</span></span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> Random().nextDouble()));</span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入房间进行等待... (&quot;</span>+barrier.getNumberWaiting()+<span class="string">&quot;/5)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                barrier.await();    <span class="comment">//调用await方法进行等待，直到等待线程到达5才会一起继续执行</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//人数到齐之后，可以开始游戏了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入游戏！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用循环屏障，我们可以对线程进行一波一波地放行，每一波都放行5个线程，当然除了自动重置之外，我们也可以调用<code>reset()</code>方法来手动进行重置操作，同样会重新计数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);  <span class="comment">//创建一个初始值为10的计数器锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);   <span class="comment">//等一下上面的线程开始运行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line"></span><br><span class="line">    barrier.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;重置后屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在调用<code>reset()</code>之后，处于等待状态下的线程，全部被中断并且抛出BrokenBarrierException异常，循环屏障等待线程数归零。那么要是处于等待状态下的线程被中断了呢？屏障的线程等待数量会不会自动减少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    t.start();</span><br><span class="line">    t.interrupt();</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当<code>await()</code>状态下的线程被中断，那么屏障会直接变成损坏状态，一旦屏障损坏，那么这一轮就无法再做任何等待操作了。也就是说，本来大家计划一起合力冲破屏障，结果有一个人摆烂中途退出了，那么所有人的努力都前功尽弃，这一轮的屏障也不可能再被冲破了（所以CyclicBarrier告诉我们，不要做那个害群之马，要相信你的团队，不然没有好果汁吃），只能进行<code>reset()</code>重置操作进行重置才能恢复正常。</p>
<p>乍一看，怎么感觉和之前讲的CountDownLatch有点像，好了，这里就得区分一下了，千万别搞混：</p>
<ul>
<li>CountDownLatch：<ol>
<li>它只能使用一次，是一个一次性的工具</li>
<li>它是一个或多个线程用于等待其他线程完成的同步工具</li>
</ol>
</li>
<li>CyclicBarrier<ol>
<li>它可以反复使用，允许自动或手动重置计数</li>
<li>它是让一定数量的线程在同一时间开始运行的同步工具</li>
</ol>
</li>
</ul>
<p>我们接着来看循环屏障的实现细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内部类，存放broken标记，表示屏障是否损坏，损坏的屏障是无法正常工作的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 内部维护一个可重入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** 再维护一个Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** 这个就是屏障的最大阻挡容量，就是构造方法传入的初始值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* 在屏障破裂时做的事情 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** 当前这一轮的Generation对象，每一轮都有一个新的，用于保存broken标记 */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认为最大阻挡容量，每来一个线程-1，和CountDownLatch挺像，当屏障破裂或是被重置时，都会将其重置为最大阻挡容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//构造方法</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开启下一轮屏障，一般屏障被冲破之后，就自动重置了，进入到下一轮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 唤醒所有等待状态的线程</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// 重置count的值</span></span><br><span class="line">        count = parties;</span><br><span class="line">      	<span class="comment">//创建新的Generation对象</span></span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//破坏当前屏障，变为损坏状态，之后就不能再使用了，除非重置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        generation.broken = <span class="keyword">true</span>;</span><br><span class="line">        count = parties;</span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//开始等待</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// 因为这里没有使用定时机制，不可能发生异常，如果发生怕是出了错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//可超时的等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是真正的等待流程了，让我们细细道来</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();   <span class="comment">//加锁，注意，因为多个线程都会调用await方法，因此只有一个线程能进，其他都被卡着了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;   <span class="comment">//获取当前这一轮屏障的Generation对象</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();   <span class="comment">//如果这一轮屏障已经损坏，那就没办法使用了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;   <span class="comment">//如果当前等待状态的线程被中断，那么会直接破坏掉屏障，并抛出中断异常（破坏屏障的第1种情况）</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;     <span class="comment">//如果上面都没有出现不正常，那么就走正常流程，首先count自减并赋值给index，index表示当前是等待的第几个线程</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 如果自减之后就是0了，那么说明来的线程已经足够，可以冲破屏障了</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();   <span class="comment">//执行冲破屏障后的任务，如果这里抛异常了，那么会进finally</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();   <span class="comment">//一切正常，开启下一轮屏障（方法进入之后会唤醒所有等待的线程，这样所有的线程都可以同时继续运行了）然后返回0，注意最下面finally中会解锁，不然其他线程唤醒了也拿不到锁啊</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)   <span class="comment">//如果是上面出现异常进来的，那么也会直接破坏屏障（破坏屏障的第2种情况）</span></span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能走到这里，那么说明当前等待的线程数还不够多，不足以冲破屏障</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;   <span class="comment">//无限循环，一直等，等到能冲破屏障或是出现异常为止</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();    <span class="comment">//如果不是定时的，那么就直接永久等待</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);   <span class="comment">//否则最多等一段时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;    <span class="comment">//等的时候会判断是否被中断（依然是破坏屏障的第1种情况）</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();   <span class="comment">//如果线程被唤醒之后发现屏障已经被破坏，那么直接抛异常</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)   <span class="comment">//成功冲破屏障开启下一轮，那么直接返回当前是第几个等待的线程。</span></span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;   <span class="comment">//线程等待超时，也会破坏屏障（破坏屏障的第3种情况）然后抛异常</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">//最后别忘了解锁，不然其他线程拿不到锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//不多说了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//判断是否被破坏，也是加锁访问，因为有可能这时有其他线程正在执行dowait</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> generation.broken;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//重置操作，也要加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// 先破坏这一轮的线程，注意这个方法会先破坏再唤醒所有等待的线程，那么所有等待的线程会直接抛BrokenBarrierException异常（详情请看上方dowait倒数第13行）</span></span><br><span class="line">            nextGeneration(); <span class="comment">// 开启下一轮</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//获取等待线程数量，也要加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;   <span class="comment">//最大容量 - 当前剩余容量 = 正在等待线程数</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了CyclicBarrier的源码之后，是不是感觉比CountDownLatch更简单一些？</p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>还记得我们在《操作系统》中学习的信号量机制吗？它在解决进程之间的同步问题中起着非常大的作用。</p>
<blockquote>
<p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</p>
</blockquote>
<p>通过使用信号量，我们可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（因此也支持公平和非公平模式），我们可以在最开始设定Semaphore的许可证数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);   <span class="comment">//许可证配额设定为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();   <span class="comment">//申请一个许可证</span></span><br><span class="line">                System.out.println(<span class="string">&quot;许可证申请成功！&quot;</span>);</span><br><span class="line">                semaphore.release();   <span class="comment">//归还一个许可证</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);   <span class="comment">//许可证配额设定为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(<span class="number">2</span>);    <span class="comment">//一次性申请两个许可证</span></span><br><span class="line">                System.out.println(<span class="string">&quot;许可证申请成功！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以通过Semaphore获取一些常规信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);   <span class="comment">//只配置一个许可证，5个线程进行争抢，不内卷还想要许可证？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> Thread(semaphore::acquireUninterruptibly).start();   <span class="comment">//可以以不响应中断（主要是能简写一行，方便）</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;剩余许可证数量：&quot;</span>+semaphore.availablePermits());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否存在线程等待许可证：&quot;</span>+(semaphore.hasQueuedThreads() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;等待许可证线程数量：&quot;</span>+semaphore.getQueueLength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以手动回收掉所有的许可证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(semaphore::acquireUninterruptibly).start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;收回剩余许可数量：&quot;</span>+semaphore.drainPermits());   <span class="comment">//直接回收掉剩余的许可证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们模拟一下，比如现在有10个线程同时进行任务，任务要求是执行某个方法，但是这个方法最多同时只能由5个线程执行，这里我们使用信号量就非常合适。</p>
<h3 id="数据交换-Exchanger"><a href="#数据交换-Exchanger" class="headerlink" title="数据交换 Exchanger"></a>数据交换 Exchanger</h3><p>线程之间的数据传递也可以这么简单。</p>
<p>使用Exchanger，它能够实现线程之间的数据交换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到主线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;AAAA&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;收到子线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;BBBB&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。</p>
<p>可见功能还是比较简单的。</p>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>在JDK7时，出现了一个新的框架用于并行执行任务，它的目的是为了把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果，并且这些小任务都是同时在进行，大大提高运算效率。Fork就是拆分，Join就是合并。</p>
<p>我们来演示一下实际的情况，比如一个算式：18x7+36x8+9x77+8x53，可以拆分为四个小任务：18x7、36x8、9x77、8x53，最后我们只需要将这四个任务的结果加起来，就是我们原本算式的结果了，有点归并排序的味道。</p>
<p>它不仅仅只是拆分任务并使用多线程，而且还可以利用工作窃取算法，提高线程的利用率。</p>
<blockquote>
<p><strong>工作窃取算法：</strong>是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p>
</blockquote>
<p>现在我们来看看如何使用它，这里以计算1-1000的和为例，我们可以将其拆分为8个小段的数相加，比如1-125、126-250… ，最后再汇总即可，它也是依靠线程池来实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        System.out.println(pool.submit(<span class="keyword">new</span> SubTask(<span class="number">1</span>, <span class="number">1000</span>)).get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;   <span class="comment">//比如我们要计算一个范围内所有数的和，那么就需要限定一下范围，这里用了两个int存放</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start &gt; <span class="number">125</span>) &#123;    <span class="comment">//每个任务最多计算125个数的和，如果大于继续拆分，小于就可以开始算了</span></span><br><span class="line">                SubTask subTask1 = <span class="keyword">new</span> SubTask(start, (end + start) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork();    <span class="comment">//会继续划分子任务执行</span></span><br><span class="line">                SubTask subTask2 = <span class="keyword">new</span> SubTask((end + start) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">                subTask2.fork();   <span class="comment">//会继续划分子任务执行</span></span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();   <span class="comment">//越玩越有递归那味了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 开始计算 &quot;</span>+start+<span class="string">&quot;-&quot;</span>+end+<span class="string">&quot; 的值!&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                    res += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;   <span class="comment">//返回的结果会作为join的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ForkJoinPool-1-worker-2 开始计算 1-125 的值!</span><br><span class="line">ForkJoinPool-1-worker-2 开始计算 126-250 的值!</span><br><span class="line">ForkJoinPool-1-worker-0 开始计算 376-500 的值!</span><br><span class="line">ForkJoinPool-1-worker-6 开始计算 751-875 的值!</span><br><span class="line">ForkJoinPool-1-worker-3 开始计算 626-750 的值!</span><br><span class="line">ForkJoinPool-1-worker-5 开始计算 501-625 的值!</span><br><span class="line">ForkJoinPool-1-worker-4 开始计算 251-375 的值!</span><br><span class="line">ForkJoinPool-1-worker-7 开始计算 876-1000 的值!</span><br><span class="line">500500</span><br></pre></td></tr></table></figure>

<p>可以看到，结果非常正确，但是整个计算任务实际上是拆分为了8个子任务同时完成的，结合多线程，原本的单线程任务，在多线程的加持下速度成倍提升。</p>
<p>包括Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJByte.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">byte</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">             ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">             MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并行排序的性能在多核心CPU环境下，肯定是优于普通排序的，并且排序规模越大优势越显著。</p>
<p>至此，并发编程篇完结。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
