<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>由Hexo Next搭建的博客网站，这是第一篇博客！</p>
<p>文章将有以下分类：工具、技术、笔记、思考、生活、阅读</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows和IDEA的常用快捷键</title>
    <url>/posts/bde9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>博主作为一个Java后端攻城狮，开发过程中不免要使用许多的快捷键。合理使用快捷键能极大提高工作效率，那么这么多的快捷键又该记住哪些呢，把所有快捷键都记下显然是不太现实的。因此我根据平时的使用习惯，总结了自己在Windows和IDEA中常用的快捷键。</p>
</blockquote>
<span id="more"></span>

<h1 id="Windows快捷键"><a href="#Windows快捷键" class="headerlink" title="Windows快捷键"></a>Windows快捷键</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>win</td>
<td>打开开始菜单</td>
</tr>
<tr>
<td>win + d</td>
<td>缩小所有窗口</td>
</tr>
<tr>
<td>win + a</td>
<td>打开右侧通知栏(可连wifi、蓝牙等)</td>
</tr>
<tr>
<td>win + e</td>
<td>打开我的电脑</td>
</tr>
<tr>
<td>win + r</td>
<td>cmd进入命令行，regedit进入注册表</td>
</tr>
<tr>
<td>win + q</td>
<td>打开搜索栏</td>
</tr>
<tr>
<td>win + l</td>
<td>快速锁屏</td>
</tr>
<tr>
<td>win + i</td>
<td>打开windows设置</td>
</tr>
<tr>
<td>win + x + u + s</td>
<td>使电脑进入睡眠状态</td>
</tr>
<tr>
<td>win + p</td>
<td>多屏管理</td>
</tr>
<tr>
<td>win + .</td>
<td>输入表情符号</td>
</tr>
<tr>
<td>alt + tab</td>
<td>切换窗口</td>
</tr>
<tr>
<td>ctrl + shift + esc</td>
<td>打开任务管理器</td>
</tr>
<tr>
<td>ctrl + tab</td>
<td>切换chrome网页窗口</td>
</tr>
<tr>
<td>ctrl + j</td>
<td>进入下载内容</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>收藏网页</td>
</tr>
<tr>
<td>F5</td>
<td>chrome刷新网页</td>
</tr>
<tr>
<td>F12</td>
<td>chrome进入开发者工具</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>开发者工具下刷新页面请求</td>
</tr>
<tr>
<td>F2</td>
<td>重命名</td>
</tr>
<tr>
<td>ctrl + alt + a</td>
<td>【个人习惯】截屏</td>
</tr>
<tr>
<td>F3</td>
<td>【个人习惯】贴图</td>
</tr>
<tr>
<td>鼠标左侧按键</td>
<td>【个人习惯】网页前进后退</td>
</tr>
<tr>
<td>ctrl + 选中文字</td>
<td>【个人习惯】沙拉查词翻译</td>
</tr>
<tr>
<td>ctrl + /</td>
<td>【个人习惯】语雀插入代码块</td>
</tr>
<tr>
<td>ctrl + `</td>
<td>打开Ditto，双击即复制</td>
</tr>
</tbody></table>
<h1 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>选中项目 + →</td>
<td>展开项目</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>撤销</td>
</tr>
<tr>
<td>ctrl + shift + z</td>
<td>反撤销</td>
</tr>
<tr>
<td>ctrl + y</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>复制当前行</td>
</tr>
<tr>
<td>鼠标快速点三下</td>
<td>选中当前行</td>
</tr>
<tr>
<td>ctrl + alt + t</td>
<td>快速try…catch/if</td>
</tr>
<tr>
<td>ctrl + /</td>
<td>单行注释</td>
</tr>
<tr>
<td>ctrl + shift + /</td>
<td>多行注释</td>
</tr>
<tr>
<td>alt + enter</td>
<td>导包、修正代码</td>
</tr>
<tr>
<td>alt + insert</td>
<td>pojo类生成方法</td>
</tr>
<tr>
<td>ctrl + tab</td>
<td>切换代码窗口(按上下键选择文件)</td>
</tr>
<tr>
<td>ctrl + f</td>
<td>当前文件搜索关键字</td>
</tr>
<tr>
<td>ctrl + shift + f</td>
<td>全局搜索关键字</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>当前文件替换关键字</td>
</tr>
<tr>
<td>ctrl + shift + r</td>
<td>全局替换关键字</td>
</tr>
<tr>
<td>ctrl + n</td>
<td>通过类名查找文件</td>
</tr>
<tr>
<td>ctrl + shift + n</td>
<td>通过文件名定位</td>
</tr>
<tr>
<td>ctrl + alt + l</td>
<td>调整代码格式</td>
</tr>
<tr>
<td>ctrl + F12</td>
<td>查看类结构(字段和方法)</td>
</tr>
<tr>
<td>ctrl + h</td>
<td>查看类继承关系</td>
</tr>
<tr>
<td>shift + F6</td>
<td>重命名文件</td>
</tr>
<tr>
<td>shift + F9</td>
<td>Debug启动项目</td>
</tr>
<tr>
<td>ctrl + t</td>
<td>【个人习惯】CodeIf命名插件</td>
</tr>
<tr>
<td>F8</td>
<td>代码向下执行一行</td>
</tr>
<tr>
<td>F7</td>
<td>进入到某个方法内部，F8向下执行可跳出</td>
</tr>
<tr>
<td>F9</td>
<td>执行到下一个断点或执行到底</td>
</tr>
<tr>
<td>alt + F8</td>
<td>断点调试时查看某行代码数据</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Windows</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>尚医通学习总结</title>
    <url>/posts/943f.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="尚医通学习总结"><a href="#尚医通学习总结" class="headerlink" title="尚医通学习总结"></a>尚医通学习总结</h1><p>尚医通完结撒花！</p>
<p>视频来自<a href="https://www.bilibili.com/video/BV1V5411K7rT">Java微服务+分布式+全栈项目【尚医通】</a></p>
<span id="more"></span>

<h2 id="1-项目总结"><a href="#1-项目总结" class="headerlink" title="1 项目总结"></a>1 项目总结</h2><h3 id="1-1-项目功能总结-后台管理系统"><a href="#1-1-项目功能总结-后台管理系统" class="headerlink" title="1.1 项目功能总结(后台管理系统)"></a>1.1 项目功能总结(后台管理系统)</h3><p>1、医院设置管理</p>
<ul>
<li><p>医院设置列表、添加、锁定、删除  </p>
</li>
<li><p>医院列表、详情、排班、下线     </p>
</li>
</ul>
<p>2、数据管理</p>
<ul>
<li>数据字典树形显示、导入、导出 </li>
</ul>
<p>3、用户管理  </p>
<ul>
<li><p>用户列表、查看、锁定  </p>
</li>
<li><p>认证用户审批 </p>
</li>
</ul>
<p>4、订单管理  </p>
<ul>
<li>订单列表、详情     </li>
</ul>
<p>5、统计管理  </p>
<ul>
<li>预约统计  </li>
</ul>
<h3 id="1-2-项目功能总结-前台用户系统"><a href="#1-2-项目功能总结-前台用户系统" class="headerlink" title="1.2 项目功能总结(前台用户系统)"></a>1.2 项目功能总结(前台用户系统)</h3><p>1、首页数据显示</p>
<ul>
<li>医院列表</li>
</ul>
<p> 2、医院详情显示</p>
<ul>
<li>医院科室显示</li>
</ul>
<p> 3、用户登录功能</p>
<ul>
<li><p>手机号登录（短信验证码发送）</p>
</li>
<li><p>微信扫描登录</p>
</li>
</ul>
<p>4、用户实名认证</p>
<p>5、就诊人管理</p>
<ul>
<li>列表、添加、详情、删除</li>
</ul>
<p> 6、预约挂号功能</p>
<ul>
<li><p>排班和挂号详情信息</p>
</li>
<li><p>确认挂号信息</p>
</li>
<li><p>生成预约挂号订单</p>
</li>
<li><p>挂号订单支付（微信）</p>
</li>
<li><p>取消预约订单</p>
</li>
</ul>
<p>7、就医提醒功能</p>
<h3 id="1-3-项目技术点总结-后端技术"><a href="#1-3-项目技术点总结-后端技术" class="headerlink" title="1.3 项目技术点总结(后端技术)"></a>1.3 项目技术点总结(后端技术)</h3><p>1、SpringBoot</p>
<p>2、SpringCloud</p>
<ul>
<li><p>Nacos注册中心</p>
</li>
<li><p>Feign</p>
</li>
<li><p>GateWay</p>
</li>
</ul>
<p>3、Redis</p>
<ul>
<li><p>使用Redis作为缓存</p>
</li>
<li><p>验证码有效时间、支付二维码有效时间</p>
</li>
</ul>
<p>4、MongoDB</p>
<ul>
<li>使用MongoDB存储 医院相关数据</li>
</ul>
<p>5、EasyExcel</p>
<ul>
<li>操作excel表格，进行读和写操作</li>
</ul>
<p>6、MyBatisPlus</p>
<p>7、RabbitMQ</p>
<ul>
<li>订单相关操作，发送mq消息</li>
</ul>
<p>8、Docker</p>
<ul>
<li><p>下载镜像 docker pull </p>
</li>
<li><p>创建容器 docker run</p>
</li>
</ul>
<p>9、阿里云OSS</p>
<p>10、阿里云短信服务</p>
<p>11、微信登录/支付</p>
<p>12、定时任务</p>
<h3 id="1-4-项目技术点总结-前端技术"><a href="#1-4-项目技术点总结-前端技术" class="headerlink" title="1.4 项目技术点总结(前端技术)"></a>1.4 项目技术点总结(前端技术)</h3><p>1、vue</p>
<ul>
<li>指令</li>
</ul>
<p>2、Element-ui</p>
<p>3、nuxt</p>
<p>4、npm </p>
<p>5、ECharts</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>尚医通</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城学习总结</title>
    <url>/posts/7f37.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="谷粒商城学习总结"><a href="#谷粒商城学习总结" class="headerlink" title="谷粒商城学习总结"></a>谷粒商城学习总结</h1><p>第一遍学习完结撒花，第一遍主要是熟悉整个项目背景。</p>
<p>第二遍打算结合视频独立完成，熟悉项目的整体设计、优秀业务代码的编写，并输出学习笔记。</p>
<p>​<span id="more"></span></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>谷粒商城</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/posts/251e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>关于SpringBoot的学习笔记，视频来自<a href="https://www.bilibili.com/video/BV19K4y1L7MT">雷丰阳SpringBoot2021</a><br>​<span id="more"></span></p>
<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><h2 id="1-SpringBoot概述"><a href="#1-SpringBoot概述" class="headerlink" title="1.SpringBoot概述"></a>1.SpringBoot概述</h2><p>SpringBoot的底层是SpringFramework<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722254166-192baa58-942d-41b5-92e3-cc7acf733dd5.png?x-oss-process=image%2Fresize%2Cw_944%2Climit_0" /></p>
<p>什么是适配器模式？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630053630809-2d294113-d2e1-40cf-884b-a2b16b9260f2.png#clientId=u8f909344-f80e-4&from=paste&id=u6b36a10c&margin=%5Bobject%20Object%5D&name=&originHeight=435&originWidth=1232&originalType=binary&ratio=1&size=72081&status=done&style=none&taskId=ue9520550-6872-489a-b200-5943e2f77d4"></p>
<h3 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722198135-24ff3779-1baa-4579-ad00-b4ccecf08354.png"></p>
<p>微服务将一大应用拆分成小模块，每个小模块都可以独立部署到服务器上<br>微服务拆分后会出现分布式问题，这时候就使用<strong>SpringBoot + SpringCloud</strong>的解决方案<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631722217507-9393c5ce-c52f-4a69-a1cb-1d827dafccfe.png" /></p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>场景启动器的基础是<strong>spring-boot-starter</strong>，它包含许多其他依赖，这些依赖定义了版本，因此你要引入这些依赖可以不用定义版本信息。如果是非其他依赖，需要定义版本信息<br>​</p>
<p>springboot的application启动类就是一个IOC，配置好了许多组件，如支持Spring MVC的多个组件等</p>
<p>包扫描：application所在的包自动扫描容器<br>想要改变扫描路径，@SpringBootApplication(scanBasePackages=”com.atguigu”)<br>​</p>
<h3 id="组件添加【底层注解】"><a href="#组件添加【底层注解】" class="headerlink" title="组件添加【底层注解】"></a>组件添加【底层注解】</h3><p>@proxyBeanMethods：代理bean的方法<br>Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】<br>Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】<br>​</p>
<p>@Import({User.class, DBHelper.class})<br>给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名<br>条件装配：满足@Conditional指定的条件，则进行组件注入<br>​</p>
<p>@ImportResource支持导入Spring的配置文件<br>​</p>
<p>JavaBean和配置文件中的属性绑定<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630064355478-850a8ddc-fb35-4e7e-a105-204476fc0805.png#clientId=u8f909344-f80e-4&from=paste&height=51&id=u66b02441&margin=%5Bobject%20Object%5D&name=&originHeight=102&originWidth=573&originalType=binary&ratio=1&size=55574&status=done&style=none&taskId=uf0111ee4-cb85-49b3-ba03-485639cd997&width=286.5"><br>@Component注解表示该类是一个组件类<br>​</p>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>SpringBoot启动默认加载所有的自动配置项，按照条件装配最终会被按需加载<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630132928220-0f42cc99-ab93-48f2-a013-7dfb7d6951c4.png#clientId=uc2d51021-934b-4&from=paste&height=159&id=u525869c2&margin=%5Bobject%20Object%5D&name=&originHeight=318&originWidth=1079&originalType=binary&ratio=1&size=189217&status=done&style=none&taskId=u7a1a2575-3299-40b7-b167-ccadc0aa133&width=539.5"></p>
<h2 id="2-开发小技巧"><a href="#2-开发小技巧" class="headerlink" title="2.开发小技巧"></a>2.开发小技巧</h2><h3 id="1-Lombok"><a href="#1-Lombok" class="headerlink" title="1 Lombok"></a>1 Lombok</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NoArgsConstructor   //无参构造器</span><br><span class="line">@AllArgsConstructor  //所有成员变量的有参构造器，如需定制，可以自己手动编写代码</span><br><span class="line">@Data    //get、set方法</span><br><span class="line">@ToString   //toString方法</span><br><span class="line">@EqualsAndHashCode   //重写equals和hashcode</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private Pet pet;</span><br><span class="line"></span><br><span class="line">    public User(String name,Integer age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lombok还提供@Slf4j注解，用于日志打印。如果需要使用lombok，需要引入依赖</strong></p>
<h3 id="2-dev-tools"><a href="#2-dev-tools" class="headerlink" title="2 dev-tools"></a>2 dev-tools</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>项目或者页面修改以后：Ctrl+F9；  跟shift+F9效果差不多，它的功能也是重启项目</p>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>yaml配置文件，k v格式，k v之间必须要有空格<br>properties的优先级比yml高<br>\n    双引号会换行，单引号不会换行<br>maven的clean+package导出jar包，jar包是项目可执行的文件，java -jar启动</p>
<h2 id="2-Web开发"><a href="#2-Web开发" class="headerlink" title="2.Web开发"></a>2.Web开发</h2><p>SpringBoot几乎提供了所有的自动配置</p>
<h3 id="2-1-静态资源目录"><a href="#2-1-静态资源目录" class="headerlink" title="2.1 静态资源目录"></a>2.1 静态资源目录</h3><p>只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources<br>访问 ： 当前项目根路径/ + 静态资源名<br>​</p>
<p>原理： 静态映射/**。<br>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面<br>​</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /res/**</span><br><span class="line">    </span><br><span class="line">	resources:</span><br><span class="line">    static-locations: [classpath:/haha/]</span><br></pre></td></tr></table></figure>


<p>静态资源前缀的设置，会导致静态资源中index和favicon的失效</p>
<h3 id="2-2-请求映射"><a href="#2-2-请求映射" class="headerlink" title="2.2 请求映射"></a>2.2 请求映射</h3><p>所有的请求映射都在HandlerMapping中。</p>
<ul>
<li>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</li>
<li>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</li>
<li>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。<ul>
<li>如果有就找到这个请求对应的handler</li>
<li>如果没有就是下一个 HandlerMapping</li>
</ul>
</li>
<li>我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></li>
</ul>
<h3 id="2-3-请求处理"><a href="#2-3-请求处理" class="headerlink" title="2.3 请求处理"></a>2.3 请求处理</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631162277931-5807f1fe-3526-4d8a-b8a0-f6a31cfded35.png#clientId=ub5bbc323-b3fc-4&from=paste&height=446&id=ue9d44191&margin=%5Bobject%20Object%5D&name=&originHeight=446&originWidth=763&originalType=binary&ratio=1&size=47923&status=done&style=none&taskId=u45f79ebb-3158-4804-9e40-64ce100efb7&width=763"></p>
<p>矩阵变量必须有url路径变量才能被解析<br>​</p>
<p><strong>参数解析器的理解</strong></p>
<h3 id="2-4-POJO的封装过程"><a href="#2-4-POJO的封装过程" class="headerlink" title="2.4 POJO的封装过程"></a>2.4 POJO的封装过程</h3><p><strong>数据绑定</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631264667583-91f324de-f04e-420e-b0b4-39a85959146e.png#clientId=ue844cd9e-3703-4&from=paste&height=287&id=uac93d380&margin=%5Bobject%20Object%5D&name=&originHeight=287&originWidth=828&originalType=binary&ratio=1&size=158755&status=done&style=none&taskId=u8760807b-21c9-45aa-b622-e413838c849&width=828"></p>
<h3 id="2-5-数据响应与内容协商"><a href="#2-5-数据响应与内容协商" class="headerlink" title="2.5 数据响应与内容协商"></a>2.5 数据响应与内容协商</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631265908773-3cb29740-fc3a-4fc4-b737-eed4d36ade88.png#clientId=ue844cd9e-3703-4&from=paste&height=274&id=ufb225947&margin=%5Bobject%20Object%5D&name=&originHeight=274&originWidth=432&originalType=binary&ratio=1&size=12612&status=done&style=none&taskId=uf802e7c9-5678-476f-b915-05303cd4193&width=432"></p>
<h2 id="3-Thymeleaf"><a href="#3-Thymeleaf" class="headerlink" title="3.Thymeleaf"></a>3.Thymeleaf</h2><p>前端模板引擎，用于springboot的前后端不分离项目<br>​</p>
<p>后端向前端html传递数据，可以把数据放在HttpSession和Model对象中<br>session存在服务器，cookie存在客户端<br>​</p>
<p>用户是否登录使用拦截器的解决方案<br>​</p>
<p>创建list的user对象的方法：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631503799043-5a49aaf3-29ac-49e2-8cd3-d52090fc2630.png#clientId=uc718f90e-1fb8-4&from=paste&height=316&id=ud1608871&margin=%5Bobject%20Object%5D&name=&originHeight=316&originWidth=1137&originalType=binary&ratio=1&size=291163&status=done&style=none&taskId=u8d28f38e-d4d1-4c62-83d6-096d7396a28&width=1137"></p>
<h2 id="4-拦截器"><a href="#4-拦截器" class="headerlink" title="4.拦截器"></a>4.拦截器</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631669770552-88c6e8c3-ffc2-4ef1-869e-c9f3b27d3e34.png#clientId=udec2cb0c-a3fa-4&from=paste&height=91&id=u8335d798&margin=%5Bobject%20Object%5D&name=&originHeight=91&originWidth=778&originalType=binary&ratio=1&size=121894&status=done&style=none&taskId=u2d8340c1-6352-4b96-bba1-22131b6c82b&width=778"></p>
<p>写完拦截器后，还要写一个配置类<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631669639670-27b30153-6108-44ff-88e4-705ffce27db2.png#clientId=udec2cb0c-a3fa-4&from=paste&height=290&id=u3147febf&margin=%5Bobject%20Object%5D&name=&originHeight=290&originWidth=1345&originalType=binary&ratio=1&size=272546&status=done&style=none&taskId=ua1e4fbb4-b598-494e-b092-f952529268a&width=1345"></p>
<p>log日志打印用大括号{}，后面可以传参数到大括号中<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631670617684-71515619-2885-4226-acca-297093ae490d.png#clientId=udec2cb0c-a3fa-4&from=paste&height=529&id=uad28c216&margin=%5Bobject%20Object%5D&name=&originHeight=529&originWidth=1167&originalType=binary&ratio=1&size=257366&status=done&style=none&taskId=u030bcad3-af47-4dc4-9a23-3dd7b17b0a9&width=1167"><br>​</p>
<h2 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5.文件上传"></a>5.文件上传</h2><p>使用@RequestPart注解<br>文件上传API <strong>Multipart</strong>接口可以在配置文件中设置单个文件上传大小、整体文件上传大小<br>一般设置单个文件上传大小为10M<br>​</p>
<h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><p>前端需要设置404、5xx错误跳转页面。后端编写全局异常处理跳转代码</p>
<p>异常处理自动配置ErrorMvcAutoConfiguration<br>​</p>
<h2 id="7-Web原生组件注入-Servlet、Filter、Listener"><a href="#7-Web原生组件注入-Servlet、Filter、Listener" class="headerlink" title="7.Web原生组件注入(Servlet、Filter、Listener)"></a>7.Web原生组件注入(Servlet、Filter、Listener)</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631685881305-ea779be7-bfba-4d63-bb09-a2dda5780519.png#clientId=udec2cb0c-a3fa-4&from=paste&height=402&id=udfbefec0&margin=%5Bobject%20Object%5D&name=&originHeight=402&originWidth=706&originalType=binary&ratio=1&size=40933&status=done&style=none&taskId=ud35374ff-ab7f-420c-a6d6-fa4a35da2eb&width=706"></p>
<p>SpringBoot场景的正常运行得益于底层的自动配置</p>
<p><strong>定制化原理</strong><br>如果接管SpringMVC，就要全面定义它底层的行为<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631686881524-49dbfa3a-481d-4e8c-a674-76442dbbda13.png#clientId=udec2cb0c-a3fa-4&from=paste&height=44&id=u597e4fbe&margin=%5Bobject%20Object%5D&name=&originHeight=44&originWidth=928&originalType=binary&ratio=1&size=64808&status=done&style=none&taskId=u868ed1bd-d40d-4762-9aa4-802c711b827&width=928"></p>
<h2 id="8-数据访问"><a href="#8-数据访问" class="headerlink" title="8.数据访问"></a>8.数据访问</h2><h3 id="8-1-JDBCTempalte"><a href="#8-1-JDBCTempalte" class="headerlink" title="8.1 JDBCTempalte"></a>8.1 JDBCTempalte</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631687365008-3f821da9-ae1a-4bcc-9d18-b8a2741cdc4f.png#clientId=udec2cb0c-a3fa-4&from=paste&height=205&id=uc02ee31e&margin=%5Bobject%20Object%5D&name=&originHeight=205&originWidth=770&originalType=binary&ratio=1&size=14431&status=done&style=none&taskId=u4cbc34bb-c3bc-4603-84e0-b863eb15568&width=770"><br>数据库驱动？<br>为什么导入JDBC场景，官方不导入驱动？官方不知道我们接下要操作什么数据库。<br>数据库版本和驱动版本对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<p>SpringBoot默认使用的是Hikari数据源，配置文件配置数据源的时候不用去配置，因为底层已经指定帮我们配好了。如果需要更换数据源，也可以进行配置<br>​</p>
<p>使用JdbcTemplate模板引擎，就可以操作数据库了<br>​</p>
<p><strong>使用某个中间件：首先要找starter，starter会把需要用到的组件都注入到容器中，我们只需要进行一些配置，就可以使用这些中间件了</strong></p>
<p>目前比较流行的数据源是Hikari和Druid<br>​</p>
<p><strong>​</strong></p>
<p><strong>自定义整合Druid数据源：</strong><br>Druid提供内置监控页的功能，在配置文件中配置即可查看页面<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631691102372-6a7dbc49-3d11-4a20-b2a8-c2f23e60a638.png#clientId=udec2cb0c-a3fa-4&from=paste&height=331&id=u07649a35&margin=%5Bobject%20Object%5D&name=&originHeight=331&originWidth=1059&originalType=binary&ratio=1&size=230828&status=done&style=none&taskId=ubaf7fad5-1403-42ee-8789-ff915cedeb5&width=1059"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631691580980-9f05619d-cc27-4321-9b09-e3c6daebab1c.png#clientId=udec2cb0c-a3fa-4&from=paste&height=361&id=u793f1485&margin=%5Bobject%20Object%5D&name=&originHeight=361&originWidth=1032&originalType=binary&ratio=1&size=358430&status=done&style=none&taskId=uf4099a81-7596-4c60-a4ce-2dfc7e5e6a4&width=1032"><br>Arrays.asList()  创建一个集合<br>​</p>
<p><strong>如果某个中间有starter启动类，就不用自己创建配置类进行配置了。所以用中间件之前，先引入starter，比如druid就有starter</strong><br><strong>​</strong></p>
<p>druid的监控页可以配置账号密码<br>​</p>
<h3 id="8-2-MyBatis"><a href="#8-2-MyBatis" class="headerlink" title="8.2 MyBatis"></a>8.2 MyBatis</h3><p>引入MyBatis的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>MyBatis开启驼峰命名规则，否则数据库带_的字段无法正常读取<br>mybatis-config.xml可以不写，配置直接写在application.properties中即可<br>mapper接口标注@Mapper注解<br>​</p>
<p>sql语句可以用xml的方式，也可以用注解的方式<br>​</p>
<h3 id="8-3-MyBatis-Plus"><a href="#8-3-MyBatis-Plus" class="headerlink" title="8.3 MyBatis Plus"></a>8.3 MyBatis Plus</h3><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>mapper接口继承BaseMapper<T>，不用自己编写xml文件<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631696711988-4a74fe71-7e66-49b7-8c74-45fd449ad08f.png#clientId=udec2cb0c-a3fa-4&from=paste&height=243&id=ucaea7a0a&margin=%5Bobject%20Object%5D&name=&originHeight=243&originWidth=835&originalType=binary&ratio=1&size=172997&status=done&style=none&taskId=ue53d6fe1-1c7e-4a99-bb67-6a7956dd654&width=835"></p>
<p>MyBatis Plus的pojo类示例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631696858682-0b336734-0072-40cf-b0cf-90deed01d10c.png#clientId=udec2cb0c-a3fa-4&from=paste&height=620&id=ub3a30d4c&margin=%5Bobject%20Object%5D&name=&originHeight=620&originWidth=460&originalType=binary&ratio=1&size=251786&status=done&style=none&taskId=ua6af1bb7-6373-4d80-8da6-5c04b519af1&width=460"><br>@TableField表示该字段不在数据库中<br>Service的实现类需要加@Service注解<br>​</p>
<p>MyBatis Plus在mapper层和service层都进行了简化，提供了基础的方法，并且自己不用写xml文件<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631697133197-a037115e-9738-4162-8585-7c63a8b71859.png#clientId=udec2cb0c-a3fa-4&from=paste&height=68&id=u421fd858&margin=%5Bobject%20Object%5D&name=&originHeight=68&originWidth=757&originalType=binary&ratio=1&size=61403&status=done&style=none&taskId=u646ae702-5dea-4b36-80a4-2d52958cb00&width=757"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631697190080-6b3fbac1-090b-4a4c-b505-63e1d80fa741.png#clientId=udec2cb0c-a3fa-4&from=paste&height=174&id=ub6d32822&margin=%5Bobject%20Object%5D&name=&originHeight=174&originWidth=1211&originalType=binary&ratio=1&size=108140&status=done&style=none&taskId=u6872e4dc-ed52-41fc-90bf-5a401fc04f7&width=1211"><br>ctrl + F12可以查看类结构，由于继承了ServiceImpl，可以看到由MyBatis Plus已经实现的方法<br>​</p>
<p>实现分页查询，创建Page对象，然后使用提供的分页查询方法。想要分页完成，需要整合分页插件<br>​</p>
<p>MyBatis Plus结合Thymeleaf完成分页查询<br>​</p>
<h3 id="8-4-Redis"><a href="#8-4-Redis" class="headerlink" title="8.4 Redis"></a>8.4 Redis</h3><p>redis-starter由官方整合，由官方整合的starter自动配置都在统一的一个包中可以进行查看<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631710788203-58f4a7e7-32b6-4059-8af5-1752f205cbfc.png#clientId=ubcae3f69-ac75-4&from=paste&id=u43acbe15&margin=%5Bobject%20Object%5D&name=&originHeight=245&originWidth=908&originalType=binary&ratio=1&size=84771&status=done&style=none&taskId=ube5b7741-3a62-47a2-a979-253605613f1"></p>
<p>使用RedisTemplate即可操作Redis,对Redis中的数据进行增加、修改、删除等操作<br>​</p>
<h2 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9.单元测试"></a>9.单元测试</h2><p><strong>当前主要是JUnit5</strong>，相比于JUnit4使用起来更方便。SpringBoot2.4之后就不允许使用JUnit4了<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631715257345-0a10ee8a-15ae-45f8-b80c-02c288814b34.png#clientId=ubcae3f69-ac75-4&from=paste&id=u3959f422&margin=%5Bobject%20Object%5D&name=&originHeight=199&originWidth=1047&originalType=binary&ratio=1&size=60953&status=done&style=none&taskId=ubba0656b-70b3-4ff9-ab29-aaacd8355cb"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631715345279-36880286-2501-46b5-822b-4954248134d2.png#clientId=ubcae3f69-ac75-4&from=paste&id=ue162f8f3&margin=%5Bobject%20Object%5D&name=&originHeight=204&originWidth=398&originalType=binary&ratio=1&size=34006&status=done&style=none&taskId=uc234bfe2-656c-4e10-98d9-3afe4d03de7"><br>以上这种单元测试使用起来非常方便<br>​</p>
<p>JUnit5的相关注解：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631716028871-cbc169cb-f865-4f22-99be-acd33b3969f7.png#clientId=ubcae3f69-ac75-4&from=paste&id=u71dff98b&margin=%5Bobject%20Object%5D&name=&originHeight=446&originWidth=1060&originalType=binary&ratio=1&size=189236&status=done&style=none&taskId=ue8e5a17e-158a-4d3d-9060-c7d6ba8cbbd"></p>
<p><strong>断言机制</strong><br>不满足的断言会使测试条件失败</p>
<p><strong>前制条件</strong><br>​</p>
<p><strong>嵌套测试</strong><br>​</p>
<p><strong>参数化测试</strong><br>使用不同的参数多次运行某个测试  @ValueSource<br>​</p>
<h2 id="10-指标监控"><a href="#10-指标监控" class="headerlink" title="10.指标监控"></a>10.指标监控</h2><p>SpringBoot Actuator<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631718011444-e1dab13b-0d5b-4b56-8c18-dacf671f5e57.png#clientId=ubcae3f69-ac75-4&from=paste&id=u3954f3b5&margin=%5Bobject%20Object%5D&name=&originHeight=137&originWidth=762&originalType=binary&ratio=1&size=91721&status=done&style=none&taskId=u0737ed26-320c-4881-a68c-155f1d69c2c"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631718497581-94c74683-4b65-4bdc-99f3-66d94c872e91.png#clientId=ubcae3f69-ac75-4&from=paste&id=ubda37100&margin=%5Bobject%20Object%5D&name=&originHeight=163&originWidth=218&originalType=binary&ratio=1&size=15123&status=done&style=none&taskId=u43ee0b45-926b-4b66-8924-60ab4c0a165"><br><strong>整合SpringBoot Admin Server：开源的应用监控可视化项目</strong><br>可以用来查看应用的启动状态、内存占用、cpu使用率等</p>
<h2 id="11-原理解析"><a href="#11-原理解析" class="headerlink" title="11.原理解析"></a>11.原理解析</h2><h3 id="11-1-Profile配置环境切换"><a href="#11-1-Profile配置环境切换" class="headerlink" title="11.1 Profile配置环境切换"></a>11.1 Profile配置环境切换</h3><p>从配置文件取值，@Value加冒号，冒号后面表示如果不到值，赋予一个默认值<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1631719367531-9ef7fd53-47ab-46cf-a718-034e3c293842.png#clientId=ubcae3f69-ac75-4&from=paste&height=73&id=u86b1f00e&margin=%5Bobject%20Object%5D&name=&originHeight=145&originWidth=663&originalType=binary&ratio=1&size=57104&status=done&style=none&taskId=ud78e0e88-4291-4f29-a6c8-da731bf1ae5&width=331.5"><br>如果两个配置文件中有相同的配置，以指定环境的配置为主<br>​</p>
<p>打包一般使用clean  install，install包含了package的功能<br>​</p>
<h3 id="11-2-自定义starter"><a href="#11-2-自定义starter" class="headerlink" title="11.2 自定义starter"></a>11.2 自定义starter</h3><p>SpringBoot也可以自定义starter<br>​</p>
<h3 id="11-3-SpringBoot启动过程"><a href="#11-3-SpringBoot启动过程" class="headerlink" title="11.3 SpringBoot启动过程"></a>11.3 SpringBoot启动过程</h3><ul>
<li>创建 <strong>SpringApplication</strong><ul>
<li>保存一些信息。</li>
<li>判定当前应用的类型。ClassUtils。Servlet</li>
<li><strong>bootstrappers：初始启动引导器（</strong>List<Bootstrapper>**）：去spring.factories文件中找 **org.springframework.boot.<strong>Bootstrapper</strong></li>
<li>找 <strong>ApplicationContextInitializer</strong>；去<strong>spring.factories找 ApplicationContextInitializer</strong><ul>
<li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li>
</ul>
</li>
<li><strong>找 ApplicationListener  ；应用监听器。</strong>去<strong>spring.factories找 ApplicationListener</strong><ul>
<li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li>
</ul>
</li>
</ul>
</li>
<li>运行 <strong>SpringApplication</strong><ul>
<li><strong>StopWatch</strong></li>
<li><strong>记录应用的启动时间</strong></li>
<li><strong>创建引导上下文（Context环境）createBootstrapContext()</strong><ul>
<li>获取到所有之前的 **bootstrappers 挨个执行 **intitialize() 来完成对引导启动器上下文环境设置</li>
</ul>
</li>
<li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li>
<li><strong>获取所有 RunListener（运行监听器）【为了方便所有Listener进行事件感知】</strong><ul>
<li>getSpringFactoriesInstances 去<strong>spring.factories找 SpringApplicationRunListener</strong>. </li>
</ul>
</li>
<li>遍历 <strong>SpringApplicationRunListener 调用 starting 方法；</strong><ul>
<li><strong>相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</strong></li>
</ul>
</li>
<li>保存命令行参数；ApplicationArguments</li>
<li>准备环境 prepareEnvironment（）;<ul>
<li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li>
<li><strong>配置环境信息对象。</strong><ul>
<li><strong>读取所有的配置源的配置属性值。</strong></li>
</ul>
</li>
<li>绑定环境信息</li>
<li>监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</li>
</ul>
</li>
<li>创建IOC容器（createApplicationContext（））<ul>
<li>根据项目类型（Servlet）创建容器，</li>
<li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong></li>
</ul>
</li>
<li>**准备ApplicationContext IOC容器的基本信息 **  <strong>prepareContext()</strong><ul>
<li>保存环境信息</li>
<li>IOC容器的后置处理流程。</li>
<li>应用初始化器；applyInitializers；<ul>
<li>遍历所有的 <strong>ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能</strong></li>
<li>遍历所有的 listener 调用 <strong>contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared</strong></li>
</ul>
</li>
<li><strong>所有的监听器 调用 contextLoaded。通知所有的监听器 contextLoaded；</strong></li>
</ul>
</li>
<li><strong>刷新IOC容器。</strong>refreshContext<ul>
<li>创建容器中的所有组件（Spring注解）</li>
</ul>
</li>
<li>容器刷新完成后工作？afterRefresh</li>
<li>所有监听 器 调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器 started</strong></li>
<li><strong>调用所有runners；</strong>callRunners()<ul>
<li><strong>获取容器中的</strong> **ApplicationRunner **</li>
<li><strong>获取容器中的  CommandLineRunner</strong></li>
<li><strong>合并所有runner并且按照@Order进行排序</strong></li>
<li><strong>遍历所有的runner。调用 run 方法</strong></li>
</ul>
</li>
<li><strong>如果以上有异常，</strong><ul>
<li><strong>调用Listener 的 failed</strong></li>
</ul>
</li>
<li>**调用所有监听器的 running 方法  **listeners.running(context); **通知所有的监听器 running **</li>
<li><strong>running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/2789.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>从大二开始就一直很想有一个属于自己的博客网站，可一拖再拖，直到最近才下了决心去搭建一个网站。在网上了解到基于Hexo的博客搭建比较简单并且美观，在查阅了许多教程，走过无数坑后，写下了这篇文章。本文主要讲解个人博客网站的搭建，内容比较详细，适合小白食用。</p>
</blockquote>
<p>网页预览：<a href="https://yuumiy.github.io/">https://yuumiy.github.io</a></p>
<span id="more"></span>

<h1 id="第一部分-搭建与发布"><a href="#第一部分-搭建与发布" class="headerlink" title="第一部分 搭建与发布"></a>第一部分 搭建与发布</h1><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><p>windows10<br>Github<br>Visual Studio Code<br>Hexo 5.4.0 + Next 7.8.0<br>Git 2.32.0<br>Node.js 14.17.4</p>
<h2 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h2><h3 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h3><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<br>可以到<a href="https://git-scm.com/download/win">Git官网</a>进行下载，Git详细安装教程可以查看<a href="https://blog.csdn.net/qq_43715354/article/details/108638061">Git安装</a>。</p>
<h3 id="2、安装VSCode"><a href="#2、安装VSCode" class="headerlink" title="2、安装VSCode"></a>2、安装VSCode</h3><p>VSCode 全称 Visual Studio Code，是微软出的一款轻量级代码编辑器，免费、开源而且功能强大，一般为前端代码开发IDE。<br>可以到<a href="https://code.visualstudio.com/Download">VSCode官网</a>进行下载，VSCode详细安装教程可以查看<a href="https://zhuanlan.zhihu.com/p/264785441">VSCode安装</a>。</p>
<h3 id="3、安装Node-js"><a href="#3、安装Node-js" class="headerlink" title="3、安装Node.js"></a>3、安装Node.js</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。<br>可以到<a href="http://nodejs.cn/download/">Node官网</a>进行下载，Node详细安装教程可以查看<a href="https://www.bilibili.com/video/BV1VK4y1v7TK">Node.js安装</a>。需要注意配置环境变量，便于npm包管理和使用全局组件。</p>
<h3 id="4、安装Hexo"><a href="#4、安装Hexo" class="headerlink" title="4、安装Hexo"></a>4、安装Hexo</h3><p>Hexo是一个快速、简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。<br>安装完Node.js后，就可以使用软件内自带的npm包管理器下载Hexo。<br>在任意文件夹下，右键<code>Git Bash Here</code>，<code>npm install -g hexo-cli</code>安装Hexo，然后使用<code>hexo init hexo-blog</code>初始化一个hexo项目。右键通过Code打开项目，在集成终端打开文件夹，执行<code>hexo server</code>，能够通过localhost:4000访问到项目，hexo就安装成功了。</p>
<h3 id="5、注册Github账号创建个人仓库"><a href="#5、注册Github账号创建个人仓库" class="headerlink" title="5、注册Github账号创建个人仓库"></a>5、注册Github账号创建个人仓库</h3><p>Github是世界上最大的代码托管平台，怎么注册账号相信不必我多说。<br>注册登录好之后，进去新建一个仓库，仓库名字有一定的规范要求。例如我的Github名字叫yuumiy，那么在填写仓库名的时候就是jorsoe.github.io。这样就完成了个人仓库的创建。</p>
<h3 id="6、生成ssh密钥添加到Github"><a href="#6、生成ssh密钥添加到Github" class="headerlink" title="6、生成ssh密钥添加到Github"></a>6、生成ssh密钥添加到Github</h3><p>这一步的目的是可以使用Github的ssh地址pull、push仓库。设置使用ssh密钥的好处是可以使用ssh连接，提交代码的时候可以不用输入密码，免密提交。<br>Github下载代码有三种方式，http下载、ssh下载、zip下载，到个人仓库页面就可以看到这三种下载方式。<br>​</p>
<p>在本地博客文件夹中右键选择Git Bash Here调出命令行，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;YourGithubName&quot;</span>		//双引号内填写你的GitHub用户名</span><br><span class="line">git config --global user.email <span class="string">&quot;YourGithubEmail&quot;</span>	//双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure>
<p> 用户名和邮箱根据你Github自己的信息自行更改。</p>
<p> 然后输入以下命令生成SSH密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;YourGithubEmail&quot;</span>		//双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure>
<p> 此时你个人的SSH密钥就已经生成，输入以下命令将其 Copy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub		//在Git命令提示符中显示出SSH密钥</span><br></pre></td></tr></table></figure>
<p>接下来打开Github，点击头像在选项卡中找到Setting设置选项，再点击SSH and GPG keys，新建一个SSH，命名随意，将刚才再Git输入框中复制的密钥粘贴在此处，点击保存。</p>
<p> 然后回到Git命令行，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com		//查看本地是否与Github连接成功</span><br></pre></td></tr></table></figure>
<p> 如果出现自己的用户名，那就已经将本地环境与Github连接成功，以后就可以通过ssh的方式提交代码，一劳永逸。</p>
<h3 id="7、修改Hexo配置文件"><a href="#7、修改Hexo配置文件" class="headerlink" title="7、修改Hexo配置文件"></a>7、修改Hexo配置文件</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的站点配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。​<br>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hexo/_config.yml</span><br><span class="line"></span><br><span class="line">/hexo/themes/landscape/_config.yml</span><br></pre></td></tr></table></figure>
<p>打开站点配置文件，修改配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: ssh仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>在repository仓库中填上刚才申请的个人仓库的ssh地址，branch分支填上主分支，保存即可。<br>建议将在VSCode中配置自动保存文件，自行百度进行相关设置。</p>
<h3 id="8、Hexo项目映射到Github仓库"><a href="#8、Hexo项目映射到Github仓库" class="headerlink" title="8、Hexo项目映射到Github仓库"></a>8、Hexo项目映射到Github仓库</h3><p>完成Hexo配置后，就可以在当前项目的集成终端执行<code>git init</code>，初始化一个git项目。<code>git remote add origin ssh地址</code>，ssh地址即为刚才申请的个人仓库的ssh地址。<br>在使用Hexo部署博客之前，需要先安装一个依赖，这个依赖会将我们生成好的代码部署到一个具体的分支，执行命令<code>npm install hexo-deployer-git</code>安装依赖。然后<code>hexo deploy</code>，即完成Hexo部署到Github。yuumiy.github.io即为博客项目的访问地址。</p>
<h3 id="9、Markdown学习与工具"><a href="#9、Markdown学习与工具" class="headerlink" title="9、Markdown学习与工具"></a>9、Markdown学习与工具</h3><p>所有的框架与工具配置好之后，就可以在/source/_post文件夹里面的.md文件进行博客的编撰，而编撰过程使用Markdown语法进行编写，点击<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdow</a>学习相应语法，教程比较全面而且讲述清晰，很容易理解。<br>工具使用<a href="https://typora.io/">Typora</a>，一个轻量级的Markdown文本编辑器，界面极简并且功能强大。</p>
<h1 id="第二部分-Next主题配置美化"><a href="#第二部分-Next主题配置美化" class="headerlink" title="第二部分 Next主题配置美化"></a>第二部分 Next主题配置美化</h1><blockquote>
<p>在Github开源了许多关于Hexo的博客主题，因为个人比较喜欢简约风格，在进行多番对比后，最终选择Next作为个人博客网站的主题。</p>
</blockquote>
<h2 id="Hexo相关介绍"><a href="#Hexo相关介绍" class="headerlink" title="Hexo相关介绍"></a>Hexo相关介绍</h2><h3 id="1、Hexo目录构成"><a href="#1、Hexo目录构成" class="headerlink" title="1、Hexo目录构成"></a>1、Hexo目录构成</h3><blockquote>
<p>node_modules：里面存放Node.js各种库的目录</p>
<p>public：生成网页的文件目录</p>
<p>scaffolds：存放新文章和新页面的初始设置</p>
<p>source：存放文章，各类页面，图像等文件</p>
<p>themes：存放着主题文件</p>
<p>_config.yml：站点配置文件</p>
</blockquote>
<h3 id="2、更换主题"><a href="#2、更换主题" class="headerlink" title="2、更换主题"></a>2、更换主题</h3><p>Hexo有着自己的开源主题库，我们需要去下载Next主题。</p>
<p>在集成终端，也就是博客根目录，执行<code>git clone git@github.com:theme-next/hexo-theme-next.git themes/next</code>，下载完成后，删除next文件夹中的.git和.gitigore文件，因为博客文件夹不能有两个git管理。<br>修改站点配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>执行<code>hexo server</code>，本地的个人博客网站已经更换为Next主题。</p>
<h3 id="3、Next目录构成"><a href="#3、Next目录构成" class="headerlink" title="3、Next目录构成"></a>3、Next目录构成</h3><blockquote>
<p>languages：语言 [通常保存本网站支持的语言设置和支持]</p>
<p>layout：布局文件[通常此文件中添加或者删除一些小功能]</p>
<p>pages：页面文件</p>
<p>scripts：脚本文件 [存放一些JavaScript脚本文件]</p>
<p>sources：资源文件 [存放一些图片,特效之类的文件]</p>
<p><em>config.yml：主题配置文件</em></p>
<p>static_prefix.yml：静态网页参数</p>
</blockquote>
<h2 id="主题配置美化"><a href="#主题配置美化" class="headerlink" title="主题配置美化"></a>主题配置美化</h2><blockquote>
<p>网上Next主题的配置大多为next5.+或next6.+，在Next 7.8.0中对之前的版本进行了高度的插件化，许多功能都集成在主题配置文件中，同时之前自定义样式配置文件的路径也有所改变，针对于此写下自己的配置记录。</p>
</blockquote>
<h3 id="1、设置博主文字描述和中文语言"><a href="#1、设置博主文字描述和中文语言" class="headerlink" title="1、设置博主文字描述和中文语言"></a>1、设置博主文字描述和中文语言</h3><p>站点配置文件修改Site：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 岛田悠米</span><br><span class="line">subtitle: &#x27;心中有梦 不负韶华&#x27;</span><br><span class="line">description: &#x27;coding就是生产力&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: Yuumiy</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="2、设置Next主题样式"><a href="#2、设置Next主题样式" class="headerlink" title="2、设置Next主题样式"></a>2、设置Next主题样式</h3><p>Next提供了四种主题样式，根据个人的喜好选择即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<h3 id="3、设置博客文章持久化链接"><a href="#3、设置博客文章持久化链接" class="headerlink" title="3、设置博客文章持久化链接"></a>3、设置博客文章持久化链接</h3><p>发布博客后，它的默认url地址是带中文的，并且进行了多层分级，非常复杂，因此需要安装这个插件简化url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>站点配置文件修改permalink添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://yuumiy.github.io/</span><br><span class="line">permalink: posts/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16</span><br><span class="line">    rep: hex</span><br></pre></td></tr></table></figure>
<h3 id="4、Menu添加关于、标签、分类页面"><a href="#4、Menu添加关于、标签、分类页面" class="headerlink" title="4、Menu添加关于、标签、分类页面"></a>4、Menu添加关于、标签、分类页面</h3><p>站点配置文件修改menu，将about、tags、categories前的#号去掉，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br></pre></td></tr></table></figure>
<p>新建相关页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>修改生成页面的配置<br>source/about/index.md<br>source/tags/index.md<br>source/categories/index.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="5、添加搜索功能"><a href="#5、添加搜索功能" class="headerlink" title="5、添加搜索功能"></a>5、添加搜索功能</h3><p>安装exo-generator-searchdb这个插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>站点配置文件添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Search</span><br><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>
<h3 id="6、对于网站样式的自定义"><a href="#6、对于网站样式的自定义" class="headerlink" title="6、对于网站样式的自定义"></a>6、对于网站样式的自定义</h3><p>在博客根目录下的source文件夹下新建_data文件夹并添加styles.styl文件，就可以对网站样式进行自定义<br>以我的个人博客为例，我做了如下自定义样式：修改链接样式、去掉顶部黑线、修改选中字符的颜色、修改代码块选中的颜色、修改引用样式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改链接样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff106c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, span.exturl &#123;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff106c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //去掉顶部黑线：</span><br><span class="line">.headband &#123;display:none;&#125;</span><br><span class="line"></span><br><span class="line">// 修改选中字符的颜色</span><br><span class="line">/* webkit, opera, IE9 */</span><br><span class="line">::selection &#123; </span><br><span class="line">    background: #00c4b6;</span><br><span class="line">    color: #f7f7f7; </span><br><span class="line">&#125;</span><br><span class="line">/* firefox */</span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    background: #00c4b6;</span><br><span class="line">    color: #f7f7f7;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码块选中颜色</span><br><span class="line">.highlight *::selection &#123;</span><br><span class="line">    background: #00c4b6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修改引用样式</span><br><span class="line">blockquote &#123;</span><br><span class="line">    border-left: 4px solid #f27c8d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、设置侧栏阅读进度百分比"><a href="#7、设置侧栏阅读进度百分比" class="headerlink" title="7、设置侧栏阅读进度百分比"></a>7、设置侧栏阅读进度百分比</h3><p>编辑站点配置文件，修改 back2top 部分如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  sidebar: true</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="8、设置字数统计和预计阅读时间"><a href="#8、设置字数统计和预计阅读时间" class="headerlink" title="8、设置字数统计和预计阅读时间"></a>8、设置字数统计和预计阅读时间</h3><p>在博客根目录下安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#文章、站点字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4                   # Average Word Length</span><br><span class="line">  wpm: 275                 # Words Per Minute（每分钟阅读词数）</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure>
<h3 id="9、网站底部添加网站运行时间"><a href="#9、网站底部添加网站运行时间" class="headerlink" title="9、网站底部添加网站运行时间"></a>9、网站底部添加网站运行时间</h3><p>修改主题下layout/_partials/footer.swig，在{ {- next_inject(‘footer’) } }上方添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date();</span><br><span class="line">    function createtime() &#123;</span><br><span class="line">        var grt= new Date(&quot;08/10/2021 12:00:00&quot;);//此处修改你的建站时间或者网站上线时间</span><br><span class="line">        now.setTime(now.getTime()+250);</span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);</span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);</span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);</span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);</span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125;</span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;;</span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="10、添加自定义404页面"><a href="#10、添加自定义404页面" class="headerlink" title="10、添加自定义404页面"></a>10、添加自定义404页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>
<p>编辑新建的页面文件，默认在站点根目录下 /source/404/index.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">comments: false</span><br><span class="line">permalink: /404</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;center&gt;对不起，您所访问的页面不存在或者已删除&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">* [click here](https://yuumiy.github.io/) 返回首页</span><br><span class="line">* 我的Github：[https://github.com/yuumiy](https://github.com/yuumiy)</span><br></pre></td></tr></table></figure>
<h3 id="11、添加图片放大预览功能"><a href="#11、添加图片放大预览功能" class="headerlink" title="11、添加图片放大预览功能"></a>11、添加图片放大预览功能</h3><p>在主题配置文件，启用 fancybox，修改配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>
<h3 id="12、隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#12、隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="12、隐藏网页底部 powered By Hexo / 强力驱动"></a>12、隐藏网页底部 powered By Hexo / 强力驱动</h3><p>修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powered: false</span><br></pre></td></tr></table></figure>
<h3 id="13、网页底部添加动态桃心"><a href="#13、网页底部添加动态桃心" class="headerlink" title="13、网页底部添加动态桃心"></a>13、网页底部添加动态桃心</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">icon:</span><br><span class="line">    animated: true</span><br></pre></td></tr></table></figure>
<h3 id="14、图片懒加载设置"><a href="#14、图片懒加载设置" class="headerlink" title="14、图片懒加载设置"></a>14、图片懒加载设置</h3><p>在主题配置文件中启用lazyload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazyload: true</span><br></pre></td></tr></table></figure>
<h3 id="15、设置标题栏背景图片"><a href="#15、设置标题栏背景图片" class="headerlink" title="15、设置标题栏背景图片"></a>15、设置标题栏背景图片</h3><p>博客根目录下的source/_data/styles.styl文件，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 标题栏背景图片</span><br><span class="line">.site-brand-container &#123; </span><br><span class="line">  background-image: url(/images/bg.png);</span><br><span class="line">  background-size: 100% 100%;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/images/bg.png指的是根目录下public/images/下的图片</p>
<h3 id="16、修改文章底部tag标签"><a href="#16、修改文章底部tag标签" class="headerlink" title="16、修改文章底部tag标签"></a>16、修改文章底部tag标签</h3><p>把文章底部#标签改为图标，在主题配置文件中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>
<h3 id="17、设置头像"><a href="#17、设置头像" class="headerlink" title="17、设置头像"></a>17、设置头像</h3><p>在主题配置文件中修改avatar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>
<p>/images/avatar.png指的是根目录下public/images/下的图片</p>
<h3 id="18、网站底部加上访问量"><a href="#18、网站底部加上访问量" class="headerlink" title="18、网站底部加上访问量"></a>18、网站底部加上访问量</h3><p>修改主题下layout/_partials/footer.swig，在{ {- next_inject(‘footer’) } }上方添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;span&gt;&lt;br&gt;&lt;/span&gt;	</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span&gt;总访客&amp;nbsp&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&amp;nbsp人&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;总访问量&amp;nbsp&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&amp;nbsp次&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="19、顶部阅读进度条"><a href="#19、顶部阅读进度条" class="headerlink" title="19、顶部阅读进度条"></a>19、顶部阅读进度条</h3><p>主题配置文件中修改 reading_progress 选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # 显示在顶部</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#06d633&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>
<h3 id="20、设置网站图标"><a href="#20、设置网站图标" class="headerlink" title="20、设置网站图标"></a>20、设置网站图标</h3><p>在主题配置文件中修改favicon</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 填写自己的图片</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon.png</span><br><span class="line">  medium: /images/favicon.png</span><br><span class="line">  apple_touch_icon: /images/favicon.png</span><br><span class="line">  safari_pinned_tab: /images/favicon.png</span><br></pre></td></tr></table></figure>
<p>/images/favicon.png指的是根目录下public/images/下的图片</p>
<h3 id="21、侧边栏社交链接"><a href="#21、侧边栏社交链接" class="headerlink" title="21、侧边栏社交链接"></a>21、侧边栏社交链接</h3><p>修改主题配置文件中socail选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yuumiy || fab fa-github</span><br><span class="line">  E-Mail: mailto:115274737@qq.com || fa fa-envelope</span><br><span class="line">  CSDN: https://blog.csdn.net/qq_44752641 || fab fa-telegram</span><br><span class="line">  RSS: /atom.xml || fas fa-rss</span><br></pre></td></tr></table></figure>
<h3 id="22、阅读全文按钮样式"><a href="#22、阅读全文按钮样式" class="headerlink" title="22、阅读全文按钮样式"></a>22、阅读全文按钮样式</h3><p>在博客需要显示摘要的地方加上 more标签，就不会显示全文。</p>
<h3 id="23、更改新建文章的模板"><a href="#23、更改新建文章的模板" class="headerlink" title="23、更改新建文章的模板"></a>23、更改新建文章的模板</h3><p>默认新建文章没有分类这个选项，需要自己填写，现在修改 hexo/scaffolds/post.md 文件 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="24、设定代码高亮格式"><a href="#24、设定代码高亮格式" class="headerlink" title="24、设定代码高亮格式"></a>24、设定代码高亮格式</h3><p>在站点的配置文件中，搜索highlight</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>
<p>主题配置有关于代码高亮样式的选择，搜索highlight，一般选择normal即可</p>
<h3 id="25、代码块复制选项"><a href="#25、代码块复制选项" class="headerlink" title="25、代码块复制选项"></a>25、代码块复制选项</h3><p>主题配置文件搜索copy_button：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_button:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<h3 id="26、添加萌萌哒Live2D模型"><a href="#26、添加萌萌哒Live2D模型" class="headerlink" title="26、添加萌萌哒Live2D模型"></a>26、添加萌萌哒Live2D模型</h3><p>安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>
<p>在站点配置文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure>
<p>我使用的是喵咪的模型，使用以下命令下载组件，如需使用别的看板娘，请自行百度搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure>

<ul>
<li>在Hexo根目录中新建文件夹live2d_models</li>
<li>在 node_modules 文件夹中找到刚刚下载的 live2d 模型，将其复制到 live2d_models 中。live2d 模型是一个类似于这样的文件夹：live2d-widget-model-hijiki</li>
<li>更新站点配置文件中model.use项，将其修改为 live2d_models 文件夹中的模型文件夹的名称<h3 id="27、开启Valine评论系统"><a href="#27、开启Valine评论系统" class="headerlink" title="27、开启Valine评论系统"></a>27、开启Valine评论系统</h3>注册 Leancloud 账号，注册完成后进入app控制面板-&gt;创建应用-&gt;创建开发版应用。</li>
</ul>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932563266-a353398b-e96b-4b96-b3a6-8f31ec7d6823.png"></p>
<p>接下来我们配置一下我们的leancloud。点击设置-&gt;安全中心-&gt;Web 安全域名，输入你的博客网址来保证其他人就算获取了你的appid也没办法操作你的数据库。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932611676-e5f17d12-271d-4f85-87a8-e547cf7fc427.png"></p>
<p>接下来点击应用凭证获取你的appid和appkey。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628932681681-3f87d5db-34fc-4b73-ae9d-7690800a4811.png"></p>
<hr>
<p>打开主题配置文件，找到comments栏目并开启valine。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure>
<p>往下滑动进入valine设置栏，开启valine并填入你的appid和appkey。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: # Your leancloud application appid</span><br><span class="line">  appkey: # Your leancloud application appkey</span><br><span class="line">  notify: false # Mail notifier</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 作者看到就会及时反馈，欢迎评论哦(๑•̀ㅂ•́)و✧ # Comment box placeholder</span><br><span class="line">  avatar: retro # Gravatar style</span><br><span class="line">  guest_info: nick,mail # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: # Language, available values: en, zh-cn</span><br><span class="line">  visitor: true # Article reading statistic</span><br><span class="line">  comment_count: true # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line">  recordIP: true # Whether to record the commenter IP</span><br><span class="line">  serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span><br><span class="line">  #post_meta_order: 0</span><br></pre></td></tr></table></figure>
<p>这里稍微解释一下各个参数的用途。<br>placeholder是在用户未输入任何参数时默认显示的值；avatar是默认用户头像，参考<a href="https://valine.js.org/avatar.html">link</a>；meta是可以选择的用户信息栏。</p>
<p>为了让Valine更加简洁，我们可以自定义Valine的显示，我是去除了Valine的power by、svg标签、下方的评论提示。具体做法是修改source/_data/styles.styl:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 隐藏 valine 的 powered by</span><br><span class="line">.vpower.txt-right &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// 隐藏 valine 的 svg标签</span><br><span class="line">.markdown &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">// 隐藏 valine 的 下方评论提示</span><br><span class="line">.vempty &#123;</span><br><span class="line">  display: none!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>至此你的评论系统已经开启。</p>
</blockquote>
<h3 id="28、添加对表情符号的支持"><a href="#28、添加对表情符号的支持" class="headerlink" title="28、添加对表情符号的支持"></a>28、添加对表情符号的支持</h3><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-emoji</span><br></pre></td></tr></table></figure>

<p>在站点配置文件添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 为博客添加emoji表情支持</span><br><span class="line">emoji:</span><br><span class="line">  enable: true</span><br><span class="line">  className: github-emoji</span><br><span class="line">  styles: </span><br><span class="line">  customEmojis: </span><br></pre></td></tr></table></figure>



<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>花了大概3个小时，终于把这篇『搭建自己的个人博客网站』完成。这篇文章是我第一篇真正意义上的博客，首先是用心去写，花了大量时间去思考内容和排版；其次，希望自己能保持写博客的好习惯，从今天起，能保持每个月4篇高质量博客的输出，毕竟好记性不如烂笔头，多去总结多去思考。<br>​</p>
<p><strong>最后以维克托·雨果的话作为结束：</strong><br><strong>人的智慧掌握着三把钥匙，一把开启数字，一把开启字母，一把开启音符。知识、想象、幻想就在其中。</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性</title>
    <url>/posts/f6d8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>jdk8新特性学习，视频来自<a href="https://www.bilibili.com/video/BV1HV411W78K">2021最新版JDK8新特性详解</a></p>
</blockquote>
<p>​<span id="more"></span></p>
<h3 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h3><p><strong>lambda表达式的优点：</strong><br>1、简化匿名内部类的使用<br>lambda表达式：匿名内部类是传入接口，而且该接口只能有一个抽象方法<br>一个方法传入接口，就是匿名内部类的写法，因为必须实现接口的抽象方法，否则会报错</p>
<p>2、lambda表达式的省略写法<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971379624-91528a05-8669-44d0-8b50-f0109cf828e9.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u30bd8d35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132597&status=done&style=none&taskId=u3c5875ac-2bb2-480e-8cb0-6b333b1ee8a&title=&width=836" alt="image.png"></p>
<p>3、lambda表达式的使用前提<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971844159-19b8f263-3870-4d46-b7c5-80d920b1251b.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=112&id=u1ff72433&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50173&status=done&style=none&taskId=u123a68ed-b89f-4aef-93f5-1ce1e5035fc&title=&width=603" alt="image.png"><br>4、lambda表达式和匿名内部类的对比<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1645971974322-471b00a0-f497-486e-970f-f7df0727e1ed.png#clientId=u674d1aac-5617-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u8d96d1d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=421&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160037&status=done&style=none&taskId=u88c4ae96-0c18-4976-ba33-2a55940580a&title=&width=608" alt="image.png"></p>
<p>Lambda表达式使用时不关心接口名，抽象方法名。只关心抽象方法的参数列表和返回值类型 </p>
<h3 id="二、接口新特性"><a href="#二、接口新特性" class="headerlink" title="二、接口新特性"></a>二、接口新特性</h3><p>1、默认方法 default void test()<br>接口中的抽象方法一定要重写，如果有默认方法存在。多个实现了接口的类，可以不重写默认方法<br>2、静态方法<br>直接通过接口类名调用</p>
<p>3、两者的区别介绍<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647052456697-afd744e7-a8b6-45fa-a18f-1e93530a9166.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=103&id=u38de11f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=129&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95759&status=done&style=none&taskId=u515021a3-9317-4647-9937-89f30430d3e&title=&width=638.4" alt="image.png"> </p>
<h3 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h3><p>1、函数式接口的由来<br>lambda表达式只关心入参和返回值类型，重写接口中的方法，lambda表达式相当于一个实现类<br>2、函数式接口介绍<br>String.valueOf   将其他类型转为String<br>Double.valueOf  将字符串转为Double<br>Arrays.sort()  对数组进行排序<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647055257602-a0197426-9c17-4a99-add2-ebfccc91d7d8.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=82&id=u5a076924&margin=%5Bobject%20Object%5D&name=image.png&originHeight=103&originWidth=725&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42217&status=done&style=none&taskId=u75cbf198-88ef-4ec1-ab7b-975b6d25e89&title=&width=580" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647055306127-809a0863-58d9-4d67-8b50-08a4ff242434.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=113&id=u36c4a84a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75678&status=done&style=none&taskId=uab77bf00-9f5d-4e85-9117-3af37cca920&title=&width=940.8" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647056563032-83df341e-e443-4516-a18c-1e8f9933e31a.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=553&id=ua57197a8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=691&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139462&status=done&style=none&taskId=uf41cd682-b9f2-4f57-9aad-2269042a232&title=&width=472" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647056708846-37275818-55bc-4ef6-abdc-e3af6a33b73a.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u2ac6c9a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=1214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68238&status=done&style=none&taskId=uc5a8dbd3-6bef-4f08-9532-226b7c61b32&title=&width=971.2" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647062445281-051a04ab-63bd-44d6-9914-8101ae1656da.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=83&id=u93609191&margin=%5Bobject%20Object%5D&name=image.png&originHeight=104&originWidth=311&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14571&status=done&style=none&taskId=u7de84a6c-a3a0-4007-b451-9ab5fa307a4&title=&width=248.8" alt="image.png"></p>
<p>jdk提供了以上四种函数式接口，我们就不用自己再去写接口了</p>
<h3 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647068201968-98703cab-447c-45d0-890f-1655f13c5733.png#clientId=uaa1f0038-92a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=724&id=u53dde557&margin=%5Bobject%20Object%5D&name=image.png&originHeight=905&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281748&status=done&style=none&taskId=ucfbe09bc-3cc5-49f2-aad8-2594d8fd6c3&title=&width=964" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647077532053-eb2ec73a-5ebd-4d9a-a149-253f022a7805.png#clientId=u3d4aae83-b6ce-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=164&id=u50a8c6d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102734&status=done&style=none&taskId=ueebde7b7-f499-49b4-871b-6468765c809&title=&width=792.8" alt="image.png"><br>对象名::方法名<br>类名::静态方法名<br>类名::方法名<br>类名::构造器<br>数组::构造器</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647166775189-4fc4f1df-2047-4df9-83ca-a7ac1875f0de.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u3ed3b079&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=746&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200596&status=done&style=none&taskId=u61ef2c4d-4333-4e1d-a048-f67fd83500e&title=&width=596.8" alt="image.png"></p>
<h3 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="五、Stream API"></a>五、Stream API</h3><p>定义一个List集合  Arrays.asList()   主要针对集合的操作进行优化</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong>集合数据处理举例：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647167402749-d216eab5-b61e-419f-83d3-97678a08cfd3.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=562&id=ub62bdf79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=1259&originalType=binary&ratio=1&rotation=0&showTitle=false&size=261806&status=done&style=none&taskId=u14d50692-7080-4b55-89b7-584931f439a&title=&width=1007.2" alt="image.png"></p>
<p>Stream对数据进行加工处理，filter、map、skip、count</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168172502-addcc8dd-9ccf-490f-a388-92c969283727.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=519&id=u7fe5d9d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=1213&originalType=binary&ratio=1&rotation=0&showTitle=false&size=330818&status=done&style=none&taskId=u505ff1b5-31ce-4d06-8d6d-16afb9df596&title=&width=970.4" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168463324-78e4b3ea-7367-4466-bc0b-a79776390c60.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=519&id=ud47c6cd6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=274970&status=done&style=none&taskId=ucf5dade7-cb2a-45c0-8367-6d08b4f40ab&title=&width=976" alt="image.png"></p>
<p><strong>stream要调用终结方法才有作用</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168829000-bf606e0a-fff3-4fb3-ada7-2e412dc40e43.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=92&id=u7fabf8ec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25255&status=done&style=none&taskId=ufaaa0e40-3efc-4c9d-a59e-5dc2f6f0ca3&title=&width=260" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647168875637-b13c740f-a065-46f7-aa44-21da381f1b29.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=84&id=ufddc94f0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29979&status=done&style=none&taskId=uc9cac828-dae4-49e9-90a1-57c46f0b4d1&title=&width=415.2" alt="image.png"><br>** 4.3 filter**<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169084499-e2e61f47-f308-4c5f-87e0-96719e30ac57.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u2137d325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=1234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=135991&status=done&style=none&taskId=u20911917-c1c1-4a7e-b451-26ad7765172&title=&width=987.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169234120-a858d482-d797-4e8c-be8f-5eb5a2b8d96b.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=u85cf442b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=462&originWidth=1059&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92138&status=done&style=none&taskId=u2a107a58-81f1-42f0-9b5b-e9fca597623&title=&width=847.2" alt="image.png"></p>
<p><strong>4.5 skip</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169430333-6b0c70ff-1a67-42df-b506-29cb0b11a12f.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=74&id=uc2e3c241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=92&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31507&status=done&style=none&taskId=uf610f471-676f-4617-8aa8-2b659af18b8&title=&width=588.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169646238-d0fbedf8-9476-4d65-8f53-044b5cb45b1e.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=666&id=udc06268f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=833&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=285922&status=done&style=none&taskId=u0778cc04-433c-4e55-a765-d2036994867&title=&width=1024" alt="image.png"><br><strong>4.7 sorted</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647169776843-921b1887-4377-4c78-80ec-cbc494955b74.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u1a16dabc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=942&originalType=binary&ratio=1&rotation=0&showTitle=false&size=150944&status=done&style=none&taskId=ub5c3819e-effc-4f71-8fda-289a3b74f3f&title=&width=753.6" alt="image.png"><br>o2 - o1 代表降序  sorted默认是升序<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170041222-fb4adeab-9d23-488a-994c-e1944796b62d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=110&id=u576716be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28624&status=done&style=none&taskId=u905f037b-80d4-4373-b12f-405597e27ac&title=&width=370.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170236073-286439de-50d9-44cb-ab73-3f398bfc36ff.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=u06a06ffe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140025&status=done&style=none&taskId=u957ebc71-348c-4868-8ebe-3af7a2dad02&title=&width=968" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170377654-35a78b6d-8fd6-4ccc-bbae-e1916be6aa81.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=u41228ccc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105746&status=done&style=none&taskId=u69a247ff-bcf8-42bc-8276-57fa2b4ea9c&title=&width=968" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170439395-3ee72977-88c4-4641-b326-491616080ef5.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=90&id=u502e2250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=521&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31675&status=done&style=none&taskId=u7750f4c0-3137-4ea4-b6f8-879ce3674ad&title=&width=416.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170599823-faf233fd-2efe-4e6b-a7cc-7615b05b801e.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u41422863&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121661&status=done&style=none&taskId=ud076ce4d-15b4-4715-9baa-afddd0e51f9&title=&width=928.8" alt="image.png"><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170622800-0499edf1-c225-4195-8b2f-16b30d57e5ac.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=u2d0038fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=591&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39919&status=done&style=none&taskId=ue95b8bab-a57e-4e4f-abcb-5be17d67767&title=&width=472.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647170993407-22eac015-e324-411d-99a3-e57350b24556.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=198&id=ua7924805&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55506&status=done&style=none&taskId=u3fa10043-45f4-49d2-991e-d9ddb487edd&title=&width=671.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647172388224-ec691e4f-79ca-4c61-a328-25f2685f4087.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=230&id=u91872cb2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113939&status=done&style=none&taskId=u8cce103b-bc31-491f-b5c0-9d34add5395&title=&width=574.4" alt="image.png"><br>-&gt; 叫做箭头</p>
<p><strong>4.13 map与reduce的结合</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647172817396-d10786d0-b847-470b-89cb-bf6cffdbf277.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=ubd87fe22&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297685&status=done&style=none&taskId=ubf08f031-f490-44c0-8f20-7764f43c124&title=&width=800" alt="image.png"></p>
<p>stream对包装类进行操作i，比如Integer</p>
<p>Integer.intValue 把String转为int</p>
<p><strong>4.14 mapToInt</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175783195-e9d17cbc-5fbc-40fd-ae01-3414fbec94d4.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=u35db0212&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&size=193753&status=done&style=none&taskId=u3d4d0fed-db1b-4633-a354-9dfa21166cf&title=&width=948.8" alt="image.png"><br> <img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175933281-d192541b-2ee5-4f99-b327-226a69cb1d0d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=72&id=ua8910985&margin=%5Bobject%20Object%5D&name=image.png&originHeight=90&originWidth=758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41359&status=done&style=none&taskId=u4605c6b1-817b-4c73-9bef-15104c556b1&title=&width=606.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647175938173-515d3fe2-e9a2-4d8f-848b-85c597eab22f.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=204&id=u72f1c526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=1195&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108482&status=done&style=none&taskId=ud4a84833-3bed-4502-9cf4-afbc2f9d4f9&title=&width=956" alt="image.png"></p>
<p><strong>4.16 综合案例</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647177637801-30c16d42-6e8a-4ebe-9ac5-18751838ae00.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=u16d869c5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=334&originWidth=621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136831&status=done&style=none&taskId=u3a2108f0-89a3-400d-be86-5e4d6d1576e&title=&width=496.8" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.bobo.jdk.stream;</span><br><span class="line">import com.bobo.jdk.lambda.domain.Person;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line">public class StreamTest21Demo &#123;</span><br><span class="line">/**</span><br><span class="line">* 1. 第一个队伍只保留姓名长度为3的成员</span><br><span class="line">* 2. 第一个队伍筛选之后只要前3个人</span><br><span class="line">* 3. 第二个队伍只要姓张的成员</span><br><span class="line">* 4. 第二个队伍筛选之后不要前两个人</span><br><span class="line">* 5. 将两个队伍合并为一个队伍</span><br><span class="line">* 6. 根据姓名创建Person对象输出结果：</span><br><span class="line">5.Stream结果收集</span><br><span class="line">5.1 结果收集到集合中</span><br><span class="line">* 7. 打印整个队伍的Person信息</span><br><span class="line">* @param args</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list1 = Arrays.asList(&quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;, &quot;老子&quot;,</span><br><span class="line">&quot;庄子&quot;, &quot;孙子&quot;, &quot;洪七 公&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(&quot;古力娜扎&quot;, &quot;张无忌&quot;, &quot;张三丰&quot;, &quot;赵丽颖&quot;,</span><br><span class="line">&quot;张二狗&quot;, &quot;张天爱&quot;, &quot;张三&quot;);</span><br><span class="line">// 1. 第一个队伍只保留姓名长度为3的成员</span><br><span class="line">// 2. 第一个队伍筛选之后只要前3个人</span><br><span class="line">Stream&lt;String&gt; stream1 = list1.stream().filter(s -&gt; s.length() ==</span><br><span class="line">3).limit(3);</span><br><span class="line">// 3. 第二个队伍只要姓张的成员</span><br><span class="line">// 4. 第二个队伍筛选之后不要前两个人</span><br><span class="line">Stream&lt;String&gt; stream2 = list2.stream().filter(s -&gt;</span><br><span class="line">s.startsWith(&quot;张&quot;)).skip(2);</span><br><span class="line">// 5. 将两个队伍合并为一个队伍</span><br><span class="line">// 6. 根据姓名创建Person对象</span><br><span class="line">// 7. 打印整个队伍的Person信息</span><br><span class="line">Stream.concat(stream1,stream2)</span><br><span class="line">//.map(n-&gt; new Person(n))</span><br><span class="line">.map(Person::new)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要test测试，可以引入 junit 依赖</p>
<h4 id="Stream结果收集"><a href="#Stream结果收集" class="headerlink" title="Stream结果收集"></a>Stream结果收集</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647178563912-c6591790-b342-4a4e-9979-9ead888f6a13.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=129&id=u7adbce3e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=161&originWidth=334&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25070&status=done&style=none&taskId=u6940cf2f-de4a-426f-a72d-4b7cdb33c72&title=&width=267.2" alt="image.png"><br><strong>聚合运算：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* Stream流中数据的聚合计算</span><br><span class="line">*/</span><br><span class="line">@Testpublic void test03()&#123;</span><br><span class="line">// 获取年龄的最大值</span><br><span class="line">Optional&lt;Person&gt; maxAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">System.out.println(&quot;最大年龄：&quot; + maxAge.get());</span><br><span class="line">// 获取年龄的最小值</span><br><span class="line">Optional&lt;Person&gt; minAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">System.out.println(&quot;最新年龄:&quot; + minAge.get());</span><br><span class="line">// 求所有人的年龄之和</span><br><span class="line">Integer sumAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">)</span><br><span class="line">//.collect(Collectors.summingInt(s -&gt; s.getAge()))</span><br><span class="line">.collect(Collectors.summingInt(Person::getAge))</span><br><span class="line">;</span><br><span class="line">System.out.println(&quot;年龄总和：&quot; + sumAge);</span><br><span class="line">// 年龄的平均值</span><br><span class="line">Double avgAge = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).collect(Collectors.averagingInt(Person::getAge));</span><br><span class="line">System.out.println(&quot;年龄的平均值：&quot; + avgAge);</span><br><span class="line">// 统计数量</span><br><span class="line">Long count = Stream.of(</span><br><span class="line">new Person(&quot;张三&quot;, 18)</span><br><span class="line">, new Person(&quot;李四&quot;, 22)</span><br><span class="line">, new Person(&quot;张三&quot;, 13)</span><br><span class="line">, new Person(&quot;王五&quot;, 15)</span><br><span class="line">, new Person(&quot;张三&quot;, 19)</span><br><span class="line">).filter(p-&gt;p.getAge() &gt; 18)</span><br><span class="line">.collect(Collectors.counting());</span><br><span class="line">System.out.println(&quot;满足条件的记录数:&quot; + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组分组：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179626317-254cdac5-c34d-4dc2-849f-d84984c06d54.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=524&id=ud90100e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=655&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180622&status=done&style=none&taskId=u70b49964-2bee-4904-8731-c3d3b45f8c2&title=&width=627.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179638583-d8484c76-f18e-4767-9f89-584a99c3a08d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=241&id=u3ae54ac1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98518&status=done&style=none&taskId=u44894e9a-2ec9-4a95-8337-3fd55ad8eba&title=&width=624.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179651531-503736f8-5a4c-44fe-96ec-f2757d7f64db.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=584&id=u6108f6f0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146207&status=done&style=none&taskId=ub2a321f5-75ed-4d5b-b2a7-b7e15a304ec&title=&width=751.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647179660821-c377f2b0-dbd4-4e64-baf1-a713fffa4a7d.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ue6d20e07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56925&status=done&style=none&taskId=uacf4ca4b-6a14-48a4-80e5-d7b270d81d6&title=&width=614.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180654573-e7a407f3-ffbc-4bbe-95e3-6efb69aa2218.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=80&id=u4df3d602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=100&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73903&status=done&style=none&taskId=u1dc5b796-bff6-42ec-bb1c-5fa1737d797&title=&width=792" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180677098-1cadc779-e2b1-4c5a-8d10-b52c6bd06a86.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=478&id=u63cf98f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1173&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237475&status=done&style=none&taskId=uca829a68-06b1-4ead-937b-776b843af90&title=&width=938.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647180837472-fb80d88f-ea35-4918-a62e-59b2004c93b1.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=586&id=u966eb087&margin=%5Bobject%20Object%5D&name=image.png&originHeight=733&originWidth=585&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166511&status=done&style=none&taskId=u0e0278c4-471f-43ae-a764-60bac8a1329&title=&width=468" alt="image.png"></p>
<h4 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h4><p>之前的Stream操作都是串行流，它们都是在一个线程中去操作，因此效率不是很高</p>
<p>获取并行流的两种方式：<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647181128005-f647a650-850c-4c76-ab09-60e33c70e266.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u14d06f5d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106286&status=done&style=none&taskId=uaac7c4ba-4f27-4b89-9f57-3eb902a98a3&title=&width=636" alt="image.png"><br> 并行流就是转换成多线程处理<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647181628393-92ff0244-2bd7-40ae-bc2e-9aad634f4602.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=u61d988c9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=97&originWidth=1013&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71388&status=done&style=none&taskId=u53bc737f-992c-4d96-8a08-801de0ec736&title=&width=810.4" alt="image.png"></p>
<p><strong>并行流中的线程安全问题</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647182090800-ea4afd80-1047-4336-a03a-07f1ae5fc53b.png#clientId=u5b54d101-07d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=69&id=u693bd55f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=341&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21077&status=done&style=none&taskId=u9dbd05a3-255e-410c-a769-9313a57ceba&title=&width=272.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647184649734-ee71bab7-48d9-4580-82a6-fda775163a3c.png#clientId=uf2d0c17c-91f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u607dcf26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=421&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118752&status=done&style=none&taskId=u1259999d-441c-41c4-83fc-5cde74fd18e&title=&width=697" alt="image.png"></p>
<h3 id="六、Optional类"><a href="#六、Optional类" class="headerlink" title="六、Optional类"></a>六、Optional类</h3><p>解决空指针问题<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743599004-08b191de-e18c-4f73-b186-77839a73966d.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=ub450af9f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=1189&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122159&status=done&style=none&taskId=u4373d58f-4296-44bc-8a1b-d21aab4db17&title=&width=951.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743683010-ebb82e44-b390-4db1-bea7-5dabb6d24892.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=367&id=uf5803731&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=1102&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133437&status=done&style=none&taskId=u36c1298f-627a-472e-bb0e-a8343568010&title=&width=881.6" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647743837918-d7d451ff-30b3-4350-bac4-83a13a8407bd.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=435&id=u41f3b9fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223324&status=done&style=none&taskId=ue1d94bcb-d4e6-4acf-a0db-0f4fc37b7e0&title=&width=940" alt="image.png"></p>
<h4 id="Optional常用方法"><a href="#Optional常用方法" class="headerlink" title="Optional常用方法"></a>Optional常用方法</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647744191519-9ea36f5a-d550-4e3e-8fa5-48987186ca5b.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=222&id=u5070de8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=1074&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175401&status=done&style=none&taskId=uda2c94c1-0726-474d-a17e-60dd8c056e8&title=&width=859.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647745482613-a70fb790-959d-4d5a-82ad-da9f7592f40e.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=478&id=u8ac1d41e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&size=203328&status=done&style=none&taskId=ubfba51f2-44d2-46a9-9e71-81246c4646c&title=&width=636" alt="image.png"></p>
<h3 id="七、新日期时间API"><a href="#七、新日期时间API" class="headerlink" title="七、新日期时间API"></a>七、新日期时间API</h3><p>sdf.format 将时间转为字符串<br>sdf.parse  将字符串转为时间</p>
<p>想要不打印错误日志，可以 try catch 打印一下，可以把错误信息提示去除<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746317953-6786d83b-bcdb-46ed-8d25-6d857323ccd4.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=136&id=uc591c46b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144569&status=done&style=none&taskId=u3006f330-0abd-4313-92d9-04255a7a464&title=&width=996.8" alt="image.png"></p>
<p>新的API位于java.time包下</p>
<h4 id="新日期API介绍"><a href="#新日期API介绍" class="headerlink" title="新日期API介绍"></a>新日期API介绍</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746396473-0349ea86-25e7-4596-a70f-09f269d0f457.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=579&id=u0c209939&margin=%5Bobject%20Object%5D&name=image.png&originHeight=724&originWidth=1047&originalType=binary&ratio=1&rotation=0&showTitle=false&size=378576&status=done&style=none&taskId=ua871272d-8a07-4bd8-9667-a64d20f629a&title=&width=837.6" alt="image.png"><br>日期时间类型：<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746584959-84dfd393-ddbc-414b-8ea6-23a1fbddb045.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=442&id=u443e977a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=283749&status=done&style=none&taskId=uf366d8e0-78b1-48d1-b58e-2e08655b123&title=&width=884.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746669098-c69f00f8-1ced-470f-a4c5-1c269ca270ad.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=321&id=u4248d8a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=1092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208704&status=done&style=none&taskId=u018cbf5e-9a1f-4190-be8c-1a6e23f855c&title=&width=873.6" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746737104-e921d675-3d52-465a-83ef-70273d3a6e2a.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=463&id=ub8f12d62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179792&status=done&style=none&taskId=uaabaac09-2230-44b6-aad7-acb296c5fcc&title=&width=554.4" alt="image.png"><br>LocalDate、LocalTime、LocalDateTime的操作</p>
<h4 id="日期时间的修改和比较"><a href="#日期时间的修改和比较" class="headerlink" title="日期时间的修改和比较"></a>日期时间的修改和比较</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647746979632-3ebe66c5-3281-4fa8-ab6a-39d7e707e83c.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=348&id=ude506394&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197602&status=done&style=none&taskId=u5786614b-575b-40d3-80a7-7882f632e68&title=&width=751.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747163521-9d9f746f-d8d8-46ca-912c-6dda46a9f7c8.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=494&id=u40ab0fdd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=303832&status=done&style=none&taskId=u986d62ac-18f0-40b9-9014-507c70af771&title=&width=764.8" alt="image.png"><br>变量后加soutv，可以快速打印，并且是v = 的形式<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747360936-51b80635-f45e-44ff-b1e8-54b70789664f.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=334&id=u74e0693f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204069&status=done&style=none&taskId=u96db3670-0c7b-49b1-a245-9e43918356e&title=&width=769.6" alt="image.png"><br>新日期API在多线程场景下是日期安全的，因为他创建了一个新对象，不是在原对象基础上修改的</p>
<h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747567914-6737e3ba-c7f3-498b-9e12-0bbceaf1ee5d.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=360&id=uda475eec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&size=299194&status=done&style=none&taskId=u141ebb62-febf-4906-85e4-3be55e90007&title=&width=1012" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647747639659-16bb6f50-b9ea-4d4f-9213-091daeda2011.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=143&id=u14867fbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=179&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109495&status=done&style=none&taskId=u4f7ad158-e52b-488a-a64e-475575b3103&title=&width=955.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748259901-7b8787ea-4f14-43c9-b4db-2612d5fa5a14.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=116&id=u50d66240&margin=%5Bobject%20Object%5D&name=image.png&originHeight=145&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65035&status=done&style=none&taskId=u93f47d88-1f85-4da2-be09-2d8e42e4b21&title=&width=490.4" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748172134-3138a5a2-f8a1-4580-b00e-7293df637fe5.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=438&id=uaf1fcb26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252551&status=done&style=none&taskId=u967fca3e-0e36-462d-95a0-847fed13f3c&title=&width=734.4" alt="image.png"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748632770-069986bb-ba90-4a16-8a76-01caf5caee6a.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=113&id=u4d0a4b31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67287&status=done&style=none&taskId=u4794be92-5689-4b13-81b0-300b0fa05d7&title=&width=688" alt="image.png"><br>使用方法引用打印更加的简洁<br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748836615-aeadf7ea-85a8-45b7-8c19-c83595e6a94e.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=769&id=uc3a68617&margin=%5Bobject%20Object%5D&name=image.png&originHeight=961&originWidth=1224&originalType=binary&ratio=1&rotation=0&showTitle=false&size=498945&status=done&style=none&taskId=ueb268e45-dcad-43aa-9d5f-345ea507ab2&title=&width=979.2" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647748960552-503db30c-9118-414f-a1c5-1f91addfa5c0.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=uaef9a9b9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=237&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119465&status=done&style=none&taskId=ue30be5b6-8ad7-402a-9715-bcf78e05b76&title=&width=768" alt="image.png"></p>
<h3 id="八、其他新特性"><a href="#八、其他新特性" class="headerlink" title="八、其他新特性"></a>八、其他新特性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647749367561-15481f08-5408-4e50-a762-ba9ced27ef07.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=513&id=u0733fda8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=641&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156840&status=done&style=none&taskId=u73d5fecf-de65-4bd0-99df-7b64ed9f20e&title=&width=620.8" alt="image.png"><br><img data-src="https://cdn.nlark.com/yuque/0/2022/png/12855610/1647749476548-015f1e9c-08d9-4665-b31e-e42e850d0155.png#clientId=u3c2fd059-6ea7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=148&id=u93d98f85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=701&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64487&status=done&style=none&taskId=u2415e2cd-4be1-4c55-93d1-21bf847d7a7&title=&width=560.8" alt="image.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jdk新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/posts/c7f5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<blockquote>
<p>开始路途漫漫的计算机网络学习吧，视频来自<a href="https://www.bilibili.com/video/BV1c4411d7jb">计算机网络微课堂</a></p>
</blockquote>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/jpeg/12855610/1630208621955-a4a8ad3a-087d-4521-ab8a-0ca28358b4fd.jpeg?x-oss-process=image/resize,w_750,limit_0"><br>​<span id="more"></span></p>
<h1 id="第1章（概述）"><a href="#第1章（概述）" class="headerlink" title="第1章（概述）"></a>第1章（概述）</h1><h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628777569933-58dd3f9a-ce38-4aba-8626-27d783e01a07.png#clientId=u5bcd3f52-855b-4&from=paste&height=104&id=ubbcf1626&margin=%5Bobject%20Object%5D&name=&originHeight=104&originWidth=1000&originalType=binary&ratio=1&size=96303&status=done&style=none&taskId=uf1ac7f41-93c7-4c5d-ae49-9a88e2478cf&width=1000"></p>
<h2 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628778640771-c607a095-9977-4e60-a27f-d55a4c498e29.png#clientId=u5bcd3f52-855b-4&from=paste&height=179&id=uc944f721&margin=%5Bobject%20Object%5D&name=&originHeight=179&originWidth=1163&originalType=binary&ratio=1&size=131039&status=done&style=none&taskId=u4f04652f-227b-48dc-87c2-23f6d7952ae&width=1163"></p>
<h3 id="因特网服务提供者ISP"><a href="#因特网服务提供者ISP" class="headerlink" title="因特网服务提供者ISP"></a>因特网服务提供者ISP</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779152193-65729399-20d2-4595-9036-3ef181486f82.png#clientId=u5bcd3f52-855b-4&from=paste&height=644&id=uc6be73cd&margin=%5Bobject%20Object%5D&name=&originHeight=644&originWidth=1047&originalType=binary&ratio=1&size=459365&status=done&style=none&taskId=u31f8023d-1da3-4b27-8154-e89ce8957c6&width=1047"></p>
<h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779468596-76a020d5-8599-4ae4-bbe3-4304145f3a17.png#clientId=u5bcd3f52-855b-4&from=paste&height=630&id=u93a628ff&margin=%5Bobject%20Object%5D&name=&originHeight=630&originWidth=1300&originalType=binary&ratio=1&size=464641&status=done&style=none&taskId=u9a57a76d-e150-4a63-9871-f075b8eb7f2&width=1300"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628779815480-8af16f6f-f25b-4d48-9014-53176b717c1d.png#clientId=u5bcd3f52-855b-4&from=paste&height=282&id=u86ebf233&margin=%5Bobject%20Object%5D&name=&originHeight=282&originWidth=1083&originalType=binary&ratio=1&size=95378&status=done&style=none&taskId=u828a76be-e1a3-422b-9d0d-d3547a5626c&width=1083"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>用户发送的信息称为报文，将报文分成等长的数据段，数据段加上首部称为分组，也可简称为”包”。首部存放的是分组的目的地址<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628780330715-dfe331ed-8243-48aa-bacc-d23e41a69ff3.png#clientId=u5bcd3f52-855b-4&from=paste&height=521&id=u525e3440&margin=%5Bobject%20Object%5D&name=&originHeight=521&originWidth=984&originalType=binary&ratio=1&size=228921&status=done&style=none&taskId=u2af371e5-b3a3-4d48-8b8e-f308b9fa7c8&width=984"></p>
<h3 id="电路交换、分组交换、报文交换的对比"><a href="#电路交换、分组交换、报文交换的对比" class="headerlink" title="电路交换、分组交换、报文交换的对比"></a>电路交换、分组交换、报文交换的对比</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628841426201-9638448d-ba29-4861-8d10-f91f80f6db19.png#clientId=u5bb285be-1404-4&from=paste&height=425&id=u5e1ac898&margin=%5Bobject%20Object%5D&name=&originHeight=849&originWidth=1874&originalType=binary&ratio=1&size=770247&status=done&style=none&taskId=ub3a5cbab-12d9-4f81-ad5c-a2156053f5d&width=937"></p>
<h2 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628845551278-72841815-6d10-4d00-9446-f98d03d7adee.png#clientId=u5bb285be-1404-4&from=paste&height=104&id=u6f83d95b&margin=%5Bobject%20Object%5D&name=&originHeight=207&originWidth=1142&originalType=binary&ratio=1&size=278066&status=done&style=none&taskId=u0350f4b5-b06d-431b-89f4-76518a998a5&width=571"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>广域网覆盖范围大，局域网覆盖范围小，<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628846531841-26ab0036-589b-4a75-9ad4-1b8bc16d639d.png#clientId=u5bb285be-1404-4&from=paste&height=439&id=u1b0bc7d0&margin=%5Bobject%20Object%5D&name=&originHeight=878&originWidth=1094&originalType=binary&ratio=1&size=668143&status=done&style=none&taskId=u2c86f648-0382-4734-8d49-2c6b781bcac&width=547"></p>
<h2 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628943139704-18617916-77e1-4530-b4bf-014cd51856c0.png#clientId=u008fe770-74df-4&from=paste&height=231&id=u93ed42de&margin=%5Bobject%20Object%5D&name=&originHeight=461&originWidth=1599&originalType=binary&ratio=1&size=400174&status=done&style=none&taskId=uf3ee2cdf-3602-4fb5-bf22-476adf0b4ab&width=799.5"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628943540735-34976ced-d791-4e38-8885-f7947781f2f8.png#clientId=u008fe770-74df-4&from=paste&height=338&id=u0cecd14e&margin=%5Bobject%20Object%5D&name=&originHeight=675&originWidth=1604&originalType=binary&ratio=1&size=408215&status=done&style=none&taskId=u955ff525-4a15-460e-9f73-05aa11e1e52&width=802"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>最好控制信道利用率为50%</p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>只有网络拥塞时才会出现丢包</p>
<h2 id="1-6-计算机网络的体系结构"><a href="#1-6-计算机网络的体系结构" class="headerlink" title="1.6 计算机网络的体系结构"></a>1.6 计算机网络的体系结构</h2><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1628944041887-4f8d25b7-21c5-4e50-aac2-807f71dd964e.png#clientId=u008fe770-74df-4&from=paste&height=403&id=uc6766672&margin=%5Bobject%20Object%5D&name=&originHeight=805&originWidth=1220&originalType=binary&ratio=1&size=498670&status=done&style=none&taskId=ud21a8693-6662-4088-9409-3ab19027eb9&width=610"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629102778484-a4375c7d-e25c-46c5-a4b7-634f09065303.png#clientId=u64bc25fb-3b69-4&from=paste&height=188&id=uea4d7f43&margin=%5Bobject%20Object%5D&name=&originHeight=375&originWidth=935&originalType=binary&ratio=1&size=187683&status=done&style=none&taskId=u52f62287-7221-4a4d-8296-17879e42a02&width=467.5"><br>TCP/IP协议协议中，TCP协议和IP协议是比较重要的，IP协议互连不同的网络接口，TCP协议提供数据有效传输<br>四层的TCP/IP协议是国际标准<br>学习计算机网络时，一般折中采用五层协议进行学习<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629102958791-c724a7a7-d0cf-4f1f-9f65-a90dc387d1e5.png#clientId=u64bc25fb-3b69-4&from=paste&height=307&id=ufb7bec20&margin=%5Bobject%20Object%5D&name=&originHeight=613&originWidth=590&originalType=binary&ratio=1&size=230227&status=done&style=none&taskId=u557781a2-d4aa-4a3f-91b9-2e17874c26a&width=295"></p>
<h3 id="计算机网络结构分层的必要性"><a href="#计算机网络结构分层的必要性" class="headerlink" title="计算机网络结构分层的必要性"></a>计算机网络结构分层的必要性</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629103392690-4af6eef5-7d70-4750-8369-787181a976b9.png#clientId=u64bc25fb-3b69-4&from=paste&height=364&id=u8560b7aa&margin=%5Bobject%20Object%5D&name=&originHeight=727&originWidth=1817&originalType=binary&ratio=1&size=932937&status=done&style=none&taskId=uf6acf1b9-4a78-4de9-be04-7f6f23ee14c&width=908.5"></p>
<p>计算机网络的分层处理方法，使得数据能够正确传输</p>
<p>各层数据包的举例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629104185818-c08fce11-d4e4-4410-b6fb-1baa70ad5977.png#clientId=u64bc25fb-3b69-4&from=paste&height=366&id=u7361f9a6&margin=%5Bobject%20Object%5D&name=&originHeight=732&originWidth=1128&originalType=binary&ratio=1&size=827790&status=done&style=none&taskId=u69ee9565-cc86-4155-a83b-39ad3261dcd&width=564"><br>下面的协议对上面的实体是透明的</p>
<h2 id="1-7-习题课"><a href="#1-7-习题课" class="headerlink" title="1.7 习题课"></a>1.7 习题课</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629117738283-1cb1a1ae-e61e-4851-bb12-deeb2b02ad3b.png#clientId=ubd2f1b92-2427-4&from=paste&height=123&id=udc342371&margin=%5Bobject%20Object%5D&name=&originHeight=123&originWidth=1191&originalType=binary&ratio=1&size=83808&status=done&style=none&taskId=u7667cc77-34b5-4d7b-a959-9e47d9dc398&width=1191"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629118231321-b842b248-fd5e-4d57-9684-1569864a06f4.png#clientId=ubd2f1b92-2427-4&from=paste&height=288&id=uc8176aee&margin=%5Bobject%20Object%5D&name=&originHeight=288&originWidth=689&originalType=binary&ratio=1&size=135451&status=done&style=none&taskId=u6424df0c-3db1-47f3-ba40-ee60b7a2fb8&width=689"><br>时延计算略<br>​</p>
<h1 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章(物理层)"></a>第2章(物理层)</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629200527694-948834b0-bc43-4c48-b56e-fcc4d4c63a12.png#clientId=u1eb3b024-ecfa-4&from=paste&height=438&id=uc4aa2912&margin=%5Bobject%20Object%5D&name=&originHeight=438&originWidth=629&originalType=binary&ratio=1&size=261785&status=done&style=none&taskId=u730c5340-7af5-4928-a773-62bcfcc5561&width=629"></p>
<h2 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629200855340-646208c1-d520-4774-80e4-51df205cebc4.png#clientId=u1eb3b024-ecfa-4&from=paste&height=128&id=u1cab68d1&margin=%5Bobject%20Object%5D&name=&originHeight=128&originWidth=1364&originalType=binary&ratio=1&size=98667&status=done&style=none&taskId=ueeb2f2a5-01d2-4c57-b4c4-73b5c92f72a&width=1364"></p>
<h2 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629201175213-957f0e0c-59c8-4ba9-9c47-b084e2d006d8.png#clientId=u1eb3b024-ecfa-4&from=paste&height=98&id=ueb416d47&margin=%5Bobject%20Object%5D&name=&originHeight=98&originWidth=1322&originalType=binary&ratio=1&size=62170&status=done&style=none&taskId=u0731372b-75b5-4700-ac94-51366553951&width=1322"><br>计算机网络采用串行传输，计算机内部采用并行传输<br>双向同时通信需要两个信道，举例来说就是电话</p>
<h2 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h2><p>把数字信号转换为模拟信号，在模拟信道中传输，称为调制<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629201848075-40b2b230-6c51-4007-810d-e3a4dbd3e8bc.png#clientId=u1eb3b024-ecfa-4&from=paste&height=524&id=u1e6a7732&margin=%5Bobject%20Object%5D&name=&originHeight=524&originWidth=1214&originalType=binary&ratio=1&size=243345&status=done&style=none&taskId=udb5a7a5a-a603-4911-9dce-a6248f32e28&width=1214"></p>
<h2 id="2-5-信道的极限容量"><a href="#2-5-信道的极限容量" class="headerlink" title="2.5 信道的极限容量"></a>2.5 信道的极限容量<img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629202078655-40d685d9-732d-4faa-bed7-ac8150891280.png#clientId=u1eb3b024-ecfa-4&from=paste&height=587&id=ub64dcd8d&margin=%5Bobject%20Object%5D&name=&originHeight=587&originWidth=1294&originalType=binary&ratio=1&size=351376&status=done&style=none&taskId=u235bff9a-6313-4752-919e-33bd8733634&width=1294"></h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629203564639-b25b0344-4fee-4e93-bfcd-ccad61a1bd76.png#clientId=u5cb0ce9a-30ea-4&from=paste&height=102&id=ua455be91&margin=%5Bobject%20Object%5D&name=&originHeight=102&originWidth=1152&originalType=binary&ratio=1&size=111983&status=done&style=none&taskId=ue7689295-cce4-4ffe-abc8-062a578ba1a&width=1152"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629203626245-d42138f6-e427-49f7-95aa-f726a1a78e7f.png#clientId=u5cb0ce9a-30ea-4&from=paste&height=462&id=ub966c689&margin=%5Bobject%20Object%5D&name=&originHeight=462&originWidth=1012&originalType=binary&ratio=1&size=208642&status=done&style=none&taskId=ue150b397-b462-450f-890a-dcfc5dc2d2a&width=1012"></p>
<h1 id="第3章-数据链路层"><a href="#第3章-数据链路层" class="headerlink" title="第3章(数据链路层)"></a>第3章(数据链路层)</h1><h2 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h2><p>封装成帧   差错检测   可靠传输</p>
<h2 id="3-2-封装成帧"><a href="#3-2-封装成帧" class="headerlink" title="3.2 封装成帧"></a>3.2 封装成帧</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290277118-dd210354-686c-4704-bc50-654f3ae6e50f.png#clientId=ua9168488-b0f8-4&from=paste&height=284&id=u7e86c531&margin=%5Bobject%20Object%5D&name=&originHeight=284&originWidth=1009&originalType=binary&ratio=1&size=198401&status=done&style=none&taskId=u910c6f2c-ad08-45ed-acb7-7961f34e2e2&width=1009"></p>
<h2 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290534706-57cc08d2-63be-4eca-aaa3-d2662a3127c2.png#clientId=ua9168488-b0f8-4&from=paste&height=229&id=ue662ebaf&margin=%5Bobject%20Object%5D&name=&originHeight=229&originWidth=1118&originalType=binary&ratio=1&size=194303&status=done&style=none&taskId=u4f1f72ef-d744-4cec-b970-dd10c5db9c3&width=1118"><br>差错检测方法：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290789366-68ba85f3-8017-488d-9191-d645b78ff6ea.png#clientId=ua9168488-b0f8-4&from=paste&height=213&id=u553f9740&margin=%5Bobject%20Object%5D&name=&originHeight=213&originWidth=1107&originalType=binary&ratio=1&size=191730&status=done&style=none&taskId=ua382a9c1-f1f7-4548-8489-083eb43054f&width=1107"><br>奇偶校验差错高，计算机网络一般不采用这种方法<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629290866564-4c155a10-07d4-4ba3-a2c3-9b7722daa9d1.png#clientId=ua9168488-b0f8-4&from=paste&height=196&id=u763f8ddf&margin=%5Bobject%20Object%5D&name=&originHeight=196&originWidth=1226&originalType=binary&ratio=1&size=128459&status=done&style=none&taskId=ucfa771b0-e329-435c-8142-2820364d364&width=1226"><br>循环冗余校验CRC有很好的检错能力，漏检率非常低。<br>检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误。</p>
<h2 id="3-4-可靠传输的基本概念"><a href="#3-4-可靠传输的基本概念" class="headerlink" title="3.4 可靠传输的基本概念"></a>3.4 可靠传输的基本概念</h2><p>可靠传输的实现机制：</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629292662338-65b7f3be-90c8-4359-ab23-16bd67be040c.png#clientId=ua9168488-b0f8-4&from=paste&height=617&id=uf88c4940&margin=%5Bobject%20Object%5D&name=&originHeight=617&originWidth=1312&originalType=binary&ratio=1&size=733181&status=done&style=none&taskId=u3c6ddb6d-7fd1-4dec-beec-6eae827c499&width=1312"><br><strong>数据分组和确认分组需要进行编号</strong></p>
<h3 id="回退N帧协议"><a href="#回退N帧协议" class="headerlink" title="回退N帧协议"></a>回退N帧协议</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629294865323-fd01821d-ed19-47fb-bda4-ccf550b21daf.png#clientId=ua9168488-b0f8-4&from=paste&height=690&id=u2958ac55&margin=%5Bobject%20Object%5D&name=&originHeight=690&originWidth=1312&originalType=binary&ratio=1&size=580852&status=done&style=none&taskId=u4492cdc6-155a-4daa-ba68-ee092892049&width=1312"><br>回退N帧协议又叫发送窗口协议<br>​</p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>为了避免对通信资源的极大浪费，接收窗口的尺寸WR 不应该再等于1<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629296593908-9e67ae88-5c8c-4c13-ae66-444f2b69ca6a.png#clientId=ua9168488-b0f8-4&from=paste&height=577&id=u46696a81&margin=%5Bobject%20Object%5D&name=&originHeight=577&originWidth=1322&originalType=binary&ratio=1&size=369006&status=done&style=none&taskId=u82530c8b-956a-4ba3-8b35-7d14a46d4e0&width=1322"></p>
<h2 id="3-5-点对点协议PPP"><a href="#3-5-点对点协议PPP" class="headerlink" title="3.5 点对点协议PPP"></a>3.5 点对点协议PPP</h2><p>PPP协议是目前使用最广泛的点对点数据链路层协议<br>​</p>
<h2 id="3-6-媒体接入控制"><a href="#3-6-媒体接入控制" class="headerlink" title="3.6 媒体接入控制"></a>3.6 媒体接入控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629297686952-c9a95a94-9dc2-49ab-be72-7bc0cc83eedc.png#clientId=ua9168488-b0f8-4&from=paste&height=137&id=u3eb3596a&margin=%5Bobject%20Object%5D&name=&originHeight=137&originWidth=1305&originalType=binary&ratio=1&size=85954&status=done&style=none&taskId=u538331aa-b395-4aa8-85a2-adbbc0e6ea1&width=1305"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629298839897-0cf743dc-45c3-40c8-a17a-7fa7241d578e.png#clientId=ua9168488-b0f8-4&from=paste&height=460&id=u6e333eaa&margin=%5Bobject%20Object%5D&name=&originHeight=460&originWidth=1331&originalType=binary&ratio=1&size=474262&status=done&style=none&taskId=u00a7b1ae-c54a-458b-be16-2351ef88829&width=1331"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629299237438-6acadd2c-74e8-4da6-8fe9-6aafd356af2a.png#clientId=ua9168488-b0f8-4&from=paste&height=678&id=u81856fd3&margin=%5Bobject%20Object%5D&name=&originHeight=678&originWidth=1187&originalType=binary&ratio=1&size=511831&status=done&style=none&taskId=udcff65b9-de80-47bd-bda5-cd6564763fb&width=1187"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629300122249-e9ab13a0-246c-4eb7-95fb-f77d34517ef3.png#clientId=ua9168488-b0f8-4&from=paste&height=480&id=ue4d3e6c2&margin=%5Bobject%20Object%5D&name=&originHeight=480&originWidth=999&originalType=binary&ratio=1&size=193070&status=done&style=none&taskId=udce33ca2-47e0-48ce-956f-39c82239705&width=999"></p>
<p>CSMA协议有可能发生冲突，也称为碰撞<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301658247-638460fe-1b15-49b6-920e-ec3e6d0db37b.png#clientId=ua9168488-b0f8-4&from=paste&height=50&id=u3d4fc360&margin=%5Bobject%20Object%5D&name=&originHeight=50&originWidth=962&originalType=binary&ratio=1&size=35992&status=done&style=none&taskId=ucb6db744-1d1a-4939-b352-fd8d0d681ec&width=962"></p>
<h2 id="3-7-MAC地址、IP地址、ARP协议"><a href="#3-7-MAC地址、IP地址、ARP协议" class="headerlink" title="3.7 MAC地址、IP地址、ARP协议"></a>3.7 MAC地址、IP地址、ARP协议</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址属于数据链路层的范畴<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301904582-517c8a42-9a3f-4974-8dab-e9509565cd4c.png#clientId=ua9168488-b0f8-4&from=paste&height=303&id=u7a6a9dce&margin=%5Bobject%20Object%5D&name=&originHeight=303&originWidth=824&originalType=binary&ratio=1&size=372037&status=done&style=none&taskId=u3d2b4fec-06b4-4b2d-aee3-e90ff229a0d&width=824"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629301998830-48eebe72-6f79-4eb9-8264-f042c1f13ca3.png#clientId=ua9168488-b0f8-4&from=paste&height=76&id=ua24b333d&margin=%5Bobject%20Object%5D&name=&originHeight=76&originWidth=1123&originalType=binary&ratio=1&size=54042&status=done&style=none&taskId=uc91b7081-7c0d-4b33-b79c-049721aac7e&width=1123"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629302321990-6479766a-b622-4d60-9c97-b0ee86971e1c.png#clientId=ua9168488-b0f8-4&from=paste&height=367&id=ueaf2463e&margin=%5Bobject%20Object%5D&name=&originHeight=367&originWidth=1192&originalType=binary&ratio=1&size=238556&status=done&style=none&taskId=ua1762187-c5ac-4828-82e5-b1df28479c7&width=1192"><br>可以从组织唯一标识符，看出硬件生产产商，如华为、小米等，由IEEE分配组织唯一标识符<br>​</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>如果主机所在的网络要接入因特网，那么MAC地址和IP地址都要使用<br>习题：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629303483376-182f0e41-e291-40cb-8737-a62f2ec11dc8.png#clientId=ua9168488-b0f8-4&from=paste&height=373&id=u598afa0c&margin=%5Bobject%20Object%5D&name=&originHeight=373&originWidth=1086&originalType=binary&ratio=1&size=316979&status=done&style=none&taskId=u8515097b-b4e5-4000-8e63-42d6dd12432&width=1086"></p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如果未知目标设备的MAC地址，通过ARP协议，可以获得目标设备的MAC地址。<br>ARP协议只能在一段链路上使用，不能跨网络使用</p>
<h2 id="3-8-集线器与交换机的区别"><a href="#3-8-集线器与交换机的区别" class="headerlink" title="3.8 集线器与交换机的区别"></a>3.8 集线器与交换机的区别</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629303816796-82fa3ecd-6610-4d9d-aeee-6e313b32fd35.png#clientId=ua9168488-b0f8-4&from=paste&height=350&id=ubfb21641&margin=%5Bobject%20Object%5D&name=&originHeight=350&originWidth=607&originalType=binary&ratio=1&size=256324&status=done&style=none&taskId=uca1dff74-87c0-4e8c-94c1-8367d5595f9&width=607"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304226953-e5ce5eef-a733-4da8-b495-22dee74c9772.png#clientId=ua9168488-b0f8-4&from=paste&height=599&id=ud3e8abf6&margin=%5Bobject%20Object%5D&name=&originHeight=599&originWidth=1141&originalType=binary&ratio=1&size=480219&status=done&style=none&taskId=u1d644ff1-450b-4927-830d-86797da63b5&width=1141"></p>
<h2 id="3-9-以太网交换机自学习和转发帧的流程"><a href="#3-9-以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9 以太网交换机自学习和转发帧的流程"></a>3.9 以太网交换机自学习和转发帧的流程</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304325116-f5fe6a7b-e69e-4630-9769-d10762422efe.png#clientId=ua9168488-b0f8-4&from=paste&height=182&id=u94c6727b&margin=%5Bobject%20Object%5D&name=&originHeight=182&originWidth=1144&originalType=binary&ratio=1&size=188050&status=done&style=none&taskId=ufe27744c-72a7-4a7a-a0c5-e85564a8a9f&width=1144"></p>
<h2 id="3-10-以太网交换机的生成树协议STP"><a href="#3-10-以太网交换机的生成树协议STP" class="headerlink" title="3.10 以太网交换机的生成树协议STP"></a>3.10 以太网交换机的生成树协议STP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629304936182-215ca9e7-a5ea-4820-a6d2-106ae42fee1d.png#clientId=ua9168488-b0f8-4&from=paste&height=332&id=uacb6852f&margin=%5Bobject%20Object%5D&name=&originHeight=332&originWidth=676&originalType=binary&ratio=1&size=297082&status=done&style=none&taskId=u3b044536-5836-4444-b244-66ea7ba4905&width=676"></p>
<h2 id="3-11-虚拟局域网VLAN概述"><a href="#3-11-虚拟局域网VLAN概述" class="headerlink" title="3.11 虚拟局域网VLAN概述"></a>3.11 虚拟局域网VLAN概述</h2><p>使用广播有可能发生广播风暴问题，占用CPU资源<br><strong>虚拟局域网VLAN技术可以隔绝广播域</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629305135155-9cd015c3-b81f-4430-8667-647ed365146c.png#clientId=ua9168488-b0f8-4&from=paste&height=73&id=ufafd0705&margin=%5Bobject%20Object%5D&name=&originHeight=73&originWidth=1072&originalType=binary&ratio=1&size=125501&status=done&style=none&taskId=u32512650-2ae0-41eb-9921-afe74f16d23&width=1072"></p>
<h1 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章(网络层)"></a>第4章(网络层)</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629895311610-dc712f8b-6e8b-446b-a2b2-05f555c834f1.png#clientId=ue04b705f-4445-4&from=paste&height=317&id=u63e8a5e8&margin=%5Bobject%20Object%5D&name=&originHeight=317&originWidth=1015&originalType=binary&ratio=1&size=233847&status=done&style=none&taskId=ub46a736e-d0cb-4cdf-ad49-d541521519d&width=1015"></p>
<h2 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h2><p>面向连接的虚电路服务、无连接的数据报服务<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629899004716-3e50cbca-eb9a-4228-bef1-79009bc6bb53.png#clientId=u8b60e0cf-ca8a-4&from=paste&height=442&id=u1b006b96&margin=%5Bobject%20Object%5D&name=&originHeight=589&originWidth=595&originalType=binary&ratio=1&size=408181&status=done&style=none&taskId=u971b57cb-929a-429c-b56d-de229d30b12&width=446"></p>
<h2 id="4-3-IPv4地址"><a href="#4-3-IPv4地址" class="headerlink" title="4.3 IPv4地址"></a>4.3 IPv4地址</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629899675919-db69ba64-3615-4f73-b0b1-0a95fc7260c5.png#clientId=ue530bc8e-ad2f-4&from=paste&height=75&id=uff8ac2f0&margin=%5Bobject%20Object%5D&name=&originHeight=75&originWidth=1110&originalType=binary&ratio=1&size=95144&status=done&style=none&taskId=u235b3b7e-fee0-45a4-b67e-0c3ad2b2fa5&width=1110"><br>8位无符号二进制整数转十进制数</p>
<h3 id="2-分类编址的IPv4地址"><a href="#2-分类编址的IPv4地址" class="headerlink" title="2.分类编址的IPv4地址"></a>2.分类编址的IPv4地址</h3><p><strong>地址=网络号+主机号</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984338002-912e1f84-7c66-4b29-aed6-3449f05c5995.png#clientId=u99cd8dab-b839-4&from=paste&height=617&id=udf80f2dc&margin=%5Bobject%20Object%5D&name=&originHeight=617&originWidth=1346&originalType=binary&ratio=1&size=295402&status=done&style=none&taskId=u03d45a6b-33fd-48ed-852e-719c181885e&width=1346"><br><strong>主机号全0为网络地址，主机号全1为广播地址</strong><br><strong>​</strong></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984617029-5a6a4caf-ef43-48da-8c95-a946932f2846.png#clientId=u99cd8dab-b839-4&from=paste&height=679&id=ubd8cdd92&margin=%5Bobject%20Object%5D&name=&originHeight=679&originWidth=1363&originalType=binary&ratio=1&size=517829&status=done&style=none&taskId=u636f1bfd-dbe7-40bb-a2d4-247c495f22f&width=1363"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984830276-4ab15ae7-9b26-412b-8cd1-580b79ad079b.png#clientId=u99cd8dab-b839-4&from=paste&height=577&id=u2ce8ddf7&margin=%5Bobject%20Object%5D&name=&originHeight=577&originWidth=1346&originalType=binary&ratio=1&size=304949&status=done&style=none&taskId=u48a7df6c-8267-487c-9e9a-010b570244a&width=1346"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629984902741-162a94ee-f47d-4c04-acf5-d94c8369596e.png#clientId=u99cd8dab-b839-4&from=paste&height=557&id=ub2ff9fbb&margin=%5Bobject%20Object%5D&name=&originHeight=557&originWidth=1328&originalType=binary&ratio=1&size=310296&status=done&style=none&taskId=u8947a48f-e3cc-4ea2-96d0-a246e1fe049&width=1328"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629985792094-1e11b136-8bb3-4c40-b65a-bdbfba1c20f4.png#clientId=u029f7a3f-c032-4&from=paste&height=640&id=uf08660dd&margin=%5Bobject%20Object%5D&name=&originHeight=640&originWidth=1310&originalType=binary&ratio=1&size=447945&status=done&style=none&taskId=u9fa9194b-4b6c-43bc-b811-d3903fd9555&width=1310"></p>
<p>主机号小于127的A类，128-191的B类，192-223的C类<br>申请C类网络地址，可分配的IP地址数量为254个；其他类，查看上述图片<br> 可以将主机号的一部分作为子网号，划分子网<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629986771700-3c3629bb-99d5-4bc5-8994-a31693b4f99b.png#clientId=u029f7a3f-c032-4&from=paste&height=527&id=u5cc376b8&margin=%5Bobject%20Object%5D&name=&originHeight=527&originWidth=1350&originalType=binary&ratio=1&size=429821&status=done&style=none&taskId=u6463215b-01d4-4838-94d4-c0bf3283428&width=1350"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629995061991-39429b99-d8a1-4a62-b212-0d8c2dfd0076.png#clientId=u79734b0e-78be-4&from=paste&height=568&id=u96f678b4&margin=%5Bobject%20Object%5D&name=&originHeight=568&originWidth=889&originalType=binary&ratio=1&size=352083&status=done&style=none&taskId=u9aea79f9-3d21-4213-8ff2-58e7bf01e18&width=889"><br>一般是从主机号借用比特作为子网号</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h4><p>定长的子网掩码FLSM、变长的子网掩码VLSM<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1629996092066-b012a8b3-28f2-4f6a-b51a-7f2f9c7a896d.png#clientId=u79734b0e-78be-4&from=paste&height=449&id=ub8d95f7d&margin=%5Bobject%20Object%5D&name=&originHeight=449&originWidth=1062&originalType=binary&ratio=1&size=452150&status=done&style=none&taskId=u1f1d22b4-4200-4bce-b673-c42fc156841&width=1062"></p>
<h2 id="4-4-IP数据报的发送和转发过程"><a href="#4-4-IP数据报的发送和转发过程" class="headerlink" title="4.4 IP数据报的发送和转发过程"></a>4.4 IP数据报的发送和转发过程</h2><p>由IP地址和子网掩码，可以得出网络地址。路由器进行网络地址的转发，需要知道目的网络地址，才能将数据发送出去<br>由路由器的路由表确定该由哪个路由器进行转发</p>
<h2 id="4-5-静态路由配置及其可能产生的路由环路问题"><a href="#4-5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5 静态路由配置及其可能产生的路由环路问题"></a>4.5 静态路由配置及其可能产生的路由环路问题</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630033837991-9cbbf289-e74c-49d0-9939-2169778518cd.png#clientId=u1edab733-fa4e-4&from=paste&height=443&id=ud5bf8b66&margin=%5Bobject%20Object%5D&name=&originHeight=886&originWidth=1375&originalType=binary&ratio=1&size=564202&status=done&style=none&taskId=u343600c5-1042-42e1-97b7-167411a5ee6&width=687.5"></p>
<h2 id="4-6-路由选择协议概述"><a href="#4-6-路由选择协议概述" class="headerlink" title="4.6 路由选择协议概述"></a>4.6 路由选择协议概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630034856622-aa26428d-2a5c-4707-8101-fa1c17c86148.png#clientId=u1edab733-fa4e-4&from=paste&height=312&id=u0b055cc5&margin=%5Bobject%20Object%5D&name=&originHeight=623&originWidth=1882&originalType=binary&ratio=1&size=626706&status=done&style=none&taskId=u59cf01a9-16ea-4c76-ab15-d4335ff3ed7&width=941"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035046058-c765bfc6-eae8-42d4-ab78-0da7633367fd.png#clientId=u1edab733-fa4e-4&from=paste&height=351&id=u779726ef&margin=%5Bobject%20Object%5D&name=&originHeight=702&originWidth=1886&originalType=binary&ratio=1&size=803225&status=done&style=none&taskId=ub218777c-8a9d-4a3f-b2c6-b7b2a00702e&width=943"></p>
<h3 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035159645-6c39b751-7f04-454d-957c-54381e128e21.png#clientId=u1edab733-fa4e-4&from=paste&height=448&id=ub491947c&margin=%5Bobject%20Object%5D&name=&originHeight=895&originWidth=1823&originalType=binary&ratio=1&size=692025&status=done&style=none&taskId=u754ce3b2-23e8-437c-a0d1-9954696f143&width=911.5"></p>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><strong>路由信息协议RIP</strong>认为好的路由就是距离短的路由<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630035343897-15d16f08-a902-4e78-8851-bd32906e0ec8.png#clientId=u1edab733-fa4e-4&from=paste&height=139&id=u944fd16b&margin=%5Bobject%20Object%5D&name=&originHeight=277&originWidth=815&originalType=binary&ratio=1&size=243398&status=done&style=none&taskId=uc88d86b2-99f5-4db0-aa78-a2e40b587d5&width=407.5"><br>路由表包含的条目是到目的地址的信息<br>​</p>
<p><strong>开放式最短路径优先OSPF</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630037745333-f80e84da-6a62-4786-be44-65194105c4df.png#clientId=u1edab733-fa4e-4&from=paste&height=315&id=u17811cdf&margin=%5Bobject%20Object%5D&name=&originHeight=630&originWidth=1369&originalType=binary&ratio=1&size=564539&status=done&style=none&taskId=u20d1c9cd-f259-4a33-93e5-d984e09aa09&width=684.5"><br>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域。这样使每个区域内部交换的信息量大大减少。<br>​</p>
<p><strong>边界网关协议BGP</strong><br>直接封装RIP、OSPF、BGP的报文协议分别是UDP、IP、TCP</p>
<h2 id="4-7-IPv4数据报的首部格式"><a href="#4-7-IPv4数据报的首部格式" class="headerlink" title="4.7 IPv4数据报的首部格式"></a>4.7 IPv4数据报的首部格式</h2><p>首部的固定部分是20字节，可变部分字节数是变化的<br>生存时间是TTL<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630039612119-7b02c6bc-48c6-4cd9-8cbf-3099d51a1bca.png#clientId=ufe427c8a-6a89-4&from=paste&height=203&id=u2e6fc32f&margin=%5Bobject%20Object%5D&name=&originHeight=406&originWidth=1207&originalType=binary&ratio=1&size=161011&status=done&style=none&taskId=u350e8067-d81f-419c-9f6b-178fea205f9&width=603.5"><br>** 每行都是4个字节，32个bit**<br>可变部分长度可变，导致首部的长度也是可变的，增加了路由器处理数据的压力，但一般可变部分很少用到<br><strong>网际层使用的是IP协议进行封装</strong></p>
<h2 id="4-8-网际控制报文协议ICMP"><a href="#4-8-网际控制报文协议ICMP" class="headerlink" title="4.8 网际控制报文协议ICMP"></a>4.8 网际控制报文协议ICMP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630042596629-61f0d547-1888-4960-bd05-54412795b981.png#clientId=ufe427c8a-6a89-4&from=paste&height=87&id=ua0d05f77&margin=%5Bobject%20Object%5D&name=&originHeight=173&originWidth=1831&originalType=binary&ratio=1&size=130854&status=done&style=none&taskId=u2ef2d7c2-e6bb-4923-9871-68c8e5f8bdb&width=915.5"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630042807657-c98ecabc-ecfa-4139-b17a-91cc51843d89.png#clientId=ufe427c8a-6a89-4&from=paste&height=379&id=u4b356a6a&margin=%5Bobject%20Object%5D&name=&originHeight=757&originWidth=1455&originalType=binary&ratio=1&size=706490&status=done&style=none&taskId=ue3341430-1f78-4925-abbf-66dece8c83a&width=727.5"></p>
<p>ICMP的应用举例：分组网间探测PING、跟踪路由</p>
<h2 id="4-9-虚拟专用网VPN与网络地址转换NAT"><a href="#4-9-虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网VPN与网络地址转换NAT"></a>4.9 虚拟专用网VPN与网络地址转换NAT</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043094390-f7d123b9-a37d-42f5-99a1-c3558fcfcc13.png#clientId=ufe427c8a-6a89-4&from=paste&height=140&id=u8833eeaa&margin=%5Bobject%20Object%5D&name=&originHeight=279&originWidth=1541&originalType=binary&ratio=1&size=535228&status=done&style=none&taskId=u35043e21-25ff-4d2d-961b-0e0e0af3ddb&width=770.5"><br>在因特网的所有路由器中，对目的地址是私有地址的IP数据报一律不进行转发<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043308159-fc9f8123-7157-4317-9a1c-74aa21e4c563.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=341&id=u361b8b3a&margin=%5Bobject%20Object%5D&name=&originHeight=682&originWidth=1899&originalType=binary&ratio=1&size=823624&status=done&style=none&taskId=u8e2e6ad2-9622-4037-a562-40dab9ac475&width=949.5"><br>可重用IP一般是说每人都可以用的，比如局域网中的：192.168.x.x这类格式。<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043660820-2dad3301-df24-4378-b5a4-41fd6fe4d023.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=84&id=ue3f3fa7d&margin=%5Bobject%20Object%5D&name=&originHeight=168&originWidth=1686&originalType=binary&ratio=1&size=203217&status=done&style=none&taskId=u58389169-a82c-43aa-97d8-a1184c23705&width=843"><br><strong>​</strong></p>
<p><strong>网络地址转换NAT</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630043936507-ba8576fe-58f9-4e26-826e-806ef1fb11d8.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=107&id=uc0f13ddb&margin=%5Bobject%20Object%5D&name=&originHeight=214&originWidth=1845&originalType=binary&ratio=1&size=681462&status=done&style=none&taskId=u8b3fdb8c-bca2-4733-b0f3-8321ed0ea92&width=922.5"></p>
<p>什么是私有IP地址、公有IP地址？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630044115083-3e9a8654-305a-4007-9898-5cf28ea74729.png#clientId=u7f01cc9f-9b1e-4&from=paste&height=230&id=u44e24201&margin=%5Bobject%20Object%5D&name=&originHeight=459&originWidth=1101&originalType=binary&ratio=1&size=76276&status=done&style=none&taskId=u138ca015-957f-4674-8d71-0ebffe072c5&width=550.5"></p>
<h1 id="第5章-运输层"><a href="#第5章-运输层" class="headerlink" title="第5章(运输层)"></a>第5章(运输层)</h1><h2 id="5-1-运输层概述"><a href="#5-1-运输层概述" class="headerlink" title="5.1 运输层概述"></a>5.1 运输层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151394190-c7aaf562-8f82-4d1d-ab6f-1f1bcb855a2a.png#clientId=ub9f2d9a6-7257-4&from=paste&height=197&id=u63c74f32&margin=%5Bobject%20Object%5D&name=&originHeight=197&originWidth=1298&originalType=binary&ratio=1&size=223824&status=done&style=none&taskId=ue1d70bed-e248-4c43-9295-397f0803afe&width=1298"></p>
<h2 id="5-2-运输层端口号、复用与分用的概念"><a href="#5-2-运输层端口号、复用与分用的概念" class="headerlink" title="5.2 运输层端口号、复用与分用的概念"></a>5.2 运输层端口号、复用与分用的概念</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151619401-fa742f7b-f72b-4db2-ba4d-1a8a9d400d62.png#clientId=ub9f2d9a6-7257-4&from=paste&height=356&id=uaf62bba6&margin=%5Bobject%20Object%5D&name=&originHeight=356&originWidth=1050&originalType=binary&ratio=1&size=362460&status=done&style=none&taskId=ud9c8a6dd-0ecb-4645-88be-7f85193c5fa&width=1050"><br><strong>网络层使用的是IP协议，运输层使用的是TCP/UDP协议</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630151743066-bc4aad62-026c-480b-a299-2f38fb16e661.png#clientId=ub9f2d9a6-7257-4&from=paste&height=597&id=uf773e8a3&margin=%5Bobject%20Object%5D&name=&originHeight=597&originWidth=1364&originalType=binary&ratio=1&size=407162&status=done&style=none&taskId=u55fbea37-4a7a-45d3-840a-c5238da8bf0&width=1364"><br>​</p>
<p>举例：浏览器输入一个域名后，产生哪些行为？<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152197425-a33616c5-f278-4abb-a9aa-b08ecee73904.png#clientId=ub9f2d9a6-7257-4&from=paste&height=638&id=ua93e4a47&margin=%5Bobject%20Object%5D&name=&originHeight=638&originWidth=1332&originalType=binary&ratio=1&size=280055&status=done&style=none&taskId=u50b5092e-987d-474a-898b-6aac7b3e2b9&width=1332"><br><strong>DNS服务器将域名解析为IP地址</strong></p>
<h2 id="5-3-UDP和TCP的对比"><a href="#5-3-UDP和TCP的对比" class="headerlink" title="5.3 UDP和TCP的对比"></a>5.3 UDP和TCP的对比</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152415885-e3eefc50-b07a-4e38-bf9f-d70af0a9b934.png#clientId=ub9f2d9a6-7257-4&from=paste&height=646&id=u4a432f79&margin=%5Bobject%20Object%5D&name=&originHeight=646&originWidth=1324&originalType=binary&ratio=1&size=407134&status=done&style=none&taskId=u247eb5c6-a637-488c-84d3-3fe0b8303f3&width=1324"><br>UDP支持一对一、一对多、一对全的通信，TCP只支持一对一的通信<br>全双工：两个方向可以同时通信   半双工：同一时间只能一个方向通信<br><strong>UDP适用于视频会议等，TCP适用于文件传输等</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630152811341-3b3237cd-55e5-4d8a-8f6e-6b4dea538c31.png#clientId=ub9f2d9a6-7257-4&from=paste&height=627&id=u2d63d285&margin=%5Bobject%20Object%5D&name=&originHeight=627&originWidth=1320&originalType=binary&ratio=1&size=925199&status=done&style=none&taskId=u9a019bc3-4680-41df-b77a-4ad34cecb12&width=1320"><br><strong>报文段包括首部和数据部分</strong><br><strong>​</strong></p>
<h2 id="5-4-TCP的流量控制"><a href="#5-4-TCP的流量控制" class="headerlink" title="5.4 TCP的流量控制"></a>5.4 TCP的流量控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630154365890-263cfe95-ee9e-4d52-bec5-05e97354491e.png#clientId=ub9f2d9a6-7257-4&from=paste&height=126&id=uff2e2b8e&margin=%5Bobject%20Object%5D&name=&originHeight=126&originWidth=1097&originalType=binary&ratio=1&size=128609&status=done&style=none&taskId=u9040db5e-5082-42b8-80f9-f802095be60&width=1097"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155032423-032c4192-5ef6-4a79-8457-67ae54238197.png#clientId=ub9f2d9a6-7257-4&from=paste&height=158&id=u131bcd78&margin=%5Bobject%20Object%5D&name=&originHeight=158&originWidth=1029&originalType=binary&ratio=1&size=132336&status=done&style=none&taskId=ua2773e6f-889e-4702-b590-b5088f8b5a1&width=1029"><br><strong>举例：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155507437-b11e06a6-f7a4-4032-a593-c218976f8aa7.png#clientId=ub9f2d9a6-7257-4&from=paste&height=648&id=u78676055&margin=%5Bobject%20Object%5D&name=&originHeight=648&originWidth=1303&originalType=binary&ratio=1&size=385129&status=done&style=none&taskId=ub936cdf8-7e16-4388-8dae-0e1811f25f4&width=1303"></p>
<h2 id="5-5-TCP的拥塞控制"><a href="#5-5-TCP的拥塞控制" class="headerlink" title="5.5 TCP的拥塞控制"></a>5.5 TCP的拥塞控制</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630155711085-9849f28b-73eb-4fef-81c8-d560450727af.png#clientId=ub9f2d9a6-7257-4&from=paste&height=618&id=u2e53147a&margin=%5Bobject%20Object%5D&name=&originHeight=618&originWidth=1123&originalType=binary&ratio=1&size=435382&status=done&style=none&taskId=u145afe6f-def4-45fd-b61c-4967a680db9&width=1123"><br><strong>首部加数据部分构成报文段。若报文段发送过程发生丢失，会超时重传</strong><br>​</p>
<p>拥塞控制算法：<br><strong>慢开始和拥塞避免</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630156160974-728768c9-2641-4c3f-b8d3-e48a6e13ef38.png#clientId=ub9f2d9a6-7257-4&from=paste&height=628&id=u5186d1f7&margin=%5Bobject%20Object%5D&name=&originHeight=628&originWidth=1337&originalType=binary&ratio=1&size=551041&status=done&style=none&taskId=udd3ad504-99eb-455f-91cc-55209faa5c5&width=1337"><br><strong>快重传和快恢复</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630158712140-bbee739f-3e37-4004-836e-4af308d0b182.png#clientId=ub9f2d9a6-7257-4&from=paste&height=586&id=u174c061e&margin=%5Bobject%20Object%5D&name=&originHeight=586&originWidth=1320&originalType=binary&ratio=1&size=681522&status=done&style=none&taskId=u6f11787a-7ded-4c52-acf1-f1a33f57b36&width=1320"><br>如果只是丢失个别的报文段，而不是拥塞，可以不用启动慢开始算法，执行快恢复算法，提高效率<br>​</p>
<h2 id="5-6-TCP超时重传时间的选择"><a href="#5-6-TCP超时重传时间的选择" class="headerlink" title="5.6 TCP超时重传时间的选择"></a>5.6 TCP超时重传时间的选择</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630162592421-ac1f7a4f-b862-40d7-a722-3b864809527e.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=640&id=u95370f7d&margin=%5Bobject%20Object%5D&name=&originHeight=640&originWidth=1329&originalType=binary&ratio=1&size=583789&status=done&style=none&taskId=uba6ed328-a647-4ea4-8dda-d07e2e5f794&width=1329"></p>
<h2 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h2><p>TCP基于以字节为单位的<strong>滑动窗口</strong>来实现可靠传输<br>滑动窗口的原理需要能够描述，就是发送数据时，滑动窗口的状态及移动的过程<br>​</p>
<p>确认号字段确认接收后，发送窗口才会移动。若发送方迟迟收不到接收方的确认，会产生超时重传<br><strong>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。</strong><br><strong>发送方和接收方对报文段数据的确认</strong><br><strong>​</strong></p>
<h2 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630163696397-0aafbadd-3cb0-49af-808e-433f8c2bbee2.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=361&id=u32087d3a&margin=%5Bobject%20Object%5D&name=&originHeight=361&originWidth=1027&originalType=binary&ratio=1&size=187346&status=done&style=none&taskId=uf49ca996-8142-4abb-a6e6-df7e3e53ece&width=1027"></p>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630164187936-77352136-a111-45ce-a6f0-b41a3bc22367.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=635&id=ubcdc22e8&margin=%5Bobject%20Object%5D&name=&originHeight=635&originWidth=1367&originalType=binary&ratio=1&size=581262&status=done&style=none&taskId=ue41660fc-7d64-4866-a85d-de07b2ce1ad&width=1367"></p>
<h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p> <img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630164942626-cda2bb15-02e7-4e09-9bb0-21b306e1416d.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=671&id=ubecb3812&margin=%5Bobject%20Object%5D&name=&originHeight=671&originWidth=1302&originalType=binary&ratio=1&size=635753&status=done&style=none&taskId=u2057b9a3-b969-4f93-a476-de7d7a9793f&width=1302"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165044359-a3efc946-429a-4c04-b7a9-925e92aa8101.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=518&id=ub37c3a1d&margin=%5Bobject%20Object%5D&name=&originHeight=518&originWidth=1271&originalType=binary&ratio=1&size=425579&status=done&style=none&taskId=u39499b91-88c3-4040-95bc-346829bd477&width=1271"></p>
<h2 id="5-9-TCP报文段的首部格式"><a href="#5-9-TCP报文段的首部格式" class="headerlink" title="5.9 TCP报文段的首部格式"></a>5.9 TCP报文段的首部格式</h2><p>TCP报文段的首部格式与IP报文段的首部格式类似<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165168614-2083232e-ddbd-4859-a192-0aaf40d24c53.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=532&id=u812b32cd&margin=%5Bobject%20Object%5D&name=&originHeight=532&originWidth=1102&originalType=binary&ratio=1&size=273454&status=done&style=none&taskId=u9f368cc7-f3b0-4202-95d8-a3201a166fd&width=1102"><br>如何确定是请求报文段还是确认报文段？<br>看是否有SYN和ACK<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630165518609-85973199-ea5f-49f2-bc6e-4c2900203dde.png#clientId=u9f8e2c7d-04ab-4&from=paste&height=295&id=u19c921a5&margin=%5Bobject%20Object%5D&name=&originHeight=295&originWidth=576&originalType=binary&ratio=1&size=110544&status=done&style=none&taskId=u4b66e5d4-2339-4d55-bd72-74d4de7d4c6&width=576"></p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="第6章-应用层"><a href="#第6章-应用层" class="headerlink" title="第6章(应用层)"></a>第6章(应用层)</h1><h2 id="6-1-应用层概述"><a href="#6-1-应用层概述" class="headerlink" title="6.1 应用层概述"></a>6.1 应用层概述</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630199429756-e4f5f638-f08f-4b0b-b30c-5c525f2c92f1.png#clientId=ub9b57106-a89f-4&from=paste&height=512&id=u2dc3e02c&margin=%5Bobject%20Object%5D&name=&originHeight=512&originWidth=1289&originalType=binary&ratio=1&size=577711&status=done&style=none&taskId=u70efb5fa-2d71-41ef-8517-2555ab0dd26&width=1289"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630200373985-461de6bf-bb1e-4af6-83a5-e519cade7062.png#clientId=ub9b57106-a89f-4&from=paste&height=78&id=ube25ac6a&margin=%5Bobject%20Object%5D&name=&originHeight=78&originWidth=1184&originalType=binary&ratio=1&size=93580&status=done&style=none&taskId=u06c5a5a8-687d-4cc4-aa75-022a80fe3e5&width=1184"></p>
<h2 id="6-2-客户-服务器方式-C-S-和对等方式-P2P"><a href="#6-2-客户-服务器方式-C-S-和对等方式-P2P" class="headerlink" title="6.2 客户/服务器方式(C/S)和对等方式(P2P)"></a>6.2 客户/服务器方式(C/S)和对等方式(P2P)</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630200831698-c77ac187-3fc5-44e9-8652-dcf869c4695d.png#clientId=ub9b57106-a89f-4&from=paste&height=563&id=u79fe9ba6&margin=%5Bobject%20Object%5D&name=&originHeight=563&originWidth=1141&originalType=binary&ratio=1&size=557098&status=done&style=none&taskId=u3684ab91-db88-4149-99d0-37cfd4523c3&width=1141"></p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630201032087-fb7b31df-497b-4dcc-8f30-b18bd46c05d8.png#clientId=ub9b57106-a89f-4&from=paste&height=444&id=u0b9fe317&margin=%5Bobject%20Object%5D&name=&originHeight=444&originWidth=1147&originalType=binary&ratio=1&size=519812&status=done&style=none&taskId=u599b7045-24d6-4f99-8208-0be9bae7c62&width=1147"></p>
<h2 id="6-3-动态主机配置协议DHCP"><a href="#6-3-动态主机配置协议DHCP" class="headerlink" title="6.3 动态主机配置协议DHCP"></a>6.3 动态主机配置协议DHCP</h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630201944412-686589fc-c905-4bd2-b2dc-3ee52487e1e3.png#clientId=ub9b57106-a89f-4&from=paste&height=604&id=uc0e23d08&margin=%5Bobject%20Object%5D&name=&originHeight=604&originWidth=1205&originalType=binary&ratio=1&size=537647&status=done&style=none&taskId=ud1bb0dde-e94f-4247-92de-dcbc474e74d&width=1205"></p>
<h2 id="6-4-域名系统DNS"><a href="#6-4-域名系统DNS" class="headerlink" title="6.4 域名系统DNS"></a>6.4 域名系统DNS<img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202164656-cb1a90ae-fe46-4ae8-be47-ccc69e81d94c.png#clientId=ub9b57106-a89f-4&from=paste&height=608&id=ucb89939f&margin=%5Bobject%20Object%5D&name=&originHeight=608&originWidth=1314&originalType=binary&ratio=1&size=421163&status=done&style=none&taskId=u1c961911-4fec-4da4-8146-d0dce8e2121&width=1314"></h2><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202299316-8ffc70f7-eed3-44c1-add5-3ca672e347c0.png#clientId=ub9b57106-a89f-4&from=paste&height=568&id=ubc037671&margin=%5Bobject%20Object%5D&name=&originHeight=568&originWidth=1157&originalType=binary&ratio=1&size=548071&status=done&style=none&taskId=uf8a40b71-6be2-4632-a3da-119105403c6&width=1157"></p>
<p><strong>DNS使用分布在各地的域名服务器来实现域名到IP地址的转换</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202647784-7b86c9da-e8d5-4ab1-ac61-3158f840bda6.png#clientId=ub9b57106-a89f-4&from=paste&height=625&id=u751a9ecb&margin=%5Bobject%20Object%5D&name=&originHeight=625&originWidth=1327&originalType=binary&ratio=1&size=668642&status=done&style=none&taskId=u88c4b465-be63-46b9-a5d7-43f901d5239&width=1327"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630202883291-8b0c811e-4df1-42d4-b841-0ed0cf33b55f.png#clientId=ub9b57106-a89f-4&from=paste&height=265&id=ua872447e&margin=%5Bobject%20Object%5D&name=&originHeight=265&originWidth=524&originalType=binary&ratio=1&size=103950&status=done&style=none&taskId=u39c92748-b78c-40db-b2cd-b8cb777addf&width=524"></p>
<h2 id="6-5-文件传送协议FTP"><a href="#6-5-文件传送协议FTP" class="headerlink" title="6.5 文件传送协议FTP"></a>6.5 文件传送协议FTP</h2><p> Windows可以搭建FTP服务器。如果想要从Linux服务器上下载文件，使用相关FTP连接工具即可<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630203346283-3846b7d6-cdbf-40f1-8b7d-65e664f1890c.png#clientId=ub9b57106-a89f-4&from=paste&height=392&id=uda6a5fe3&margin=%5Bobject%20Object%5D&name=&originHeight=392&originWidth=1006&originalType=binary&ratio=1&size=209350&status=done&style=none&taskId=ud3badeb0-5e14-465a-b1b7-813e40d942f&width=1006"><br>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接<br>​</p>
<h2 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h2><p>SMTP邮件发送协议、POP3邮件读取协议<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630203941529-219a6adb-61cb-4dc6-87dd-783f8958e378.png#clientId=ub9b57106-a89f-4&from=paste&height=215&id=u844094aa&margin=%5Bobject%20Object%5D&name=&originHeight=215&originWidth=1167&originalType=binary&ratio=1&size=214913&status=done&style=none&taskId=ube9ccd78-223d-4184-939a-1e5680f7cbb&width=1167"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630204242121-aa4f2e0b-7b8f-4c1a-864f-68feb340547d.png#clientId=ub9b57106-a89f-4&from=paste&height=195&id=u6a645476&margin=%5Bobject%20Object%5D&name=&originHeight=195&originWidth=1249&originalType=binary&ratio=1&size=224137&status=done&style=none&taskId=u9cef5bc0-9252-40c5-9fea-3eff8992529&width=1249"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630204496512-20fa7951-8d10-4f08-8290-ebff30eac324.png#clientId=ub9b57106-a89f-4&from=paste&height=624&id=u9243faf5&margin=%5Bobject%20Object%5D&name=&originHeight=624&originWidth=1241&originalType=binary&ratio=1&size=404555&status=done&style=none&taskId=ua09d7108-4ac1-417a-9992-1667494b297&width=1241"></p>
<h2 id="6-7-万维网WWW"><a href="#6-7-万维网WWW" class="headerlink" title="6.7 万维网WWW"></a>6.7 万维网WWW</h2><p>万维网使用统一资源定位符URL来指明因特网上任何种类”资源”的位置<br>在html中，使用link标签引入css文件，使用script标签引入js文件</p>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206119239-ea21236e-e479-47f9-901d-23c6579c9267.png#clientId=ub9b57106-a89f-4&from=paste&height=362&id=u292c3051&margin=%5Bobject%20Object%5D&name=&originHeight=362&originWidth=1022&originalType=binary&ratio=1&size=216576&status=done&style=none&taskId=u33225de8-7b73-4fea-99c3-2de11947567&width=1022"><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206273896-ec1a7b75-0f50-4b69-b1ed-b3c8b3fa3b8c.png#clientId=ub9b57106-a89f-4&from=paste&height=464&id=ue6be07f0&margin=%5Bobject%20Object%5D&name=&originHeight=464&originWidth=1110&originalType=binary&ratio=1&size=547130&status=done&style=none&taskId=ub0a3026d-914c-4870-9dac-a86723e8843&width=1110"></p>
<p>HTTP请求报文格式举例：<br>请求报文=请求行+首部行<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206487325-2a36d06c-81fe-4965-9b80-d1895ef6c4c0.png#clientId=ub9b57106-a89f-4&from=paste&height=178&id=uc0c6ad59&margin=%5Bobject%20Object%5D&name=&originHeight=178&originWidth=647&originalType=binary&ratio=1&size=122364&status=done&style=none&taskId=uc08a9301-bd22-447c-9580-6ea770cc4dc&width=647"><br>HTTP响应报文格式举例：<br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206593049-c310094c-5e44-4bd9-a544-a4c1877b1b34.png#clientId=ub9b57106-a89f-4&from=paste&height=323&id=u042817fc&margin=%5Bobject%20Object%5D&name=&originHeight=323&originWidth=1242&originalType=binary&ratio=1&size=186479&status=done&style=none&taskId=u287d71a5-f5f2-4889-876d-7ca41dd610f&width=1242"></p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用Cookie在服务器上记录用户登录信息</p>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206808227-e1c756a1-56cc-469e-9934-de96db23a75d.png#clientId=ub9b57106-a89f-4&from=paste&height=204&id=u67a05313&margin=%5Bobject%20Object%5D&name=&originHeight=204&originWidth=1166&originalType=binary&ratio=1&size=266028&status=done&style=none&taskId=ua454bc7a-7798-4bb5-b89a-c38c6d1e5c0&width=1166"><br><strong>练习：</strong><br><img data-src="https://cdn.nlark.com/yuque/0/2021/png/12855610/1630206934741-e6d00b84-a0c9-4144-ae3f-9b6fa90f45e9.png#clientId=ub9b57106-a89f-4&from=paste&height=227&id=ucc68afb7&margin=%5Bobject%20Object%5D&name=&originHeight=227&originWidth=929&originalType=binary&ratio=1&size=194817&status=done&style=none&taskId=u95f63382-86f5-4349-879f-4e0844ee632&width=929"></p>
<h1 id="第7章-总结"><a href="#第7章-总结" class="headerlink" title="第7章(总结)"></a>第7章(总结)</h1><blockquote>
<p>计算机网络是我一直很想学习的课程，从8.12-8.29我将教书匠的课程学完，并且记下了这个笔记，方便日后复习。但计算机网络的学习并没有结束，将理论的学习用实践验证，学习路上道阻且长。</p>
</blockquote>
<p><strong>最后以唐朝韩愈的话劝勉自己：学知不足，业精于勤。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk9-17 新特性</title>
    <url>/posts/c1f7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="Java新特性介绍"><a href="#Java新特性介绍" class="headerlink" title="Java新特性介绍"></a>Java新特性介绍</h1><p>Java 8是Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java并没有就此止步，而是继续不断发展壮大，几乎每隔6个月，就会冒出一个新版本，最新的版本已经快要迭代到Java 20了，与Java 8相差了足足十来个版本，但是由于Java 8的稳定和生态完善（目前仍是LTS长期维护版本），依然有很多公司在坚持使用Java 8，不过随着SpringBoot 3.0的到来，现在强制要求使用Java 17版本（同样也是LTS长期维护版本），下一个Java版本的时代，或许已经临近了。</p>
<p>​<span id="more"></span></p>
<h2 id="Java-8-关键特性回顾"><a href="#Java-8-关键特性回顾" class="headerlink" title="Java 8 关键特性回顾"></a>Java 8 关键特性回顾</h2><p>在开始之前，我们先来回顾一下Java 8中学习的Lambda表达式和Optional类，有关Stream API请各位小伙伴回顾一下Java SE篇视频教程，这里不再进行介绍。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来搞事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;   <span class="comment">//创建一个实现Runnable的匿名内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">//具体的实现逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在<code>run()</code>方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p>
<p>在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减，实际上我们进行观察会发现，真正有用的那一部分代码，实际上就是我们对<code>run()</code>方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，那么我们能否针对于这种情况进行优化呢？我们现在只需要一个简短的lambda表达式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//只需留下我们需要具体实现的方法体</span></span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于<code>() ‐&gt; &#123; 代码语句 &#125;</code>的形式进行替换即可。是不是感觉瞬间代码清爽了N倍？</p>
<p>当然这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p>
<blockquote>
<p>但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过<code>invokedynamic</code>指令实现的，不难发现，匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();   <span class="comment">//这里我们拋个异常看看</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pm4fpasnj21e202qdgc.jpg" alt="image-20220529214948350"></p>
<p>可以看到，实际上是Main类中的<code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如Runnable接口需要一个方法体对它的<code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p>
</blockquote>
<p>我们来看一下Lambda表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<p>比如我们之前使用的Runable类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>   <span class="comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;   <span class="comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Runable的的匿名内部类实现，就可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;    &#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以写一个玩玩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;   <span class="comment">//接口类型</span></span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;    <span class="comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的Lambda表达式的实现就可以写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = (Integer i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;  <span class="comment">//这里我们就简单将i转换为字符串形式</span></span><br></pre></td></tr></table></figure>

<p>不过还可以进行优化，首先方法参数类型是可以省略的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = (i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = i -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = i -&gt; i+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，相比我们之前直接去编写一个匿名内部类，是不是简介了很多很多。当然，除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;   <span class="comment">//接口中的定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;   <span class="comment">//现在有一个静态方法，刚好匹配接口中抽象方法的返回值和参数列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来，这也是为什么前面说<code>是我们为所需要的接口提供了一个方法作为它的实现</code>，是不是越来越体会到这句话的精髓了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = Main::impl;    <span class="comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要对一个数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;   <span class="comment">//来个数组</span></span><br><span class="line">    Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;   <span class="comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(array));   <span class="comment">//按从小到大的顺序排列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，Integer类中有一个叫做<code>compare</code>的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是一个静态方法，但是它却和<code>Comparator</code>需要实现的方法返回值和参数定义一模一样，所以，懂的都懂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compare);   <span class="comment">//直接指定一手，效果和上面是一模一样</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么要是不是静态方法而是普通的成员方法呢？我们注意到Comparator要求我们实现的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1 - o2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中o1和o2都是Integer类型的，我们发现Integer类中有一个<code>compareTo</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只不过这个方法并不是静态的，而是对象所有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);   <span class="comment">//这样进行比较也行，和上面效果依然是一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<p>但是此时我们会发现，IDEA提示我们可以缩写，这是为什么呢？实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，<code>o1</code>作为目标对象，<code>o2</code>作为参数，正好匹配了<code>compareTo</code>方法，所以，直接缩写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compareTo);  <span class="comment">//注意这里调用的不是静态方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Main mainObject = <span class="keyword">new</span> Main();</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, mainObject::reserve);  <span class="comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reserve</span><span class="params">(Integer a, Integer b)</span></span>&#123;  <span class="comment">//现在Main类中有一个刚好匹配的方法</span></span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，类的构造方法同样可以作为方法引用传递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(String str)</span></span>;   <span class="comment">//现在我们需要一个参数为String返回值为String的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，String类中刚好有一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;   <span class="comment">//由于String类的构造方法返回的肯定是一个String类型的对象，且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span></span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = original.coder;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是乎：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = String::<span class="keyword">new</span>;   <span class="comment">//没错，构造方法直接使用new关键字就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。</p>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。我们先来看看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;   <span class="comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span></span><br><span class="line">    System.out.println(str.toLowerCase());  <span class="comment">//那太简单了吧，直接转换打印一气呵成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样实现的话，我们少考虑了一个问题，万一给进来的<code>str</code>是<code>null</code>呢？如果是<code>null</code>的话，在调用<code>toLowerCase</code>方法时岂不是直接空指针异常了？所以我们还得判空一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决，这时，Optional来了，我们可以将任何的变量包装进Optional类中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(s -&gt; &#123;   <span class="comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span></span><br><span class="line">                System.out.println(s);   </span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里只有一句打印，所以我们来优化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(System.out::println);  </span><br><span class="line">  	<span class="comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p>
<p>除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).get());</span><br></pre></td></tr></table></figure>

<p>不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).orElse(<span class="string">&quot;VVV&quot;</span>));   <span class="comment">//orElse表示如果为空就返回里面的内容</span></span><br></pre></td></tr></table></figure>

<p>其他操作还请回顾JavaSE篇视频教程。</p>
<h2 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h2><p>这一部分，我们将介绍Java 9为我们带来的新特性，Java 9的主要特性有，全新的模块机制、接口的private方法等。</p>
<h3 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h3><p>在我们之前的开发中，不知道各位有没有发现一个问题，就是当我们导入一个<code>jar</code>包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库，实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。</p>
<p>于是，Java 9引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofan3qvxj21b409qjs3.jpg" alt="image-20220528210803658"></p>
<p>而在引入模块机制之后：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofcn7rt7j219009y3za.jpg" alt="image-20220528210958964"></p>
<p>可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。这里我们创建一个新的项目，并在<code>src</code>目录下，新建<code>module-info.java</code>文件表示此项目采用模块管理机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来创建一个主类：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofzqina8j21lo0bymyz.jpg" alt="image-20220528213210752"></p>
<p>程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2og24c18zj216o07gwf7.jpg" alt="image-20220528213428296"></p>
<p>Java为我们提供的<code>logging</code>相关日志库呢？我们发现现在居然不见了？实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库</span></span><br><span class="line">  	<span class="comment">//当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se;  即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们导入java.logging相关模块后，就可以正常使用Logger了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogarnv3hj21oi0bewgd.jpg" alt="image-20220528214247006"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogb52z1fj214203ejrl.jpg" alt="image-20220528214308194"></p>
<p>是不是瞬间感觉编写代码时清爽了许多，全新的模块化机制提供了另一个级别的Java代码可见性、可访问性的控制，不过，你以为仅仅是做了包的分离吗？我们可以来尝试通过反射获取JDK提供的类中的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java17版本的String类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>,</span></span><br><span class="line"><span class="class">               <span class="title">Constable</span>, <span class="title">ConstantDesc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;  <span class="comment">//自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">    Field field = stringClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);   <span class="comment">//这里我们通过反射来获取String类中的value字段</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//由于是private访问权限，所以我们修改一下</span></span><br><span class="line">    System.out.println(field.get(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，在程序运行之后，修改操作被阻止了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ohbps200j22l008qgpe.jpg" alt="image-20220528221817482"></p>
<p>反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的，看来Unsafe类是玩不成了。</p>
<p>我们现在就来细嗦一下这个模块机制，首先模块具有四种类型：</p>
<ul>
<li><strong>系统模块：</strong>来自JDK和JRE的模块（官方提供的模块，比如我们上面用的），我们也可以直接使用<code>java --list-modules</code>命令来列出所有的模块，不同的模块会导出不同的包供我们使用。</li>
<li><strong>应用程序模块：</strong>我们自己写的Java模块项目。</li>
<li><strong>自动模块：</strong>可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。</li>
<li><strong>未命名模块：</strong>我们自己创建的一个Java项目，如果没有创建<code>module-info.java</code>，那么会按照未命名模块进行处理，未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。不过，由于没有使用Java 9的模块新特性，未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）</li>
</ul>
<p>这里我们就来创建两个项目，看看如何使用模块机制，首先我们在项目A中，添加一个User类，一会项目B需要用到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (&quot;</span>+age+<span class="string">&quot;岁)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们编写一下项目A的模块设置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ois6anujj21mu09075b.jpg" alt="image-20220528230842617"></p>
<p>这里我们将<code>com.test</code>包下所有内容都暴露出去，默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用。</p>
<p>接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2oj4ivmi3j21kw08ujsm.jpg" alt="image-20220528232033318"></p>
<p>现在我们就可以在Main类中使用模块<code>module.a</code>中暴露出来的包内容了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.User;   <span class="comment">//如果模块module.a不暴露，那么将无法导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;lbw&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了普通的<code>exports</code>进行包的暴露之外，我们也可以直接指定将包暴露给指定的模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过现在还有一个问题，如果模块<code>module.a</code>依赖于其他模块，那么会不会传递给依赖于模块<code>module.a</code>的模块呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//这里添加一个模块的依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2njtdxyj21gu09iabi.jpg" alt="image-20220529103614788"></p>
<p>可以看到，在模块<code>module.b</code>中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用，但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> transitive java.logging;   <span class="comment">//使用transitive来向其他模块传递此依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以使用了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2pvizv2j21cu0b275z.jpg" alt="image-20220529103828560"></p>
<p>还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    Class&lt;User&gt; userClass = User.class;</span><br><span class="line">    Field field = userClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//尝试修改访问权限</span></span><br><span class="line">    System.out.println(field.get(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2widxrbj22l608cwip.jpg" alt="image-20220529104451040"></p>
<p>那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;   <span class="comment">//直接添加open关键字开放整个模块的反射权限</span></span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    opens com.test;   <span class="comment">//通过使用opens关键字来为其他模块开放反射权限</span></span><br><span class="line">  	<span class="comment">//也可以指定目标开放反射 opens com.test to module.b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以指定模块需要使用的抽象类或是接口实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    uses com.test.Test;  <span class="comment">//使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在模块B中去实现一下，然后声明我们提供了实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestImpl</span> <span class="keyword">implements</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.b &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.a;   <span class="comment">//导入项目A的模块，此模块暴露了com.test包</span></span><br><span class="line">    provides com.test.Test with com.main.TestImpl;  <span class="comment">//声明此模块提供了Test的实现类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p3zb45vqj225w0qowlb.jpg" alt="image-20220529112208486"></p>
<p>然后我们导入了lombok框架的依赖，如果我们不创建<code>module-info.java</code>文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.java.Log;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//使用lombok提供的注解，可以正常运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好<code>module-info.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，直接报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p44huvl1j21tk0bcmzz.jpg" alt="image-20220529112707958"></p>
<p>明明导入了lombok依赖，却无法使用，这是因为我们还需要去依赖对应的模块才行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">    <span class="keyword">requires</span> lombok;   <span class="comment">//lombok模块</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;    <span class="comment">//JUL日志模块，也需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p46lqnndj21au0fu0ug.jpg" alt="image-20220529112909452"></p>
<p>这样我们就可以正常使用了，之后为了教程演示方便，咱们还是不用模块。</p>
<h3 id="JShell交互式编程"><a href="#JShell交互式编程" class="headerlink" title="JShell交互式编程"></a>JShell交互式编程</h3><p>Java 9为我们通过了一种交互式编程工具JShell，你还别说，真有Python那味。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p8zzjlfdj20v204yaaf.jpg" alt="image-20220529141547082"></p>
<p>环境配置完成后，我们只需要输入<code>jshell</code>命令即可开启交互式编程了，它支持我们一条一条命令进行操作。</p>
<p>比如我们来做一个简单的计算：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p91l5635j212609qt8z.jpg" alt="image-20220529141719363"></p>
<p>我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p949kt5nj20ze06sdg8.jpg" alt="image-20220529141954494"></p>
<p>我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p986jzkdj215608074z.jpg" alt="image-20220529142340030"></p>
<p>除了直接运行我们写进去的代码之外，它还支持使用命令，输入<code>help</code>来查看命令列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p998buwcj217m0a4t9r.jpg" alt="image-20220529142440584"></p>
<p>比如我们可以使用<code>/vars</code>命令来展示当前定义的变量列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9cn6p6qj20wy042t8s.jpg" alt="image-20220529142757286"></p>
<p>当我们不想使用jshell时，直接输入<code>/exit</code>退出即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9dlqiucj20rw03274b.jpg" alt="image-20220529142852920"></p>
<h3 id="接口中的private方法"><a href="#接口中的private方法" class="headerlink" title="接口中的private方法"></a>接口中的private方法</h3><p>在Java 8中，接口中 的方法支持添加<code>default</code>关键字来添加默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9中，接口再次得到强化，现在接口中可以存在私有方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的私有方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。</p>
<h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>在之前，如果我们想要快速创建一个Map只能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//要快速使用Map，需要先创建一个Map对象，然后再添加数据</span></span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9之后，我们可以直接通过<code>of</code>方法来快速创建了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">20</span>);  <span class="comment">//直接一句搞定</span></span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9ymylq6j21k00ggact.jpg" alt="image-20220529144905646"></p>
<p>但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是无法进行修改的。</p>
<p>当然，除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;AAA&quot;</span>);  <span class="comment">//注意Set中元素顺序并不一定你的添加顺序</span></span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;BBB&quot;</span>);   <span class="comment">//好耶，再也不用Arrays了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h3><p>还记得我们之前在JavaSE中学习的Stream流吗？当然这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//这里我们可以直接将一些元素封装到Stream中</span></span><br><span class="line">            .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">            .distinct()   <span class="comment">//去重</span></span><br><span class="line">            .forEach(System.out::println);   <span class="comment">//最后打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成（具体的详细操作请回顾JavaSE篇）</p>
<p>如此方便的框架，在Java 9得到了进一步的增强：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="keyword">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream</span><br><span class="line">            .ofNullable(<span class="keyword">null</span>) <span class="comment">//使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)   <span class="comment">//Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。</span></span><br><span class="line">      			.limit(<span class="number">20</span>)   <span class="comment">//这里限制生成20个</span></span><br><span class="line">            .forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            <span class="comment">//不知道怎么写？参考一下：for (int i = 0;i &lt; 20;i++)</span></span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .takeWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//当i小于10时正常通过，一旦大于等于10直接截断</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .dropWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//和上面相反，上来就是截断状态，只有当满足条件时再开始通过</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他小型变动"><a href="#其他小型变动" class="headerlink" title="其他小型变动"></a>其他小型变动</h3><p>Try-with-resource语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = Files.newInputStream(Paths.get(<span class="string">&quot;pom.xml&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> (inputStream) &#123;   <span class="comment">//单独丢进try中，效果是一样的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) inputStream.read());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 8中引入了Optional类，它很好的解决了判空问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    test(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//比如现在我们想执行 System.out.println(str.toLowerCase())</span></span><br><span class="line">    <span class="comment">//但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常</span></span><br><span class="line">    <span class="comment">//但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装</span></span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(s)</span><br><span class="line">            .ifPresent(str -&gt; System.out.println(str.toLowerCase()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就有点像Kotlin或是JS中的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str : <span class="type">String</span>?)</span></span>&#123;   <span class="comment">//传入的String对象可能为null，这里类型写为String?</span></span><br><span class="line">    println(str?.lowercase())   <span class="comment">// ?.表示只有不为空才进行调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 9新增了一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str).ifPresentOrElse(s -&gt; &#123;  <span class="comment">//通过使用ifPresentOrElse，我们同时处理两种情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为：&quot;</span>+s);     <span class="comment">//第一种情况和ifPresent是一样的</span></span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为null&quot;</span>);   <span class="comment">//第二种情况是如果为null的情况</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>or()</code>方法快速替换为另一个Optional类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str)</span><br><span class="line">      .or(() -&gt; Optional.of(<span class="string">&quot;AAA&quot;</span>))   <span class="comment">//如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装</span></span><br><span class="line">      .ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还支持直接转换为Stream，这里就不多说了。</p>
<p>在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">//这里我们写一个泛型类</span></span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="string">&quot;AAA&quot;</span>) &#123;   <span class="comment">//在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢</span></span><br><span class="line">      <span class="comment">//在Java 9之后，这样的写法终于可以编译通过了</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。</p>
<h2 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h2><p>Java 10主要带来的是一些内部更新，相比Java 9带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了。</p>
<h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>在Java中，我们可以使用自动类型推断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   之前我们定义变量必须指定类型</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在我们使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是注意，<code>var</code>关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe3mpaw5j210u054jrw.jpg" alt="image-20220529171216795"></p>
<p>我们来看看是不是类型也能正常获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(a.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然是有了var关键字进行自动类型推断，但是最终还是会变成String类型，得到的Class也是String类型。但是Java终究不像JS那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pdwq4g2aj218e0b4jsh.jpg" alt="image-20220529170538383"></p>
<p>并且<code>var</code>关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe66iavlj216y0963z1.jpg" alt="image-20220529171444062"></p>
<p>有关Java 10新增的一些其他改进，这里就不提了。</p>
<h2 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h2><p>Java 11 是继Java 8之后的又一个TLS长期维护版本，在Java 17出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于Lambda的形参局部变量语法。</p>
<h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 10我们认识了<code>var</code>关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在lambda中使用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppu61uu4j211w05m3z0.jpg" alt="image-20220529235822891"></p>
<p>但是实际上这里是完全可以进行类型推断的，所以在Java 11，终于是支持了，这样编写就不会报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppvf70n0j213g05m3yu.jpg" alt="image-20220529235935071"></p>
<h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;AB\nC\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str</span><br><span class="line">            .lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>repeat()</code>方法来让字符串重复拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;ABCD&quot;</span>;   <span class="comment">//比如现在我们有一个ABCD，但是现在我们想要一个ABCDABCD这样的基于原本字符串的重复字符串</span></span><br><span class="line">    System.out.println(str.repeat(<span class="number">2</span>));  <span class="comment">//一个repeat就搞定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以快速地进行空格去除操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全新的HttpClient使用"><a href="#全新的HttpClient使用" class="headerlink" title="全新的HttpClient使用"></a>全新的HttpClient使用</h3><p>在Java 9的时候其实就已经引入了全新的Http Client API，用于取代之前比较老旧的HttpURLConnection类，新的API支持最新的HTTP2和WebSocket协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();   <span class="comment">//直接创建一个新的HttpClient</span></span><br><span class="line">  	<span class="comment">//现在我们只需要构造一个Http请求实体，就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似）</span></span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://www.baidu.com&quot;</span>)).build();</span><br><span class="line">  	<span class="comment">//现在我们就可以把请求发送出去了，注意send方法后面还需要一个响应体处理器（内置了很多）这里我们选择ofString直接吧响应实体转换为String字符串</span></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">  	<span class="comment">//来看看响应实体是什么吧</span></span><br><span class="line">    System.out.println(response.body());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用全新的客户端，我们甚至可以轻松地做一个爬虫（仅供学习使用，别去做违法的事情，爬虫玩得好，牢饭吃到饱），比如现在我们想去批量下载某个网站的壁纸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9pg4bvdj22920jcq83.jpg" alt="image-20220530112549225"></p>
<p>网站地址：<a href="https://pic.netbian.com/4kmeinv/">https://pic.netbian.com/4kmeinv/</a></p>
<p>我们随便点击一张壁纸，发现网站的URL格式为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9qp1af0j220s0loaf5.jpg" alt="image-20220530112701156"></p>
<p>并且不同的壁纸似乎都是这样：<a href="https://pic.netbian.com/tupian/%E6%95%B0%E5%AD%97.html%EF%BC%8C%E5%A5%BD%E4%BA%86%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%95%B4%E6%B4%BB%E4%BA%86%EF%BC%9A">https://pic.netbian.com/tupian/数字.html，好了差不多可以开始整活了：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//先不要一次性获取太多，先来10个</span></span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com/tupian/&quot;</span>+(<span class="number">29327</span> + i)+<span class="string">&quot;.html&quot;</span>)).build();  <span class="comment">//这里我们按照规律，批量获取</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());  <span class="comment">//这里打印一下看看网页</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后控制台成功获取到这些图片的网站页面了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9uh6barj21k40b40w3.jpg" alt="image-20220530113039571"></p>
<p>接着我们需要来观察一下网站的HTML具体怎么写的，把图片的地址提取出来：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9vgs183j22b60esdmg.jpg" alt="image-20220530113136156"></p>
<p>好了，知道图片在哪里就好办了，直接字符串截取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        String html = response.body();</span><br><span class="line">        </span><br><span class="line">        String prefix = <span class="string">&quot;&lt;a href=\&quot;\&quot; id=\&quot;img\&quot;&gt;&lt;img src=\&quot;&quot;</span>;  <span class="comment">//先找好我们要截取的前面一段，作为前缀去匹配位置</span></span><br><span class="line">        String suffix = <span class="string">&quot;\&quot; data-pic=&quot;</span>;   <span class="comment">//再找好我们要截取的屁股后面紧接着的位置，作为后缀去匹配位置</span></span><br><span class="line">      	<span class="comment">//直接定位，然后前后截取，得到最终的图片地址</span></span><br><span class="line">        html = html.substring(html.indexOf(prefix) + prefix.length());</span><br><span class="line">        html = html.substring(<span class="number">0</span>, html.indexOf(suffix));</span><br><span class="line">        System.out.println(html);  <span class="comment">//最终的图片地址就有了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">				<span class="comment">//创建请求，把图片取到</span></span><br><span class="line">        HttpRequest imageRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com&quot;</span>+html)).build();</span><br><span class="line">      	<span class="comment">//这里以输入流的方式获取，不过貌似可以直接下载文件，各位小伙伴可以单独试试看</span></span><br><span class="line">        HttpResponse&lt;InputStream&gt; imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream());</span><br><span class="line">      	<span class="comment">//拿到输入流和文件输出流</span></span><br><span class="line">        InputStream imageInput = imageResponse.body();</span><br><span class="line">        FileOutputStream stream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;images/&quot;</span>+i+<span class="string">&quot;.jpg&quot;</span>); <span class="comment">//一会要保存的格式</span></span><br><span class="line">        <span class="keyword">try</span> (stream;imageInput)&#123;  <span class="comment">//直接把要close的变量放进来就行，简洁一些了</span></span><br><span class="line">            <span class="keyword">int</span> size;   <span class="comment">//下面具体保存过程的不用我多说了吧</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">            <span class="keyword">while</span> ((size = imageInput.read(data)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                stream.write(data, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在来看看效果吧，美女的图片已经成功保存到本地了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qacy37g6j22bs0psjwj.jpg" alt="image-20220530114824605"></p>
<p>当然，这仅仅是比较简单的爬虫，不过我们的最终目的还是希望各位能够学会使用新的HttpClient API。</p>
<h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12-16 新特性"></a>Java 12-16 新特性</h2><p>由于Java版本的更新迭代速度自Java 9开始为半年更新一次（Java 8到Java 9隔了整整三年），所以各个版本之间的更新内容比较少，剩余的6个版本，我们就多个版本放在一起进行讲解了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qawt5acvj21ci0u0tcg.jpg" alt="image-20220530120729757"></p>
<p>Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能，12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用，其实就是体验服的那种感觉。</p>
<h3 id="新的switch语法"><a href="#新的switch语法" class="headerlink" title="新的switch语法"></a>新的switch语法</h3><p>在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活，比如我们想要编写一个根据成绩得到等级的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入分数（范围 0 - 100）返回对应的等级：</span></span><br><span class="line"><span class="comment"> *      100-90：优秀</span></span><br><span class="line"><span class="comment"> *      70-80：良好</span></span><br><span class="line"><span class="comment"> *      60-70：及格</span></span><br><span class="line"><span class="comment"> *      0-60：寄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> score 分数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想要使用switch来实现这个功能（不会吧不会吧，不会有人要想半天怎么用switch实现吧），之前的写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">  	String res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//不同的分数段就可以返回不同的等级了</span></span><br><span class="line">        		<span class="keyword">break</span>;   <span class="comment">//别忘了break，不然会贯穿到后面</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在我们可以使用新的特性了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了（有时候就容易忘记，这样的话就算忘记也没事了）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过最后编译出来的样子，貌似还是和之前是一样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qsvu3u7dj21zw0nawhc.jpg" alt="image-20220530222918174"></p>
<p>这种全新的switch语法称为<code>switch表达式</code>，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</span></span><br><span class="line">    <span class="keyword">case</span> ...   <span class="comment">//根据不同的分支，可以存在多个case</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;   <span class="comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//我们可以使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//... 我是其他要做的事情</span></span><br><span class="line">        yield  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (args.length) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...]:</span><br><span class="line">        yield <span class="string">&quot;AAA&quot;</span>;   <span class="comment">//传统的:写法，通过yield指定返回结果，同样不需要break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    		System.out.println(<span class="string">&quot;默认情况&quot;</span>);</span><br><span class="line">        yield <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。</p>
<p><strong>注意：</strong>switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。</p>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>如果你学习过Python，一定知道三引号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span></span><br><span class="line">multi_line =  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                nice to meet you!</span></span><br><span class="line"><span class="string">                  nice to meet you!</span></span><br><span class="line"><span class="string">                      nice to meet you!</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> multi_line</span><br></pre></td></tr></table></figure>

<p>没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtu8ym7pj218008w3z2.jpg" alt="image-20220530230225037"></p>
<p>可以看到，Java中也可以使用这样的三引号来表示字符串了，并且我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtvm8z1wj21e008kdgm.jpg" alt="image-20220530230343933"></p>
<p>仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？</p>
<p><strong>注意：</strong>文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。</p>
<h3 id="新的instanceof语法"><a href="#新的instanceof语法" class="headerlink" title="新的instanceof语法"></a>新的instanceof语法</h3><p>在Java 14，instanceof迎来了一波小更新（哈哈，这版本instanceof又加强了，版本强势语法）</p>
<p>比如我们之前要重写一个类的equals方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//首先判断是否为Student类型</span></span><br><span class="line">            Student student = (Student) obj;  <span class="comment">//如果是，那么就类型转换</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//最后比对属性是否一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qufj2gt9j21da0bowg5.jpg" alt="image-20220530232252253"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;   <span class="comment">//在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//下面直接用，是不是贼方便</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用<code>instanceof</code>判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤。</p>
<p><strong>注意：</strong>新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h3 id="空指针异常的改进"><a href="#空指针异常的改进" class="headerlink" title="空指针异常的改进"></a>空指针异常的改进</h3><p>相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = a.length() + b.length();   <span class="comment">//可能给进来的a或是b为null</span></span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为空时，就会直接：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qukskyh6j21a602mgm0.jpg" alt="image-20220530232755797"></p>
<p>但是由于我们这里a和b都调用了<code>length()</code>方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）</p>
<p>但是当我们在Java 14或更高版本运行时：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qunhkgrcj21lc042my7.jpg" alt="image-20220530233031005"></p>
<p>这里会明确指出是哪一个变量调用出现了空指针，是不是感觉特别人性化。</p>
<h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><p>继类、接口、枚举、注解之后的又一新类型来了，它的名字叫”记录”，在Java 14中首次出场，这一出场，Lombok的噩梦来了。</p>
<p>在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据，比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;   <span class="comment">//使用Lombok，一个注解就搞定了</span></span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lombok可以说是简化代码的神器了，他能在编译时自动生成getter和setter、构造方法、toString()方法等实现，在编写这些实体类时，简直不要太好用，而这一波，官方也是看不下去了，于是自己也搞了一个记录类型。</p>
<p>记录类型本质上也是一个普通的类，不过是final类型且继承自java.lang.Record抽象类的，它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，好家伙，这是要逼死Lombok啊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> </span>&#123;  <span class="comment">//直接把字段写在括号中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qve5yx6tj219u086ab5.jpg" alt="image-20220530235609885"></p>
<p>并且toString也是被重写了的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qvfdhp6oj219001s3yo.jpg" alt="image-20220530235719341"></p>
<p><code>equals()</code>方法仅做成员字段之间的值比较，也是帮助我们实现好了的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Account account0 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">Account account1 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);   <span class="comment">//两个属性都是一模一样的</span></span><br><span class="line">System.out.println(account0.equals(account1));  <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>

<p>是不是感觉这种类型就是专门为这种实体类而生的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> implements Runnable </span>&#123;  <span class="comment">//支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h2 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h2><p>Java 17作为新的LTS长期维护版本，我们来看看都更新了什么（不包含预览特性，包括switch第二次增强，哈哈，果然还是强度不够，都连续加强两个版本了）</p>
<h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>密封类型可以说是Java 17正式推出的又一重磅类型，它在Java 15首次提出并测试了两个版本。</p>
<p>在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p>
<p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;   <span class="comment">//添加final关键字后，不允许对此类继承</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。</p>
<p>但是现在我们可以使用密封类型来实现这个功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>密封类型有以下要求：</p>
<ul>
<li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li>
<li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li>
<li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li>
<li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li>
</ul>
<p>标准的声明格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed [<span class="keyword">abstract</span>] [<span class="class"><span class="keyword">class</span>/<span class="title">interface</span>] 类名 [<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口, ...] <span class="title">permits</span> [子类, ...]</span>&#123;</span><br><span class="line">		<span class="comment">//里面的该咋写咋写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意子类格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/sealed/non-sealed] <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line">			<span class="comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span></span><br><span class="line">  		<span class="comment">//sealed类型：同父类，需要指定由哪些类继承。</span></span><br><span class="line">  		<span class="comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在我们写了这些类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//指定B继承A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;   <span class="comment">//在子类final，彻底封死</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到其他的类无论是继承A还是继承B都无法通过编译：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5p7u49j216i05074q.jpg" alt="image-20220531090136485"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5zg837j2130050jrz.jpg" alt="image-20220531090152743"></p>
<p>但是如果此时我们主动将B设定为<code>non-sealed</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> non-sealed <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正常继承了，因为B指定了<code>non-sealed</code>主动放弃了密封特性，这样就显得非常灵活了。</p>
<p>当然我们也可以通过反射来获取类是否为密封类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());   <span class="comment">//是否为密封</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Java 9 - 17的主要新特性就讲解完毕了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jdk新特性</tag>
      </tags>
  </entry>
</search>
