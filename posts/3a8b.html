<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="NmvL2aBrGRwi3CzraBejtkwEbHmmH-7u73OJj3FMOoc">
  <meta name="msvalidate.01" content="5DB1ECD7406CD70A251CF96C939178B9">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuumiy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="网络编程学习NIO基础在JavaSE的学习中，了解到如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程学习">
<meta property="og:url" content="https://yuumiy.github.io/posts/3a8b.html">
<meta property="og:site_name" content="岛田悠米">
<meta property="og:description" content="网络编程学习NIO基础在JavaSE的学习中，了解到如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kkaatg47j21kk0bgmyp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knn61e76j21ra08it8y.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knnkm8omj21ro08gjrs.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmdmh8ypj21ks0b8gmx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmenwakbj21lu04kwfk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knmgx4rfj21qy0j6wga.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knm0wy6bj21rq0jaac6.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knjeatbjj219y01kmx1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kph5va26j21ry07ut94.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kpw3b24fj21d601aq2t.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krtfdjjxj21qw082t96.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kru5ys1aj21ru096dgg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krvhots6j21s0088aar.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krycqrmej21ri080wfb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksetaccij21b603oq35.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksmjx76ij21ru07u75a.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksq30gzij21pw08gt9b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksqmk9smj21dw05q3yy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktaynv7nj21kw02gglg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktrvyy39j221e0f8ac2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktz4pkhtj21ue04oab1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kulzci1zj21cc05kaa3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kvvus5tej219a06c0u1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kw7cc7vnj223y0f80v0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lphvijimj223g0lajug.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1muofbqbmj22520pe0yu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mx9in88jj21l403mgmo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mxbknxa4j21gg03ijsd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5uyrdjij21t40hsmzt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5vwim5ej21hc06ct9x.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5w43wzxj21ii06igmw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ni0yi6vcj21t008ugo8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niehdyqkj21eg03wgm2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nier022vj21go03mwex.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqbuoygj218w02mq39.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqlky3ij21ek04igma.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odmx2b3yj21o60dcwgh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odzw1dk3j21oi0e2goy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9h1v29j213w06m74t.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9ms12cj217005uwet.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wgietqmhj21fq0c6tah.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1whmt5w1sj21fq0cmac7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z0omdbn1j21q60isq70.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z1qtxd9nj21cy078jrw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2lccfu5j21ii0c60tu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2em84c6j21cm0da3z4.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmuamek3j21ou0hmdiq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmugj9ztj21l005qt9d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1znqwr5lqj21wa0pak1k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zwgc0v5ej21fe08m3z1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxvmzz7hj224806sq64.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxbvl2y3j21h803st9z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zygujz9sj21no0c0abg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25i6lqr4hj21l80gct9n.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25ify7168j21s60i4n0f.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iui62e8j21na0i477f.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iwxop2wj21ky0i0ad1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25izbhxnrj21f60hwtb0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h22hrmmll1j21hg0c040d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h231vpff1tj21j60900tp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2329bmho8j21g407y75e.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hpuq1sej219i08wgms.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2381nnw6kj21ey0bitam.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2390nmv60j21es0awta1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h23b2raotjj21a607u3zd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24d0v15dkj21zs0k6ad5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24db102gqj214o02qq2x.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dcpcdxoj215e04eq2z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24domthrqj21qe0i8mzp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dtwy88pj214y04ojrv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dxlf02nj21qu0fyn0h.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24ej8u6cqj219m04cq3f.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24fzjztiyj22ac0k2gox.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24g08odmrj21e604kmyh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gcntjzbj210c02e74b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gjzm12aj214i0k842b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hbzfrozj21dy0u0jw2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25j8p1xc2j22ig0sutk2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jjq53pvj21r40m8abh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jteal4rj21eo07qabh.jpg">
<meta property="article:published_time" content="2022-10-19T15:03:30.000Z">
<meta property="article:modified_time" content="2022-10-19T15:03:30.000Z">
<meta property="article:author" content="Yuumiy">
<meta property="article:tag" content="网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kkaatg47j21kk0bgmyp.jpg">

<link rel="canonical" href="https://yuumiy.github.io/posts/3a8b.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>网络编程学习 | 岛田悠米</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="岛田悠米" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛田悠米</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心中有梦 不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuumiy.github.io/posts/3a8b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yuumiy">
      <meta itemprop="description" content="coding就是生产力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛田悠米">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络编程学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-19 23:03:30" itemprop="dateCreated datePublished" datetime="2022-10-19T23:03:30+08:00">2022-10-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span id="/posts/3a8b.html" class="post-meta-item leancloud_visitors" data-flag-title="网络编程学习" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/posts/3a8b.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/3a8b.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>111k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:41</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer" />

<h1 id="网络编程学习"><a href="#网络编程学习" class="headerlink" title="网络编程学习"></a>网络编程学习</h1><h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><p>在JavaSE的学习中，了解到如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。</p>
<p>NIO框架是在JDK1.4推出的，它的出现就是为了解决传统IO的不足。</p>
<p>​<span id="more"></span></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>一切的一切还要从缓冲区开始讲起，包括源码在内，其实这个不是很难，只是需要理清思路。</p>
<h3 id="Buffer类及其实现"><a href="#Buffer类及其实现" class="headerlink" title="Buffer类及其实现"></a>Buffer类及其实现</h3><p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。</p>
<p>Buffer是一个抽象类，它的核心内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这四个变量的关系: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">  	<span class="comment">// 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接缓冲区实现子类的数据内存地址（之后会讲解）</span></span><br><span class="line">    <span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure>

<p>我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了<code>boolean</code>类型之外）：</p>
<ul>
<li>IntBuffer   -   int类型的缓冲区。</li>
<li>ShortBuffer   -   short类型的缓冲区。</li>
<li>LongBuffer   -   long类型的缓冲区。</li>
<li>FloatBuffer   -   float类型的缓冲区。</li>
<li>DoubleBuffer   -   double类型的缓冲区。</li>
<li>ByteBuffer   -   byte类型的缓冲区。</li>
<li>CharBuffer   -   char类型的缓冲区。</li>
</ul>
<p>（注意我们之前在JavaSE中学习过的StringBuffer虽然也是这种命名方式，但是不属于Buffer体系，这里不会进行介绍）</p>
<p>这里我们以IntBuffer为例，我们来看看如何创建一个Buffer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：</span></span><br><span class="line">    <span class="comment">//1. 申请一个容量为10的int缓冲区</span></span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据）</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它的内部是本质上如何进行操作的呢？我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)   <span class="comment">//如果申请的容量小于0，那还有啥意思</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(capacity, capacity);   <span class="comment">//可以看到这里会直接创建一个新的IntBuffer实现类</span></span><br><span class="line">  	<span class="comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//可以看到这个也是创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);   <span class="comment">//调用的是上面的wrap方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBuffer又是如何实现的呢，我们接着来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HeapIntBuffer(<span class="keyword">int</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);   <span class="comment">//你会发现这怎么又去调父类的构造方法了，绕来绕去</span></span><br><span class="line">  	<span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又来看看IntBuffer中的构造方法是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] hb;                  <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">             <span class="keyword">int</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);  <span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.hb = hb;    <span class="comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.offset = offset;   <span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看Buffer中的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;       <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)  <span class="comment">//容量不能小于0，小于0还玩个锤子</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="keyword">this</span>.capacity = cap;   <span class="comment">//设定缓冲区容量</span></span><br><span class="line">    limit(lim);    <span class="comment">//设定最大position位置</span></span><br><span class="line">    position(pos);   <span class="comment">//设定起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;  <span class="comment">//如果起始标记大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)  <span class="comment">//并且标记位置大于起始位置，那么就抛异常（至于为啥不能大于我们后面再说）</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;   <span class="comment">//否则设定mark位置（mark默认为-1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对源码的观察，我们大致可以得到以下结构了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kkaatg47j21kk0bgmyp.jpg" alt="image-20220424093805677"></p>
<p>现在我们来总结一下上面这些结构的各自职责划分：</p>
<ul>
<li>Buffer：缓冲区的一些基本变量定义，比如当前的位置（position）、容量 (capacity)、最大限制 (limit)、标记 (mark)等，你肯定会疑惑这些变量有啥用，别着急，这些变量会在后面的操作中用到，我们逐步讲解。</li>
<li>IntBuffer等子类：定义了存放数据的数组（只有堆缓冲区实现子类才会用到）、是否只读等，也就是说数据的存放位置、以及对于底层数组的相关操作都在这里已经定义好了，并且已经实现了Comparable接口。</li>
<li>HeapIntBuffer堆缓冲区实现子类：数据存放在堆中，实际上就是用的父类的数组在保存数据，并且将父类定义的所有底层操作全部实现了。</li>
</ul>
<p>这样，我们对于Buffer类的基本结构就有了一个大致的认识。</p>
<h3 id="缓冲区写操作"><a href="#缓冲区写操作" class="headerlink" title="缓冲区写操作"></a>缓冲区写操作</h3><p>前面我们了解了Buffer类的基本操作，现在我们来看一下如何向缓冲区中存放数据以及获取数据，数据的存放包括以下四个方法：</p>
<ul>
<li>public abstract IntBuffer put(int i);   -   在当前position位置插入数据，由具体子类实现</li>
<li>public abstract IntBuffer put(int index, int i);   -   在指定位置存放数据，也是由具体子类实现</li>
<li>public final IntBuffer put(int[] src);   -   直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</li>
<li>public IntBuffer put(int[] src, int offset, int length);   -   直接存放数组中的内容，同上，但是可以指定存放一段范围</li>
<li>public IntBuffer put(IntBuffer src);   -   直接存放另一个缓冲区中的内容</li>
</ul>
<p>我们从最简的开始看，是在当前位置插入一个数据，那么这个当前位置是怎么定义的呢，我们来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;   <span class="comment">//这个ix和nextPutIndex()很灵性，我们来看看具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以put操作实际上是将底层数组<code>hb</code>在position位置上的数据进行设定。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knn61e76j21ra08it8y.jpg" alt="image-20220424113417640"></p>
<p>设定完成后，position自动后移：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knnkm8omj21ro08gjrs.jpg" alt="image-20220424113440765"></p>
<p>我们可以编写代码来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer</span><br><span class="line">            .put(<span class="number">1</span>)</span><br><span class="line">            .put(<span class="number">2</span>)</span><br><span class="line">            .put(<span class="number">3</span>);   <span class="comment">//我们依次存放三个数据试试看</span></span><br><span class="line">    System.out.println(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过断点调试，我们来看看实际的操作情况：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmdmh8ypj21ks0b8gmx.jpg" alt="image-20220424105031549"></p>
<p>可以看到我们不断地put操作，position会一直向后移动，当然如果超出最大长度，那么会直接抛出异常：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kmenwakbj21lu04kwfk.jpg" alt="image-20220424105131279"></p>
<p>接着我们来看看第二个put操作是如何进行，它能够在指定位置插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;  <span class="comment">//这里依然会使用ix，但是会检查位置是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;                       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))    <span class="comment">//插入的位置不能小于0并且不能大于等于底层数组最大长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">//没有问题就把i返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个比我们之前的要好理解一些，注意全程不会操作position的值，这里需要注意一下。</p>
<p>我们接着来看第三个put操作，它是直接在IntBuffer中实现的，是基于前两个put方法的子类实现来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);   <span class="comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//接着判断要插入的数据量在缓冲区是否容得下，装不下也不行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;   <span class="comment">//计算出最终读取位置，下面开始for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);   <span class="comment">//注意是直接从postion位置开始插入，直到指定范围结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   <span class="comment">//ojbk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);   <span class="comment">//因为不需要指定范围，所以直接0和length，然后调上面的，多捞哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="keyword">int</span> rem = limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)  <span class="comment">//让我猜猜，看不懂了是吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">  	<span class="comment">//实际上就是看给定的数组能不能截取出指定的这段数据，如果都不够了那肯定不行啊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程如下，首先来了一个数组要取一段数据全部丢进缓冲区：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knmgx4rfj21qy0j6wga.jpg" alt="image-20220424113337189"></p>
<p>在检查没有什么问题并且缓冲区有容量时，就可以开始插入了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knm0wy6bj21rq0jaac6.jpg" alt="Img"></p>
<p>最后我们通过代码来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    buffer.put(arr, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">//从下标3开始，截取4个元素</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));  <span class="comment">//array方法可以直接获取到数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1knjeatbjj219y01kmx1.jpg" alt="image-20220424113040485"></p>
<p>当然我们也可以将一个缓冲区的内容保存到另一个缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(IntBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)   <span class="comment">//不会吧不会吧，不会有人保存自己吧</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())   <span class="comment">//如果是只读的话，那么也是不允许插入操作的（我猜你们肯定会问为啥就这里会判断只读，前面四个呢）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();  <span class="comment">//给进来的src看看容量（注意这里不remaining的结果不是剩余容量，是转换后的，之后会说）</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())    <span class="comment">//这里判断当前剩余容量是否小于src容量</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//也是从position位置开始继续写入</span></span><br><span class="line">        put(src.get());   <span class="comment">//通过get方法一个一个读取数据出来，具体过程后面讲解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果是这样的话，会出现问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);   <span class="comment">//手动插入数据</span></span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，结果和上面的不一样，并没有成功地将数据填到下面的IntBuffer中，这是为什么呢？实际上就是因为<code>remaining()</code>的计算问题，因为这个方法是直接计算postion的位置，但是由于我们在写操作完成之后，position跑到后面去了，也就导致<code>remaining()</code>结果最后算出来为0。</p>
<p>因为这里不是写操作，是接下来需要从头开始进行读操作，所以我们得想个办法把position给退回到一开始的位置，这样才可以从头开始读取，那么怎么做呢？一般我们在写入完成后需要进行读操作时（后面都是这样，不只是这里），会使用<code>flip()</code>方法进行翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里，limit的作用开始慢慢体现了</span></span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，再次计算<code>remaining()</code>的结果就是我们需要读取的数量了，这也是为什么put方法中要用<code>remaining()</code>来计算的原因，我们再来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer src = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);</span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    src.flip();   <span class="comment">//我们可以通过flip来翻转缓冲区</span></span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻转之后再次进行转移，就正常了。</p>
<h3 id="缓冲区读操作"><a href="#缓冲区读操作" class="headerlink" title="缓冲区读操作"></a>缓冲区读操作</h3><p>前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：</p>
<ul>
<li><code>public abstract int get();</code>    -    直接获取当前position位置的数据，由子类实现</li>
<li><code>public abstract int get(int index); </code>  -    获取指定位置的数据，也是子类实现</li>
<li><code>public IntBuffer get(int[] dst)</code>  -   将数据读取到给定的数组中</li>
<li><code>public IntBuffer get(int[] dst, int offset, int length)</code>  -   同上，加了个范围</li>
</ul>
<p>我们还是从最简单的开始看，第一个get方法的实现在IntBuffer类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];    <span class="comment">//直接从数组中取就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// 好家伙，这不跟前面那个一模一样吗</span></span><br><span class="line">  <span class="keyword">int</span> p = position;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">  position = p + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每次读取操作之后，也会将postion+1，直到最后一个位置，如果还要继续读，那么就直接抛出异常。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kph5va26j21ry07ut94.jpg" alt="image-20220424123743020"></p>
<p>我们来看看第二个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];   <span class="comment">//这里依然是使用checkIndex来检查位置是否非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看第三个和第四个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);   <span class="comment">//跟put操作一样，也是需要检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//如果读取的长度比可以读的长度大，那肯定是不行的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;    <span class="comment">//计算出最终读取位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();   <span class="comment">//开始从position把数据读到数组中，注意是在数组的offset位置开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);   <span class="comment">//不指定范围的话，那就直接用上面的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    buffer.get(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kpw3b24fj21d601aq2t.jpg" alt="image-20220424125203822"></p>
<p>可以看到成功地将数据读取到了数组中。</p>
<p>当然如果我们需要直接获取数组，也可以使用<code>array()</code>方法来拿到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)   <span class="comment">//为空那说明底层不是数组实现的，肯定就没法转换了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)   <span class="comment">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;   <span class="comment">//直接返回hb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，既然都已经拿到了底层的<code>hb</code>了，我们来看看如果直接修改之后是不是读取到的就是我们的修改之后的结果了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span>[] arr = buffer.array();</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">99999</span>;   <span class="comment">//拿到数组对象直接改</span></span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这种方式由于是直接拿到的底层数组，所有修改会直接生效在缓冲区中。</p>
<p>当然除了常规的读取方式之外，我们也可以通过<code>mark()</code>来实现跳转读取，这里需要介绍一下几个操作：</p>
<ul>
<li><code>public final Buffer mark()</code>   -   标记当前位置</li>
<li><code>public final Buffer reset()</code>   -   让当前的position位置跳转到mark当时标记的位置</li>
</ul>
<p>我们首先来看标记方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;   <span class="comment">//直接标记到当前位置，mark变量终于派上用场了，当然这里仅仅是标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看重置方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;   <span class="comment">//存一下当前的mark位置</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)    <span class="comment">//因为mark默认是-1，要是没有进行过任何标记操作，那reset个毛</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;   <span class="comment">//直接让position变成mark位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那比如我们在读取到1号位置时进行标记：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krtfdjjxj21qw082t96.jpg" alt="image-20220424135842228"></p>
<p>接着我们使用reset方法就可以直接回退回去了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kru5ys1aj21ru096dgg.jpg" alt="image-20220424135925501"></p>
<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    buffer.get();   <span class="comment">//读取一位，那么position就变成1了</span></span><br><span class="line">    buffer.mark();   <span class="comment">//这时标记，那么mark = 1</span></span><br><span class="line">    buffer.get();   <span class="comment">//又读取一位，那么position就变成2了</span></span><br><span class="line">    buffer.reset();    <span class="comment">//直接将position = mark，也就是变回1</span></span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，读取的位置根据我们的操作进行了变化，有关缓冲区的读操作，就暂时讲到这里。</p>
<h3 id="缓冲区其他操作"><a href="#缓冲区其他操作" class="headerlink" title="缓冲区其他操作"></a>缓冲区其他操作</h3><p>前面我们大致了解了一下缓冲区的读写操作，那么我们接着来看看，除了常规的读写操作之外，还有哪些其他的操作：</p>
<ul>
<li><code>public abstract IntBuffer compact()</code>   -   压缩缓冲区，由具体实现类实现</li>
<li><code>public IntBuffer duplicate()</code>   -   复制缓冲区，会直接创建一个新的数据相同的缓冲区</li>
<li><code>public abstract IntBuffer slice()</code>   -    划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作</li>
<li><code>public final Buffer rewind()</code>  -   重绕缓冲区，其实就是把position归零，然后mark变回-1</li>
<li><code>public final Buffer clear()</code>  -   将缓冲区清空，所有的变量变回最初的状态</li>
</ul>
<p>我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = position();   <span class="comment">//获取当前位置</span></span><br><span class="line">    <span class="keyword">int</span> lim = limit();    <span class="comment">//获取当前最大position位置</span></span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);   <span class="comment">//断言表达式，position必须小于最大位置，肯定的</span></span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);  <span class="comment">//计算pos距离最大位置的长度</span></span><br><span class="line">    System.arraycopy(hb, ix(pos), hb, ix(<span class="number">0</span>), rem);   <span class="comment">//直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间</span></span><br><span class="line">    position(rem);   <span class="comment">//直接将position移动到rem位置</span></span><br><span class="line">    limit(capacity());   <span class="comment">//pos最大位置修改为最大容量</span></span><br><span class="line">    discardMark();   <span class="comment">//mark变回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在的状态是：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krvhots6j21s0088aar.jpg" alt="image-20220424140040711"></p>
<p>那么我们在执行<code> compact()</code>方法之后，会进行截取，此时<code>limit - position = 6</code>，那么就会截取第<code>4、5、6、7、8、9</code>这6个数据然后丢到最前面，接着position跑到<code>7</code>表示这是下一个继续的位置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1krycqrmej21ri080wfb.jpg" alt="image-20220424140326373"></p>
<p>现在我们通过代码来检验一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();   <span class="comment">//先正常读4个</span></span><br><span class="line">    buffer.compact();   <span class="comment">//压缩缓冲区</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;压缩之后的情况：&quot;</span>+Arrays.toString(buffer.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+buffer.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+buffer.limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后的结果没有问题：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksetaccij21b603oq35.jpg" alt="image-20220424141916082"></p>
<p>我们接着来看第二个方法，那么如果我们现在需要复制一个内容一模一样的的缓冲区，该怎么做？直接使用<code>duplicate()</code>方法就可以复制了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;   <span class="comment">//直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(hb,</span><br><span class="line">                                    <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                    <span class="keyword">this</span>.position(),</span><br><span class="line">                                    <span class="keyword">this</span>.limit(),</span><br><span class="line">                                    <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                    offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么各位猜想一下，如果通过这种方式创了一个新的IntBuffer，那么下面的例子会出现什么结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer duplicate = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    System.out.println(buffer == duplicate);</span><br><span class="line">    System.out.println(buffer.array() == duplicate.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于buffer是重新new的，所以第一个为false，而底层的数组由于在构造的时候没有进行任何的拷贝而是直接传递，因此实际上两个缓冲区的底层数组是同一个对象。所以，一个发生修改，那么另一个就跟着变了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    IntBuffer duplicate = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="number">0</span>, <span class="number">66666</span>);</span><br><span class="line">    System.out.println(duplicate.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们接着来看下一个方法，<code>slice()</code>方法会将缓冲区进行划分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();   <span class="comment">//获取当前position</span></span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();     <span class="comment">//获取position最大位置</span></span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);   <span class="comment">//求得剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBuffer(hb,    <span class="comment">//返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个</span></span><br><span class="line">                                    -<span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>,</span><br><span class="line">                                    rem,    <span class="comment">//新的容量变成了剩余空间的大小</span></span><br><span class="line">                                    rem,</span><br><span class="line">                                    pos + offset);   <span class="comment">//可以看到offset的地址不再是0了，而是当前的position加上原有的offset值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然现在底层依然使用的是之前的数组，但是由于设定了offset值，我们之前的操作似乎变得不太一样了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksmjx76ij21ru07u75a.jpg" alt="image-20220424142642088"></p>
<p>回顾前面我们所讲解的内容，在读取和存放时，会被<code>ix</code>方法进行调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//现在offset为4，那么也就是说逻辑上的i是0但是得到真实位置却是4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];   <span class="comment">//最后会经过ix方法转换为真正在数组中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，在逻辑上我们可以认为是这样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksq30gzij21pw08gt9b.jpg" alt="image-20220424143002885"></p>
<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();</span><br><span class="line">    IntBuffer slice = buffer.slice();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的情况：&quot;</span>+Arrays.toString(slice.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的偏移地址：&quot;</span>+slice.arrayOffset());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+slice.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+slice.limit());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slice.hasRemaining()) &#123;   <span class="comment">//将所有的数据全部挨着打印出来</span></span><br><span class="line">        System.out.print(slice.get()+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终结果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ksqmk9smj21dw05q3yy.jpg" alt="image-20220424143036449"></p>
<p>最后两个方法就比较简单了，我们先来看<code>rewind()</code>，它相当于是对position和mark进行了一次重置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是<code>clear()</code>，它相当于是将整个缓冲区回归到最初的状态了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//同上</span></span><br><span class="line">    limit = capacity;   <span class="comment">//limit变回capacity</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，关于缓冲区的一些其他操作，我们就讲解到此。</p>
<h3 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h3><p>缓冲区之间是可以进行比较的，我们可以看到equals方法和compareTo方法都是被重写了的，我们首先来看看<code>equals</code>方法，注意，它是判断两个缓冲区剩余的内容是否一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == ob)   <span class="comment">//要是两个缓冲区是同一个对象，肯定一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> IntBuffer))  <span class="comment">//类型不是IntBuffer那也不用比了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    IntBuffer that = (IntBuffer)ob;   <span class="comment">//转换为IntBuffer</span></span><br><span class="line">    <span class="keyword">int</span> thisPos = <span class="keyword">this</span>.position();  <span class="comment">//获取当前缓冲区的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> thisLim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">int</span> thatPos = that.position();  <span class="comment">//获取另一个缓冲区的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> thatLim = that.limit();</span><br><span class="line">    <span class="keyword">int</span> thisRem = thisLim - thisPos; </span><br><span class="line">    <span class="keyword">int</span> thatRem = thatLim - thatPos;</span><br><span class="line">    <span class="keyword">if</span> (thisRem &lt; <span class="number">0</span> || thisRem != thatRem)   <span class="comment">//如果剩余容量小于0或是两个缓冲区的剩余容量不一样，也不行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">//注意比较的是剩余的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thisLim - <span class="number">1</span>, j = thatLim - <span class="number">1</span>; i &gt;= thisPos; i--, j--)  <span class="comment">//从最后一个开始倒着往回比剩余的区域</span></span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="keyword">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//只要发现不一样的就不用继续了，直接false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">//上面的比较都没问题，那么就true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们按照它的思路来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer1 = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    IntBuffer buffer2 = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//直接比较</span></span><br><span class="line">    </span><br><span class="line">    buffer1.position(<span class="number">6</span>);</span><br><span class="line">    buffer2.position(<span class="number">6</span>);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//比较从下标6开始的剩余内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果就是我们所想的那样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktaynv7nj21kw02gglg.jpg" alt="image-20220424145009464"></p>
<p>那么我们接着来看比较，<code>compareTo</code>方法，它实际上是<code>Comparable</code>接口提供的方法，它实际上比较的也是pos开始剩余的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(IntBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisPos = <span class="keyword">this</span>.position();    <span class="comment">//获取并计算两个缓冲区的pos和remain</span></span><br><span class="line">    <span class="keyword">int</span> thisRem = <span class="keyword">this</span>.limit() - thisPos;</span><br><span class="line">    <span class="keyword">int</span> thatPos = that.position();</span><br><span class="line">    <span class="keyword">int</span> thatRem = that.limit() - thatPos;</span><br><span class="line">    <span class="keyword">int</span> length = Math.min(thisRem, thatRem);   <span class="comment">//选取一个剩余空间最小的出来</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>)   <span class="comment">//如果最小的小于0，那就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = thisPos + Math.min(thisRem, thatRem);  <span class="comment">//计算n的值当前的pos加上剩余的最小空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = thisPos, j = thatPos; i &lt; n; i++, j++) &#123;  <span class="comment">//从两个缓冲区的当前位置开始，一直到n结束</span></span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));  <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;   <span class="comment">//只要出现不相同的，那么就返回比较出来的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thisRem - thatRem; <span class="comment">//如果没比出来个所以然，那么就比长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就不多做介绍了。</p>
<h3 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h3><p>接着我们来看看只读缓冲区，只读缓冲区就像其名称一样，它只能进行读操作，而不允许进行写操作。</p>
<p>那么我们怎么创建只读缓冲区呢？</p>
<ul>
<li><code>public abstract IntBuffer asReadOnlyBuffer();</code>   -   基于当前缓冲区生成一个只读的缓冲区。</li>
</ul>
<p>我们来看看此方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapIntBufferR(hb,    <span class="comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span></span><br><span class="line">                                 <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                 <span class="keyword">this</span>.position(),</span><br><span class="line">                                 <span class="keyword">this</span>.limit(),</span><br><span class="line">                                 <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                 offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBufferR类跟我们普通的HeapIntBuffer有什么不同之处呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktrvyy39j221e0f8ac2.jpg" alt="image-20220424150625847"></p>
<p>可以看到它是继承自HeapIntBuffer的，那么我们来看看它的实现有什么不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapIntBufferR</span><span class="params">(<span class="keyword">int</span>[] buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(buf, mark, pos, lim, cap, off);</span><br><span class="line">    <span class="keyword">this</span>.isReadOnly = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在其构造方法中，除了直接调用父类的构造方法外，还会将<code>isReadOnly</code>标记修改为true，我们接着来看put操作有什么不同之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(IntBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有的put方法全部凉凉，只要调用就会直接抛出ReadOnlyBufferException异常。但是其他get方法依然没有进行重写，也就是说get操作还是可以正常使用的，但是只要是写操作就都不行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntBuffer buffer = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    IntBuffer readBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    System.out.println(readBuffer.isReadOnly());</span><br><span class="line">    System.out.println(readBuffer.get());</span><br><span class="line">    readBuffer.put(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ktz4pkhtj21ue04oab1.jpg" alt="image-20220424151322831"></p>
<p>这就是只读状态下的缓冲区。</p>
<h3 id="ByteBuffer和CharBuffer"><a href="#ByteBuffer和CharBuffer" class="headerlink" title="ByteBuffer和CharBuffer"></a>ByteBuffer和CharBuffer</h3><p>通过前面的学习，我们基本上已经了解了缓冲区的使用，但是都是基于IntBuffer进行讲解，现在我们来看看另外两种基本类型的缓冲区ByteBuffer和CharBuffer，因为ByteBuffer底层存放的是很多单个byte字节，所以会有更多的玩法，同样CharBuffer是一系列字节，所以也有很多便捷操作。</p>
<p>我们先来看看ByteBuffer，我们可以直接点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// Valid only for heap buffers</span></span><br><span class="line">  	....</span><br></pre></td></tr></table></figure>

<p>可以看到如果也是使用堆缓冲区子类实现，那么依然是一个<code>byte[]</code>的形式保存数据。我们来尝试使用一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//除了直接丢byte进去之外，我们也可以丢其他的基本类型（注意容量消耗）</span></span><br><span class="line">    buffer.putInt(Integer.MAX_VALUE);  <span class="comment">//丢个int的最大值进去，注意一个int占4字节</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前缓冲区剩余字节数：&quot;</span>+buffer.remaining());  <span class="comment">//只剩6个字节了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们来尝试读取一下，记得先翻转</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println(buffer.get());   <span class="comment">//一共四个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kulzci1zj21cc05kaa3.jpg" alt="image-20220424153520843"></p>
<p>可以看到第一个byte为127、然后三个都是-1，我们来分析一下：</p>
<ul>
<li><code>127</code> 转换为二进制补码形式就是 <code>01111111</code>，而<code>-1</code>转换为二进制补码形式为<code>11111111</code></li>
</ul>
<p>那也就是说，第一个字节是01111111，而后续字节就是11111111，把它们拼接在一起：</p>
<ul>
<li>二进制补码表示<code>01111111 11111111 11111111 11111111</code> 转换为十进制就是<code>2147483647</code>，也就是int的最大值。</li>
</ul>
<p>那么根据我们上面的推导，各位能否计算得到下面的结果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    buffer.flip();   <span class="comment">//翻转一下</span></span><br><span class="line">    System.out.println(buffer.getInt());  <span class="comment">//以int形式获取，那么就是一次性获取4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的计算，得到的结果就是：</p>
<ul>
<li>上面的数据以二进制补码的形式表示为：<code>00000000 00000000 00000001 11111111</code></li>
<li>将其转换为十进制那么就是：256 + 255 = 511</li>
</ul>
<p>好吧，再来个魔鬼问题，把第一个换成1呢：<code>10000000 00000000 00000001 11111111</code>，自己算。</p>
<p>我们接着来看看CharBuffer，这种缓冲区实际上也是保存一大堆char类型的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CharBuffer buffer = CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);  <span class="comment">//除了可以直接丢char之外，字符串也可以一次性丢进入</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是正是得益于char数组，它包含了很多的字符串操作，可以一次性存放一整个字符串。我们甚至还可以将其当做一个String来进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CharBuffer buffer = CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    buffer.append(<span class="string">&quot;!&quot;</span>);   <span class="comment">//可以像StringBuilder一样使用append来继续添加数据</span></span><br><span class="line">  </span><br><span class="line">  	System.out.println(<span class="string">&quot;剩余容量：&quot;</span>+buffer.remaining());  <span class="comment">//已经用了6个字符了</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;整个字符串为：&quot;</span>+buffer);   <span class="comment">//直接将内容转换为字符串</span></span><br><span class="line">    System.out.println(<span class="string">&quot;第3个字符是：&quot;</span>+buffer.charAt(<span class="number">2</span>));  <span class="comment">//直接像String一样charAt</span></span><br><span class="line"></span><br><span class="line">    buffer   <span class="comment">//也可以转换为IntStream进行操作</span></span><br><span class="line">            .chars()</span><br><span class="line">            .filter(i -&gt; i &lt; <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            .forEach(i -&gt; System.out.print((<span class="keyword">char</span>) i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了一些常规操作之外，我们还可以直接将一个字符串作为参数创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以直接使用wrap包装一个字符串，但是注意，包装出来之后是只读的</span></span><br><span class="line">    CharBuffer buffer = CharBuffer.wrap(<span class="string">&quot;收藏等于学会~&quot;</span>);</span><br><span class="line">    System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="string">&quot;111&quot;</span>);  <span class="comment">//这里尝试进行一下写操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果也是我们预料中的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kvvus5tej219a06c0u1.jpg" alt="image-20220424161925938"></p>
<p>对于这两个比较特殊的缓冲区，我们就暂时讲解到这里。</p>
<h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p><strong>注意：</strong>推荐学习完成JVM篇再来学习这一部分。</p>
<p>最后我们来看一下直接缓冲区，我们前面一直使用的都是堆缓冲区，也就是说实际上数据是保存在一个数组中的，如果你已经完成了JVM篇的学习，一定知道实际上占用的是堆内存，而我们也可以创建一个直接缓冲区，也就是申请堆外内存进行数据保存，采用操作系统本地的IO，相比堆缓冲区会快一些。</p>
<p>那么怎么使用直接缓冲区呢？我们可以通过<code>allocateDirect</code>方法来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们申请一个直接缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">  	<span class="comment">//使用方式基本和之前是一样的</span></span><br><span class="line">    buffer.put((<span class="keyword">byte</span>) <span class="number">66</span>);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看这个<code>allocateDirect</code>方法是如何创建一个直接缓冲区的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法直接创建了一个新的DirectByteBuffer对象，那么这个类又是怎么进行创建的呢？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1kw7cc7vnj223y0f80v0.jpg" alt="image-20220424163028578"></p>
<p>可以看到它并不是直接继承自ByteBuffer，而是MappedByteBuffer，并且实现了接口DirectBuffer，我们先来看看这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">address</span><span class="params">()</span></span>;   <span class="comment">//获取内存地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">attachment</span><span class="params">()</span></span>;   <span class="comment">//附加对象，这是为了保证某些情况下内存不被释放，我们后面细谈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cleaner <span class="title">cleaner</span><span class="params">()</span></span>;   <span class="comment">//内存清理类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//这三个方法目前暂时用不到，后面文件再说</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLoaded</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看DirectByteBuffer类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把Unsafe类取出来</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Bits.unsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中直接创建的内存空间地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> arrayBaseOffset = (<span class="keyword">long</span>)unsafe.arrayBaseOffset(<span class="keyword">byte</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否具有非对齐访问能力，根据CPU架构而定，intel、AMD、AppleSilicon 都是支持的</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unaligned = Bits.unaligned();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接缓冲区的内存地址，为了提升速度就放到Buffer类中去了</span></span><br><span class="line"><span class="comment">//    protected long address;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加对象，一会有大作用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object att;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();   <span class="comment">//是否直接内存分页对齐，需要额外计算</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));   <span class="comment">//计算出最终需要申请的大小</span></span><br><span class="line">  	<span class="comment">//判断堆外内存是否足够，够的话就作为保留内存</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//通过Unsafe申请内存空间，并得到内存地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">      	<span class="comment">//申请失败就取消一开始的保留内存</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//批量将申请到的这一段内存每个字节都设定为0</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//将address变量（在Buffer中定义）设定为base的地址</span></span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//创建一个针对于此缓冲区的Cleaner，由于是堆外内存，所以现在由它来进行内存清理</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在构造方法中，是直接通过Unsafe类来申请足够的堆外内存保存数据，那么当我们不使用此缓冲区时，内存会被如何清理呢？我们来看看这个Cleaner：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt;</span>&#123; <span class="comment">//继承自鬼引用，也就是说此对象会存放一个没有任何引用的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用队列，PhantomReference构造方法需要</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//执行清理的具体流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">private</span> Cleaner first = <span class="keyword">null</span>;  <span class="comment">//Cleaner双向链表，每创建一个Cleaner对象都会添加一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cleaner</span><br><span class="line">        next = <span class="keyword">null</span>,</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Cleaner <span class="title">add</span><span class="params">(Cleaner cl)</span> </span>&#123;   <span class="comment">//添加操作会让新来的变成新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl.next = first;</span><br><span class="line">            first.prev = cl;</span><br><span class="line">        &#125;</span><br><span class="line">        first = cl;</span><br><span class="line">        <span class="keyword">return</span> cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//可以看到创建鬼引用的对象就是传进的缓冲区对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cleaner</span><span class="params">(Object referent, Runnable thunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, dummyQueue);</span><br><span class="line">      	<span class="comment">//清理流程实际上是外面的Deallocator</span></span><br><span class="line">        <span class="keyword">this</span>.thunk = thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//通过此方法创建一个新的Cleaner</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object ob, Runnable thunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thunk == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> add(<span class="keyword">new</span> Cleaner(ob, thunk));   <span class="comment">//调用add方法将Cleaner添加到队列</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//清理操作</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!remove(<span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">//进行清理操作时会从双向队列中移除当前Cleaner，false说明已经移除过了，直接return</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thunk.run();   <span class="comment">//这里就是直接执行具体清理流程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable x) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们先来看看具体的清理程序在做些什么，Deallocator是在直接缓冲区中声明的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;   <span class="comment">//内存地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;    <span class="comment">//大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">//申请的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">//具体的清理操作</span></span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);   <span class="comment">//这里是直接调用了Unsafe进行内存释放操作</span></span><br><span class="line">        address = <span class="number">0</span>;   <span class="comment">//内存地址改为0，NULL</span></span><br><span class="line">        Bits.unreserveMemory(size, capacity);   <span class="comment">//取消一开始的保留内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们可以明确在清理的时候实际上也是调用Unsafe类进行内存释放操作，那么，这个清理操作具体是在什么时候进行的呢？首先我们要明确，如果是普通的堆缓冲区，由于使用的数组，那么一旦此对象没有任何引用时，就随时都会被GC给回收掉，但是现在是堆外内存，只能我们手动进行内存回收，那么当DirectByteBuffer也失去引用时，会不会触发内存回收呢？</p>
<p>答案是可以的，还记得我们刚刚看到Cleaner是PhantomReference的子类吗，而DirectByteBuffer是被鬼引用的对象，而具体的清理操作是Cleaner类的clean方法，莫非这两者有什么联系吗？</p>
<p>你别说，还真有，我们直接看到PhantomReference的父类Reference，我们会发现这样一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 预加载并初始化 InterruptedException 和 Cleaner 类</span></span><br><span class="line">        		<span class="comment">// 以避免出现在循环运行过程中时由于内存不足而无法加载</span></span><br><span class="line">            ensureClassInitialized(InterruptedException.class);</span><br><span class="line">            ensureClassInitialized(Cleaner.class);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tryHandlePending(<span class="keyword">true</span>);   <span class="comment">//这里是一个无限循环调用tryHandlePending方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* 会被GC回收的对象，也就是我们给过来被引用的对象 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;  <span class="comment">//引用队列，可以和下面的next搭配使用，形成链表</span></span><br><span class="line"><span class="comment">//Reference对象也是一个一个连起来的节点，这样才能放到ReferenceQueue中形成链表</span></span><br><span class="line"><span class="keyword">volatile</span> Reference next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即将被GC的引用链表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* 由虚拟机操作 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pending与discovered一起构成了一个pending单向链表，标记为static类所有，pending为链表的头节点，discovered为链表当前</span></span><br><span class="line"><span class="comment">//Reference节点指向下一个节点的引用，这个队列是由JVM构建的，当对象除了被reference引用之外没有其它强引用了，JVM就会将指向</span></span><br><span class="line"><span class="comment">//需要回收的对象的Reference对象都放入到这个队列里面，这个队列会由下面的 Reference Hander 线程来处理。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;    <span class="comment">//Reference类的静态代码块</span></span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">&quot;Reference Handler&quot;</span>);   <span class="comment">//在一开始的时候就会创建</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);   <span class="comment">//以最高优先级启动</span></span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);    <span class="comment">//此线程直接作为一个守护线程</span></span><br><span class="line">    handler.start();    <span class="comment">//也就是说在一开始的时候这个守护线程就会启动</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么也就是说Reference Handler线程是在一开始就启动了，那么我们的关注点可以放在<code>tryHandlePending</code>方法上，看看这玩意到底在做个啥：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;   <span class="comment">//加锁办事</span></span><br><span class="line">          	<span class="comment">//当Cleaner引用的DirectByteBuffer对象即将被回收时，pending会变成此Cleaner对象</span></span><br><span class="line">          	<span class="comment">//这里判断到pending不为null时就需要处理一下对象销毁了</span></span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// &#x27;instanceof&#x27; 有时会导致内存溢出，所以将r从链表中移除之前就进行类型判断</span></span><br><span class="line">                <span class="comment">// 如果是Cleaner类型就给到c</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将pending更新为链表下一个待回收元素</span></span><br><span class="line">                pending = r.discovered;</span><br><span class="line">                r.discovered = <span class="keyword">null</span>;   <span class="comment">//r不再引用下一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//否则就进入等待</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素是Cleaner类型，c在上面就会被赋值，这里就会执行其clean方法（破案了）</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c.clean();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);  <span class="comment">//这个是引用队列，实际上就是我们之前在JVM篇中讲解的入队机制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对源码的解读，我们就了解了直接缓冲区的内存加载释放整个流程。和堆缓冲区一样，当直接缓冲区没有任何强引用时，就有机会被GC正常回收掉并自动释放申请的内存。</p>
<p>我们接着来看看直接缓冲区的读写操作是如何进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));   <span class="comment">//直接通过Unsafe类读取对应地址上的byte数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);   <span class="comment">//ix现在是内存地址再加上i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无论是读取还是写入操作都是通过Unsafe类操作对应的内存地址完成的。</p>
<p>那么它的复制操作是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>,</span><br><span class="line">                                          <span class="keyword">this</span>.markValue(),</span><br><span class="line">                                          <span class="keyword">this</span>.position(),</span><br><span class="line">                                          <span class="keyword">this</span>.limit(),</span><br><span class="line">                                          <span class="keyword">this</span>.capacity(),</span><br><span class="line">                                          <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(DirectBuffer db,         <span class="comment">// 这里给的db是进行复制操作的DirectByteBuffer对象</span></span><br><span class="line">                           <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span><br><span class="line">                           <span class="keyword">int</span> off) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    address = db.address() + off;   <span class="comment">//直接继续使用之前申请的内存空间</span></span><br><span class="line">    cleaner = <span class="keyword">null</span>;   <span class="comment">//因为用的是之前的内存空间，已经有对应的Cleaner了，这里不需要再搞一个</span></span><br><span class="line">    att = db;   <span class="comment">//将att设定为此对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果是进行复制操作，那么会直接会继续使用执行复制操作的DirectByteBuffer申请的内存空间。不知道各位是否能够马上联想到一个问题，我们知道，如果执行复制操作的DirectByteBuffer对象失去了强引用被回收，那么就会触发Cleaner并进行内存释放，但是有个问题就是，这段内存空间可能复制出来的DirectByteBuffer对象还需要继续使用，这时肯定是不能进行回收的，所以说这里使用了att变量将之前的DirectByteBuffer对象进行引用，以防止其失去强引用被垃圾回收，所以只要不是原来的DirectByteBuffer对象和复制出来的DirectByteBuffer对象都失去强引用时，就不会导致这段内存空间被回收。</p>
<p>这样，我们之前的未解之谜为啥有个<code>att</code>也就得到答案了，有关直接缓冲区的介绍，就到这里为止。</p>
<hr>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>前面我们学习了NIO的基石——缓冲区，那么缓冲区具体用在什么地方呢，在本板块我们学习通道之后，相信各位就能知道了。那么，什么是通道呢？</p>
<p>在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。</p>
<h3 id="通道接口层次"><a href="#通道接口层次" class="headerlink" title="通道接口层次"></a>通道接口层次</h3><p>通道的根基接口是<code>Channel</code>，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通道是否处于开启状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看它的一些子接口，首先是最基本的读写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将通道中的数据读取到给定的缓冲区中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//将给定缓冲区中的数据写入到通道中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了读写功能后，最后整合为了一个ByteChannel接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lphvijimj223g0lajug.jpg" alt="image-20220425092355354"></p>
<p>在ByteChannel之下，还有更多的派生接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许保留position和更改position的通道，以及对通道连接实体的相关操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeekableByteChannel</span> <span class="keyword">extends</span> <span class="title">ByteChannel</span> </span>&#123;</span><br><span class="line">   	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的position</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前的position</span></span><br><span class="line">    <span class="function">SeekableByteChannel <span class="title">position</span><span class="params">(<span class="keyword">long</span> newPosition)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此通道连接到的实体（比如文件）的当前大小</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此通道连接到的实体截断（比如文件，截断之后，文件后面一半就没了）为给定大小</span></span><br><span class="line">    <span class="function">SeekableByteChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看，除了读写之外，Channel还可以具有响应中断的能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterruptibleChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当其他线程调用此方法时，在此通道上处于阻塞状态的线程会直接抛出 AsynchronousCloseException 异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是InterruptibleChannel的抽象实现，完成了一部分功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title">Channel</span>, <span class="title">InterruptibleChannel</span> </span>&#123;</span><br><span class="line">		<span class="comment">//加锁关闭操作用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</span><br><span class="line">  	<span class="comment">//当前Channel的开启状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> open = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractInterruptibleChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭操作实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;   <span class="comment">//同时只能有一个线程进行此操作，加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!open)   <span class="comment">//如果已经关闭了，那么就不用继续了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            open = <span class="keyword">false</span>;   <span class="comment">//开启状态变成false</span></span><br><span class="line">            implCloseChannel();   <span class="comment">//开始关闭通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法由 close 方法调用，以执行关闭通道的具体操作，仅当通道尚未关闭时才调用此方法，不会多次调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始阻塞（有可能一直阻塞下去）操作之前，需要调用此方法进行标记，</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//阻塞操作结束之后，也需要需要调用此方法，为了防止异常情况导致此方法没有被调用，建议放在finally中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> completed)</span></span></span><br><span class="line"><span class="function">				...</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而之后的一些实现类，都是基于这些接口定义的方法去进行实现的，比如FileChannel：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1muofbqbmj22520pe0yu.jpg" alt="image-20220426090845530"></p>
<p>这样，我们就大致了解了一下通道相关的接口定义，那么我来看看具体是如何如何使用的。</p>
<p>比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  	<span class="comment">//数组创建好，一会用来存放从流中读取到的数据</span></span><br><span class="line">  	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">  	<span class="comment">//直接使用输入流</span></span><br><span class="line">    InputStream in = System.in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(data)) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//将输入流中的数据一次性读取到数组中</span></span><br><span class="line">            System.out.print(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> String(data, <span class="number">0</span>, len));  <span class="comment">//读取了多少打印多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在我们使用通道之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  	<span class="comment">//缓冲区创建好，一会就靠它来传输数据</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据</span></span><br><span class="line">    ReadableByteChannel readChannel = Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//将通道中的数据写到缓冲区中，缓冲区最多一次装10个</span></span><br><span class="line">        readChannel.read(buffer);</span><br><span class="line">        <span class="comment">//写入操作结束之后，需要进行翻转，以便接下来的读取操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">//最后转换成String打印出来康康</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        <span class="comment">//回到最开始的状态</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。</p>
<h3 id="文件传输FileChannel"><a href="#文件传输FileChannel" class="headerlink" title="文件传输FileChannel"></a>文件传输FileChannel</h3><p>前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        String data = <span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>;</span><br><span class="line">        out.write(data.getBytes());   <span class="comment">//向文件的输出流中写入数据，也就是把数据写到文件中</span></span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(bytes);    <span class="comment">//从文件的输入流中读取文件的信息</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = in.getChannel();</span><br><span class="line">    <span class="comment">//创建一个容量为128的缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过输入流获取的文件通道读取是没有任何问题的，但是写入操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = in.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mx9in88jj21l403mgmo.jpg" alt="image-20220426103818019"></p>
<p>直接报错，说明只支持读取操作，那么输出流呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = out.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到能够正常进行写入，但是读取呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    FileChannel channel = out.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mxbknxa4j21gg03ijsd.jpg" alt="image-20220426104016649"></p>
<p>可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RandomAccessFile能够支持文件的随机访问，并且实现了数据流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title">DataOutput</span>, <span class="title">DataInput</span>, <span class="title">Closeable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>我们可以通过RandomAccessFile来创建通道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来测试一下它的读写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  <span class="comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span></span><br><span class="line">        FileChannel channel = f.getChannel())&#123;   <span class="comment">//通过RandomAccessFile创建一个通道</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position());  <span class="comment">//注意读取也是从现在的位置开始</span></span><br><span class="line">        channel.position(<span class="number">0</span>);  <span class="comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。</p>
<p>除了基本的读写操作，我们也可以直接对文件进行截断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = f.getChannel())&#123;</span><br><span class="line">        <span class="comment">//截断文件，只留前20个字节</span></span><br><span class="line">        channel.truncate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到文件的内容直接被截断了，文件内容就只剩一半了。</p>
<p>当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        inChannel.transferTo(<span class="number">0</span>, inChannel.size(), out.getChannel());   <span class="comment">//直接将test文件通道中的数据转到test2文件的通道中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到执行后，文件的内容全部被复制到另一个文件了。</p>
<p>当然，反向操作也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        out.getChannel().transferFrom(inChannel, <span class="number">0</span>, inChannel.size());   <span class="comment">//直接将从test文件通道中传来的数据转给test2文件的通道</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意一定要是可写的，不然无法进行修改操作</span></span><br><span class="line"><span class="keyword">try</span>(RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过map方法映射文件的某一段内容，创建MappedByteBuffer对象</span></span><br><span class="line">    <span class="comment">//比如这里就是从第四个字节开始，映射10字节内容到内存中</span></span><br><span class="line">  	<span class="comment">//注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件</span></span><br><span class="line">    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容</span></span><br><span class="line">  	<span class="comment">//注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写</span></span><br><span class="line">  	<span class="comment">//注意我们只映射了10个字节，也就是写的内容不能超出10字节了</span></span><br><span class="line">    buffer.put(<span class="string">&quot;yyds&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编辑完成后，通过force方法将数据写回文件的映射区域</span></span><br><span class="line">    buffer.force();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。</p>
<h3 id="文件锁FileLock"><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h3><p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<p>那么我们来看看如何使用文件锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">//创建RandomAccessFile对象，并拿到Channel</span></span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line">  	<span class="comment">//接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里）</span></span><br><span class="line">  	<span class="comment">//加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁</span></span><br><span class="line">  	<span class="comment">//范围锁甚至可以提前加到一个还未写入的位置上</span></span><br><span class="line">    FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//操作完成之后使用release方法进行锁释放</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关共享锁和独占锁：</p>
<ul>
<li>进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。</li>
<li>进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。</li>
</ul>
<p>现在我们来启动两个进程试试看，我们需要在IDEA中配置一下两个启动项：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5uyrdjij21t40hsmzt.jpg" alt="image-20220426153541728"></p>
<p>现在我们依次启动它们：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5vwim5ej21hc06ct9x.jpg" alt="image-20220426153636218"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1n5w43wzxj21ii06igmw.jpg" alt="image-20220426153648363"></p>
<p>可以看到确实是两个进程同一时间只能有一个进行访问，而另一个需要等待锁释放。</p>
<p>那么如果我们申请的是文件的不同部分呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中一个进程锁 0 - 5</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//另一个进程锁 6 - 11</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">6</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，两个进程这时就可以同时进行加锁操作了，因为它们锁的是不同的段落。</p>
<p>那么要是交叉呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中一个进程锁 0 - 5</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//另一个进程锁 3 - 8</span></span><br><span class="line">FileLock lock = channel.lock(<span class="number">3</span>, <span class="number">6</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到交叉的情况下也是会出现阻塞的。</p>
<p>接着我们来看看共享锁，共享锁允许多个进程同时加锁，但是不能进行写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = f.getChannel();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line">        <span class="comment">//现在使用共享锁</span></span><br><span class="line">        FileLock lock = channel.lock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">  			<span class="comment">//进行写操作</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="keyword">new</span> Date().toString().getBytes()));</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">        <span class="comment">//操作完成之后使用release方法进行锁释放</span></span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行写操作时：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ni0yi6vcj21t008ugo8.jpg" alt="image-20220426223636761"></p>
<p>可以看到直接抛出异常，说另一个程序已锁定文件的一部分，进程无法访问（某些系统或是环境实测无效，比如UP主的arm架构MacOS就不生效，这个异常是在Windows环境下运行得到的）</p>
<p>当然，我们也可以测试一下多个进行同时加共享锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileLock lock = channel.lock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果是多个进程都能加共享锁：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niehdyqkj21eg03wgm2.jpg" alt="image-20220426224938834"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nier022vj21go03mwex.jpg" alt="image-20220426224954291"></p>
<p>当然，除了直接使用<code>lock()</code>方法进行加锁之外，我们也可以使用<code>tryLock()</code>方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel channel = f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FileLock lock = channel.tryLock(<span class="number">0</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(lock);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line"></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，两个进程都去尝试获取独占锁：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqbuoygj218w02mq39.jpg" alt="image-20220426230102206"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1niqlky3ij21ek04igma.jpg" alt="image-20220426230117926"></p>
<p>第一个成功加锁的进程获得了对应的锁对象，而第二个进程直接得到的是<code>null</code>。</p>
<p>到这里，有关文件锁的相关内容就差不多了。</p>
<hr>
<h2 id="多路复用网络通信"><a href="#多路复用网络通信" class="headerlink" title="多路复用网络通信"></a>多路复用网络通信</h2><p>前面我们已经介绍了NIO框架的两大核心：Buffer和Channel，我们接着来看看最后一个内容。</p>
<h3 id="传统阻塞I-O网络通信"><a href="#传统阻塞I-O网络通信" class="headerlink" title="传统阻塞I/O网络通信"></a>传统阻塞I/O网络通信</h3><p>说起网络通信，相信各位并不陌生，正是因为网络的存在我们才能走进现代化的社会，在JavaWeb阶段，我们学习了如何使用Socket建立TCP连接进行网络通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>))&#123;    <span class="comment">//将服务端创建在端口8080上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在等待客户端连接...&quot;</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));  <span class="comment">//通过</span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>);</span><br><span class="line">        System.out.println(reader.readLine());</span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());</span><br><span class="line">        writer.write(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        OutputStream stream = socket.getOutputStream();</span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(stream);  <span class="comment">//通过转换流来帮助我们快速写入内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        writer.write(text+<span class="string">&#x27;\n&#x27;</span>);   <span class="comment">//因为对方是readLine()这里加个换行符</span></span><br><span class="line">        writer.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已发送：&quot;</span>+text);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+reader.readLine());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接失败！&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端断开连接！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用前面讲解的通道来进行通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的ServerSocketChannel，一会直接使用SocketChannel进行网络IO操作</span></span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open())&#123;</span><br><span class="line">        <span class="comment">//依然是将其绑定到8080端口</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//同样是调用accept()方法，阻塞等待新的连接到来</span></span><br><span class="line">        SocketChannel socket = serverChannel.accept();</span><br><span class="line">        <span class="comment">//因为是通道，两端的信息都是可以明确的，这里获取远端地址，当然也可以获取本地地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用缓冲区进行数据接收</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socket.read(buffer);   <span class="comment">//SocketChannel同时实现了读写通道接口，所以可以直接进行双向操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">        socket.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得关</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然可以通过传统的Socket进行网络通信，但是我们发现，如果要进行IO操作，我们需要单独创建一个线程来进行处理，比如现在有很多个客户端，服务端需要同时进行处理，那么如果我们要处理这些客户端的请求，那么我们就只能单独为其创建一个线程来进行处理：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odmx2b3yj21o60dcwgh.jpg" alt="image-20220427165019293"></p>
<p>虽然这样看起来比较合理，但是随着客户端数量的增加，如果要保持持续通信，那么就不能摧毁这些线程，而是需要一直保留（但是实际上很多时候只是保持连接，一直在阻塞等待客户端的读写操作，IO操作的频率很低，这样就白白占用了一条线程，很多时候都是站着茅坑不拉屎），但是我们的线程不可能无限制的进行创建，总有一天会耗尽服务端的资源，那么现在怎么办呢，关键是现在又有很多客户端源源不断地连接并进行操作，这时，我们就可以利用NIO为我们提供的多路复用编程模型。</p>
<p>我们来看看NIO为我们提供的模型：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1odzw1dk3j21oi0e2goy.jpg" alt="image-20220427170247004"></p>
<p>服务端不再是一个单纯通过<code>accept()</code>方法来创建连接的机制了，而是根据客户端不同的状态，Selector会不断轮询，只有客户端在对应的状态时，比如真正开始读写操作时，才会创建线程或进行处理（这样就不会一直阻塞等待某个客户端的IO操作了），而不是创建之后需要一直保持连接，即使没有任何的读写操作。这样就不会因为占着茅坑不拉屎导致线程无限制地创建下去了。</p>
<p>通过这种方式，甚至单线程都能做到高效的复用，最典型的例子就是Redis了，因为内存的速度非常快，多线程上下文的开销就会显得有些拖后腿，还不如直接单线程简单高效，这也是为什么Redis单线程也能这么快的原因。</p>
<p>因此，我们就从NIO框架的第三个核心内容：Selector，开始讲起。</p>
<h3 id="选择器与I-O多路复用"><a href="#选择器与I-O多路复用" class="headerlink" title="选择器与I/O多路复用"></a>选择器与I/O多路复用</h3><p>前面我们大概了解了一下选择器，我们知道，选择器是当具体有某一个状态（比如读、写、请求）已经就绪时，才会进行处理，而不是让我们的程序主动地进行等待。</p>
<p>既然我们现在需要实现IO多路复用，那么我们来看看常见的IO多路复用模型，也就是Selector的实现方案，比如现在有很多个用户连接到我们的服务器：</p>
<ul>
<li><strong>select</strong>：当这些连接出现具体的某个状态时，只是知道已经就绪了，但是不知道详具体是哪一个连接已经就绪，每次调用都进行线性遍历所有连接，时间复杂度为<code>O(n)</code>，并且存在最大连接数限制。</li>
<li><strong>poll</strong>：同上，但是由于底层采用链表，所以没有最大连接数限制。</li>
<li><strong>epoll</strong>：采用事件通知方式，当某个连接就绪，能够直接进行精准通知（这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，只要就绪会会直接回调callback函数，实现精准通知，但是只有Linux支持这种方式），时间复杂度<code>O(1)</code>，Java在Linux环境下正是采用的这种模式进行实现的。</li>
</ul>
<p>好了，既然多路复用模型了解完毕了，那么我们就来看看如何让我们的网络通信实现多路复用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">         Selector selector = Selector.open())&#123;   <span class="comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将选择器注册到ServerSocketChannel中，后面是选择需要监听的时间，只有发生对应事件时才会进行选择，多个事件用 | 连接，注意，并不是所有的Channel都支持以下全部四个事件，可能只支持部分</span></span><br><span class="line">        <span class="comment">//因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_CONNECT --- 连接就绪事件，表示客户端与服务器的连接已经建立成功</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_ACCEPT --- 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_READ --- 读 就绪事件，表示通道中已经有了可读的数据，可以执行读操作了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_WRITE --- 写 就绪事件，表示已经可以向通道写数据了（这玩意比较特殊，一般情况下因为都是可以写入的，所以可能会无限循环）</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//无限循环等待新的用户网络操作</span></span><br><span class="line">            <span class="comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">//如果当前ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                    SocketChannel channel = serverChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</span></span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//这样就在连接建立时完成了注册</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;    <span class="comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    <span class="comment">//别关，说不定用户还要继续通信呢</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来编写一下客户客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9h1v29j213w06m74t.jpg" alt="image-20220504155104437"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wf9ms12cj217005uwet.jpg" alt="image-20220504155116276"></p>
<p>可以看到成功实现了，当然各位也可以跟自己的室友一起开客户端进行测试，现在，我们只用了一个线程，就能够同时处理多个请求，可见多路复用是多么重要。</p>
<h3 id="实现Reactor模式"><a href="#实现Reactor模式" class="headerlink" title="实现Reactor模式"></a>实现Reactor模式</h3><p>前面我们简单实现了多路复用网络通信，我们接着来了解一下Reactor模式，对我们的服务端进行优化。</p>
<p>现在我们来看看如何进行优化，我们首先抽象出两个组件，Reactor线程和Handler处理器：</p>
<ul>
<li>Reactor线程：负责响应IO事件，并分发到Handler处理器。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Handler处理器：执行非阻塞的操作。</li>
</ul>
<p>实际上我们之前编写的算是一种单线程Reactor的朴素模型（面向过程的写法），我们来看看标准的写法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1wgietqmhj21fq0c6tah.jpg" alt="image-20220504163417826"></p>
<p>客户端还是按照我们上面的方式连接到Reactor，并通过选择器走到Acceptor或是Handler，Acceptor主要负责客户端连接的建立，Handler负责读写操作，代码如下，首先是Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是Acceptor，实际上就是把上面的业务代码搬个位置罢了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acceptor主要用于处理连接操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(ServerSocketChannel serverChannel, Selector selector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel channel = serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//这里在注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler了</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> Handler(channel));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在注册时丢了一个附加对象进去，这个附加对象会在选择器选择到此通道上时，可以通过<code>attachment()</code>方法进行获取，对于我们简化代码有大作用，一会展示，我们接着来看看Reactor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册时，将Acceptor作为附加对象存放，当选择器选择后也可以获取到</span></span><br><span class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> Acceptor(serverChannel, selector));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.dispatch(iterator.next());   <span class="comment">//通过dispatch方法进行分发</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此方法进行分发</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        Object att = key.attachment();   <span class="comment">//获取attachment，ServerSocketChannel和对应的客户端Channel都添加了的</span></span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();   <span class="comment">//由于Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span></span><br><span class="line">        &#125;   <span class="comment">//这样就实现了对应的时候调用对应的Handler或是Acceptor了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用了记得关，保持好习惯，就像看完视频要三连一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverChannel.close();</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们编写一下主类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Reactor对象，启动，完事</span></span><br><span class="line">    <span class="keyword">try</span> (Reactor reactor = <span class="keyword">new</span> Reactor())&#123;</span><br><span class="line">        reactor.run();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了单线程Reactor模式，注意全程使用到的都只是一个线程，没有创建新的线程来处理任何事情。</p>
<p>但是单线程始终没办法应对大量的请求，如果请求量上去了，单线程还是很不够用，接着我们来看看多线程Reactor模式，它创建了多个线程处理，我们可以将数据读取完成之后的操作交给线程池来执行：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1whmt5w1sj21fq0cmac7.jpg" alt="image-20220504171307721"></p>
<p>其实我们只需要稍微修改一下Handler就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="comment">//把线程池给安排了，10个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            POOL.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在数据读出之后，就可以将数据处理交给线程池执行。</p>
<p>但是这样感觉还是划分的不够，一个Reactor需要同时处理来自客户端的所有操作请求，显得有些乏力，那么不妨我们将Reactor做成一主多从的模式，让主Reactor只负责Accept操作，而其他的Reactor进行各自的其他操作：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg" alt="image-20220505131410997"></p>
<p>现在我们来重新设计一下我们的代码，Reactor类就作为主节点，不进行任何修改，我们来修改一下其他的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubReactor作为从Reactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">		<span class="comment">//每个从Reactor也有一个Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService POOL = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubReactor[] reactors = <span class="keyword">new</span> SubReactor[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> selectedIndex = <span class="number">0</span>;  <span class="comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//在一开始的时候就让4个从Reactor跑起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reactors[i] = <span class="keyword">new</span> SubReactor();</span><br><span class="line">                POOL.submit(reactors[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//轮询获取下一个Selector（Acceptor用）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">nextSelector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Selector selector = reactors[selectedIndex].selector;</span><br><span class="line">        selectedIndex = (selectedIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        Object att = key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来修改一下Acceptor类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;   <span class="comment">//只需要一个ServerSocketChannel就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            SocketChannel channel = serverChannel.accept();   <span class="comment">//还是正常进行Accept操作，得到SocketChannel</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = SubReactor.nextSelector();   <span class="comment">//选取下一个从Reactor的Selector</span></span><br><span class="line">            selector.wakeup();    <span class="comment">//在注册之前唤醒一下防止卡死</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> Handler(channel));  <span class="comment">//注意现在注册的是从Reactor的Selector</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，SocketChannel相关的操作就由从Reactor进行处理了，而不是一律交给主Reactor进行操作。</p>
<p>至此，我们已经了解了NIO的三大组件：<em>Buffer、Channel、Selector</em>，有关NIO基础相关的内容，就讲解到这里。下一章我们将继续讲解基于NIO实现的高性能网络通信框架Netty。</p>
<h1 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h1><p>前面我们学习了Java为我们提供的NIO框架，提供使用NIO提供的三大组件，我们就可以编写更加高性能的客户端/服务端网络程序了，甚至还可以自行规定一种通信协议进行通信。</p>
<h2 id="NIO框架存在的问题"><a href="#NIO框架存在的问题" class="headerlink" title="NIO框架存在的问题"></a>NIO框架存在的问题</h2><p>但是之前我们在使用NIO框架的时候，还是发现了一些问题，我们先来盘点一下。</p>
<h3 id="客户端关闭导致服务端空轮询"><a href="#客户端关闭导致服务端空轮询" class="headerlink" title="客户端关闭导致服务端空轮询"></a>客户端关闭导致服务端空轮询</h3><p>可能在之前的实验中，你发现了这样一个问题：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z0omdbn1j21q60isq70.jpg" alt="image-20220506214320210"></p>
<p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的（上面的图中在空轮询两次后抛出异常了，也有可能是无限的循环下去）所以这里我们得稍微处理一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span></span><br><span class="line">    <span class="keyword">if</span>(channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">        channel.close();   <span class="comment">//直接关闭此通道</span></span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">//继续进行选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以在客户端主动断开时关闭连接了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z1qtxd9nj21cy078jrw.jpg" alt="image-20220506222006550"></p>
<p>当然，除了这种情况可能会导致空轮询之外，实际上还有一种可能，这种情况是NIO框架本身的BUG：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = selector.select();  <span class="comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br></pre></td></tr></table></figure>

<p>详细请看JDK官方BUG反馈：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302">JDK-6670302 : (se) NIO selector wakes up with 0 selected keys infinitely</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933">JDK-6403933 : (se) Selector doesn’t block on Selector.select(timeout) (lnx)</a></li>
</ol>
<p>本质原因也是因为客户端的主动断开导致：</p>
<blockquote>
<p>This is an issue with poll (and epoll) on Linux. If a file descriptor for a connected socket is polled with a request event mask of 0, and if the connection is abruptly terminated (RST) then the poll wakes up with the POLLHUP (and maybe POLLERR) bit set in the returned event set. The implication of this behaviour is that Selector will wakeup and as the interest set for the SocketChannel is 0 it means there aren’t any selected events and the select method returns 0.</p>
</blockquote>
<p>这个问题本质是与操作系统有关的，所以JDK一直都认为是操作系统的问题，不应该由自己来处理，所以这个问题在当时的好几个JDK版本都是存在的，这是一个很严重的空转问题，无限制地进行空转操作会导致CPU资源被疯狂消耗。</p>
<p>不过，这个问题，却被Netty框架巧妙解决了，我们后面再说。</p>
<h3 id="粘包-拆包问题"><a href="#粘包-拆包问题" class="headerlink" title="粘包/拆包问题"></a>粘包/拆包问题</h3><p>除了上面的问题之外，我们接着来看下一个问题。</p>
<p>我们在<code>计算机网络</code>这门课程中学习过，操作系统通过TCP协议发送数据的时候，也会先将数据存放在缓冲区中，而至于什么时候真正地发出这些数据，是由TCP协议来决定的，这是我们无法控制的事情。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2lccfu5j21ii0c60tu.jpg" alt="image-20220506224926169"></p>
<p>也就是说，比如现在我们要发送两个数据包（P1/P2），理想情况下，这两个包应该是依次到达服务端，并由服务端正确读取两次数据出来，但是由于上面的机制，可能会出现下面的情况：</p>
<ol>
<li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li>
<li>可能P1和P2的前半部分合在一起发送给了服务端（拆包现象）</li>
<li>可能P1的前半部分就被单独作为一个部分发给了服务端，后面的和P2一起发给服务端（也是拆包现象）</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z2em84c6j21cm0da3z4.jpg" alt="image-20220506224258538"></p>
<p>当然，对于这种问题，也有一些比较常见的解决方案：</p>
<ol>
<li>消息定长，发送方和接收方规定固定大小的消息长度，例如每个数据包大小固定为200字节，如果不够，空位补空格，只有接收了200个字节之后，作为一个完整的数据包进行处理。</li>
<li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>\r\n</code>，这样就一定需要读取到这样的分隔符才能将前面所有的数据作为一个完整的数据包进行处理。</li>
<li>将消息分为头部和本体，在头部中保存有当前整个数据包的长度，只有在读到足够长度之后才算是读到了一个完整的数据包。</li>
</ol>
<p>这里我们就来演示一下第一种解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">         Selector selector = Selector.open())&#123;</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个数据包要求必须塞满30个字节</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">if</span>(buffer.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    channel.write(ByteBuffer.wrap((<span class="string">&quot;已收到 &quot;</span>+size+<span class="string">&quot; 字节的数据！&quot;</span>).getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">               	...</span><br></pre></td></tr></table></figure>

<p>现在，当我们的客户端发送消息时，如果没有达到30个字节，那么会暂时存储起来，等有30个之后再一次性得到，当然如果数据量超过了30，那么最多也只会读取30个字节，其他的放在下一批：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmuamek3j21ou0hmdiq.jpg" alt="image-20220507102955570"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zmugj9ztj21l005qt9d.jpg" alt="image-20220507103009255"></p>
<p>这样就可以在一定程度上解决粘包/拆包问题了。</p>
<hr>
<h2 id="走进Netty框架"><a href="#走进Netty框架" class="headerlink" title="走进Netty框架"></a>走进Netty框架</h2><p>前面我们盘点了一下NIO存在的一些问题，而在Netty框架中，这些问题都被巧妙的解决了。</p>
<p>Netty是由JBOSS提供的一个开源的java网络编程框架，主要是对java的nio包进行了再次封装。Netty比java原生的nio包提供了更加强大、稳定的功能和易于使用的api。 netty的作者是Trustin Lee，这是一个韩国人，他还开发了另外一个著名的网络编程框架，mina。二者在很多方面都十分相似，它们的线程模型也是基本一致 。不过netty社区的活跃程度要mina高得多。</p>
<p>Netty实际上应用场景非常多，比如我们的Minecraft游戏服务器：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1znqwr5lqj21wa0pak1k.jpg" alt="image-20220507110120090"></p>
<p>Java版本的Minecraft服务器就是使用Netty框架作为网络通信的基础，正是得益于Netty框架的高性能，我们才能愉快地和其他的小伙伴一起在服务器里面炸服。</p>
<p>学习了Netty框架后，说不定你也可以摸索到部分Minecraft插件/模组开发的底层细节（太折磨了，UP主高中搞了大半年这玩意）</p>
<p>当然除了游戏服务器之外，我们微服务之间的远程调用也可以使用Netty来完成，比如Dubbo的RPC框架，包括最新的SpringWebFlux框架，也抛弃了内嵌Tomcat而使用Netty作为通信框架。既然Netty这么强大，那么现在我们就开始Netty的学习吧！</p>
<p>导包先：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.76.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h3><p>Netty并没有使用NIO中提供的ByteBuffer来进行数据装载，而是自行定义了一个ByteBuf类。</p>
<p>那么这个类相比NIO中的ByteBuffer有什么不同之处呢？</p>
<ul>
<li>写操作完成后无需进行<code>flip()</code>翻转。</li>
<li>具有比ByteBuffer更快的响应速度。</li>
<li>动态扩容。</li>
</ul>
<p>首先我们来看看它的内部结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title">ByteBuf</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> readerIndex;   <span class="comment">//index被分为了读和写，是两个指针在同时工作</span></span><br><span class="line">    <span class="keyword">int</span> writerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;    <span class="comment">//mark操作也分两种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;    <span class="comment">//最大容量，没错，这玩意能动态扩容</span></span><br></pre></td></tr></table></figure>

<p>可以看到，读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writerIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBuffer那样还需要进行翻转了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zwgc0v5ej21fe08m3z1.jpg" alt="image-20220507160235552"></p>
<p>其中<code>readerIndex</code>和<code>writerIndex</code>之间的部分就是是可读的内容，而<code>writerIndex</code>之后到<code>capacity</code>都是可写的部分。</p>
<p>我们来实际使用一下看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个初始容量为10的ByteBuf缓冲区，这里的Unpooled是用于快速生成ByteBuf的工具类</span></span><br><span class="line">    <span class="comment">//至于为啥叫Unpooled是池化的意思，ByteBuf有池化和非池化两种，区别在于对内存的复用，我们之后再讨论</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.writeInt(-<span class="number">888888888</span>);   <span class="comment">//写入一个Int数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入Int后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.readShort();   <span class="comment">//无需翻转，直接读取一个short数据出来</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取Short后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.discardReadBytes();   <span class="comment">//丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span></span><br><span class="line">    System.out.println(<span class="string">&quot;丢弃之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.clear();    <span class="comment">//清空操作，清空之后读写指针都归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;清空之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结合断点调试，我们可以观察读写指针的移动情况，更加清楚的认识一下ByteBuf的底层操作。</p>
<p>我们再来看看划分操作是不是和之前一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//我们也可以将一个byte[]直接包装进缓冲区（和NIO是一样的）不过写指针的值一开始就跑到最后去了，但是这玩意是不是只读的</span></span><br><span class="line">    ByteBuf buf = Unpooled.wrappedBuffer(<span class="string">&quot;abcdefg&quot;</span>.getBytes());</span><br><span class="line">  	<span class="comment">//除了包装，也可以复制数据，copiedBuffer()会完完整整将数据拷贝到一个新的缓冲区中</span></span><br><span class="line">    buf.readByte();   <span class="comment">//读取一个字节</span></span><br><span class="line">    ByteBuf slice = buf.slice();   <span class="comment">//现在读指针位于1，然后进行划分</span></span><br><span class="line"></span><br><span class="line">    System.out.println(slice.arrayOffset());   <span class="comment">//得到划分出来的ByteBuf的偏移地址</span></span><br><span class="line">    System.out.println(Arrays.toString(slice.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，划分也是根据当前读取的位置来进行的。</p>
<p>我们继续来看看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>);    <span class="comment">//容量只有10字节</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">  	<span class="comment">//直接写一个字符串</span></span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);   <span class="comment">//很明显这么多字已经超过10字节了</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们发现，在写入一个超出当前容量的数据时，会进行动态扩容，扩容会从64开始，之后每次触发扩容都会x2，当然如果我们不希望它扩容，可以指定最大容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在生成时指定maxCapacity也为10</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到现在无法再动态扩容了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxvmzz7hj224806sq64.jpg" alt="image-20220507165153381"></p>
<p>我们接着来看一下缓冲区的三种实现模式：堆缓冲区模式、直接缓冲区模式、复合缓冲区模式。</p>
<p>堆缓冲区（数组实现）和直接缓冲区（堆外内存实现）不用多说，前面我们在NIO中已经了解过了，我们要创建一个直接缓冲区也很简单，直接调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.directBuffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的不能直接拿到数组，因为底层压根不是数组实现的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zxbvl2y3j21h803st9z.jpg" alt="image-20220507163253662"></p>
<p>我们来看看复合模式，复合模式可以任意地拼凑组合其他缓冲区，比如我们可以：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zygujz9sj21no0c0abg.jpg" alt="image-20220507171216323"></p>
<p>这样，如果我们想要对两个缓冲区组合的内容进行操作，我们就不用再单独创建一个新的缓冲区了，而是直接将其进行拼接操作，相当于是作为多个缓冲区组合的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个复合缓冲区</span></span><br><span class="line">CompositeByteBuf buf = Unpooled.compositeBuffer();</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println((<span class="keyword">char</span>) buf.getByte(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们也可以正常操作组合后的缓冲区。</p>
<p>最后我们来看看，池化缓冲区和非池化缓冲区的区别。</p>
<p>我们研究一下Unpooled工具类中具体是如何创建buffer的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unpooled</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;  <span class="comment">//实际上内部是有一个ByteBufAllocator对象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer();   <span class="comment">//缓冲区的创建操作实际上是依靠ByteBufAllocator来进行的</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span></span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;</span><br><span class="line">        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">        EMPTY_BUFFER = ALLOC.buffer(<span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//空缓冲区容量和最大容量都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> EMPTY_BUFFER <span class="keyword">instanceof</span> EmptyByteBuf : <span class="string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们来看看，这个ByteBufAllocator又是个啥，顾名思义，其实就是负责分配缓冲区的。</p>
<p>它有两个具体实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>，一个是非池化缓冲区生成器，还有一个是池化缓冲区生成器，那么池化和非池化有啥区别呢？</p>
<p>实际上池化缓冲区利用了池化思想，将缓冲区通过设置内存池来进行内存块复用，这样就不用频繁地进行内存的申请，尤其是在使用堆外内存的时候，避免多次重复通过底层<code>malloc()</code>函数系统调用申请内存造成的性能损失。Netty的内存管理机制主要是借鉴Jemalloc内存分配策略，感兴趣的小伙伴可以深入了解一下。</p>
<p>所以，由于是复用内存空间，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">    ByteBuf buf = allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//申请一个容量为10的直接缓冲区</span></span><br><span class="line">    buf.writeChar(<span class="string">&#x27;T&#x27;</span>);    <span class="comment">//随便操作操作</span></span><br><span class="line">    System.out.println(buf.readChar());</span><br><span class="line">    buf.release();    <span class="comment">//释放此缓冲区</span></span><br><span class="line"></span><br><span class="line">    ByteBuf buf2 = allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//重新再申请一个同样大小的直接缓冲区</span></span><br><span class="line">    System.out.println(buf2 == buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在我们使用完一个缓冲区之后，我们将其进行资源释放，当我们再次申请一个同样大小的缓冲区时，会直接得到之前已经申请好的缓冲区，所以，PooledByteBufAllocator实际上是将ByteBuf实例放入池中在进行复用。</p>
<h3 id="零拷贝简介"><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h3><p><strong>注意：</strong>此小节作为选学内容，需要掌握<code>操作系统</code>和<code>计算机组成原理</code>才能学习。</p>
<p>零拷贝是一种I/O操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，首先第一个问题，什么是内核空间，什么又是用户空间呢？</p>
<p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25i6lqr4hj21l80gct9n.jpg" alt="image-20220512122211805"></p>
<p>比如我们Java中创建一个新的线程，实际上最终是要交给操作系统来为我们进行分配的，而需要操作系统帮助我们完成任务则需要进行系统调用，是内核在进行处理，不是我们自己的程序在处理，这时就相当于我们的程序处于了内核态，而当操作系统底层分配完成，最后到我们Java代码中返回得到线程对象时，又继续由我们的程序进行操作，所以从内核态转换回了用户态。</p>
<p>而我们的文件操作也是这样，我们实际上也是需要让操作系统帮助我们从磁盘上读取文件数据或是向网络发送数据，比如使用传统IO的情况下，我们要从磁盘上读取文件然后发送到网络上，就会经历以下流程：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25ify7168j21s60i4n0f.jpg" alt="image-20220512123113806"></p>
<p>可以看到整个过程中是经历了2次CPU拷贝+2次DMA拷贝，一共四次拷贝，虽然逻辑比较清晰，但是数据老是这样来回进行复制，是不是太浪费时间了点？所以我们就需要寻找一种更好的方式，来实现零拷贝。</p>
<p>实现零拷贝我们这里演示三种方案：</p>
<ol>
<li><p>使用虚拟内存</p>
<p>现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iui62e8j21na0i477f.jpg" alt="image-20220512124512936"></p>
</li>
<li><p>使用mmap/write内存映射</p>
<p>实际上这种方式就是将内核空间中的缓存直接映射到用户空间缓存，比如我们之前在学习NIO中使用的MappedByteBuffer，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25iwxop2wj21ky0i0ad1.jpg" alt="image-20220512124732995"></p>
<p>不过这样还是会出现用户态和内核态的切换，我们得再优化优化。</p>
</li>
<li><p>使用sendfile方式</p>
<p>在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝拷贝到Socket上，直接在内核空间中一步到位：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25izbhxnrj21f60hwtb0.jpg" alt="image-20220512124950007"></p>
<p>比如我们之前在NIO中使用的<code>transferTo()</code>方法，就是利用了这种机制来实现零拷贝的。</p>
</li>
</ol>
<h3 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h3><p>前面我们了解了Netty为我们提供的更高级的缓冲区类，我们接着来看看Netty是如何工作的，上一章我们介绍了Reactor模式，而Netty正是以主从Reactor多线程模型为基础，构建出了一套高效的工作模型。</p>
<p>大致工作模型图如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h22hrmmll1j21hg0c040d.jpg" alt="image-20220509215109408"></p>
<p>可以看到，和我们之前介绍的主从Reactor多线程模型非常类似：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xgciyet7j21f40cijtp.jpg" alt="image-20220505131410997"></p>
<p>所有的客户端需要连接到主Reactor完成Accept操作后，其他的操作由从Reactor去完成，这里也是差不多的思想，但是它进行了一些改进，我们来看一下它的设计：</p>
<ul>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接受客户端的连接, WorkerGroup专门负读写，就像我们前面说的主从Reactor一样。</li>
<li>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环机制，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听的，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop了而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorkerGroup的具体实现。</li>
<li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听。</li>
</ul>
<p>前面我们大致了解了一下Netty的工作模型，接着我们来尝试创建一个Netty服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">//当然还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层Epoll单独编写的一套本地实现，没有使用NIO那套</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务端启动引导类</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">//可链式，就很棒</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//获取流水线，当我们需要处理客户端的数据时，实际上是像流水线一样在处理，这个流水线上可以有很多Handler</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//添加一个Handler，这里使用ChannelInboundHandlerAdapter</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  <span class="comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span></span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//最后绑定端口，启动</span></span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面写了很多东西，但是你一定会懵逼，这些新来的东西，都是什么跟什么啊，怎么一个也没看明白？没关系，我们可以暂时先将代码写在这里，具体的各个部分，还请听后面细细道来。</p>
<p>我们接着编写一个客户端，客户端可以直接使用我们之前的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过通道正常收发数据即可，这样我们就成功搭建好了一个Netty服务器。</p>
<h3 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h3><p>在学习NIO时，我们就已经接触到Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输。</p>
<p>而在Netty中，也有对应的Channel类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">ChannelOutboundInvoker</span>, <span class="title">Comparable</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">ChannelId <span class="title">id</span><span class="params">()</span></span>;   <span class="comment">//通道ID</span></span><br><span class="line">    <span class="function">EventLoop <span class="title">eventLoop</span><span class="params">()</span></span>;   <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    <span class="function">Channel <span class="title">parent</span><span class="params">()</span></span>;   <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    <span class="function">ChannelConfig <span class="title">config</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;   <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRegistered</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelMetadata <span class="title">metadata</span><span class="params">()</span></span>;   <span class="comment">//通道相关信息</span></span><br><span class="line">    <span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">SocketAddress <span class="title">remoteAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">closeFuture</span><span class="params">()</span></span>;  <span class="comment">//关闭通道，但是会用到ChannelFuture，后面说</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeUnwritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">bytesBeforeWritable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Unsafe <span class="title">unsafe</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;   <span class="comment">//流水线，之后也会说</span></span><br><span class="line">    <span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;   <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    <span class="function">Channel <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Channel <span class="title">flush</span><span class="params">()</span></span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Netty中的Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p>
<ul>
<li>所有的IO操作都是异步的，并不是在当前线程同步运行，方法调用之后就直接返回了，那怎么获取操作的结果呢？还记得我们在前面JUC篇教程中学习的Future吗，没错，这里的ChannelFuture也是干这事的。</li>
</ul>
<p>我们可以来看一下Channel接口的父接口ChannelOutboundInvoker接口，这里面定义了大量的I/O操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundInvoker</span> </span>&#123;   <span class="comment">//通道出站调用（包含大量的网络出站操作，比如写）</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress var1)</span></span>;  <span class="comment">//Socket绑定、连接、断开、关闭等操作</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, SocketAddress var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span></span>;    <span class="comment">//下面这一系列还有附带ChannelPromise的，ChannelPromise我们后面再说，其实就是ChannelFuture的增强版</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress var1, SocketAddress var2, ChannelPromise var3)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">close</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">deregister</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object var1)</span></span>;    <span class="comment">//可以看到这些常见的写操作，都是返回的ChannelFuture，而不是直接给结果</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">write</span><span class="params">(Object var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object var1, ChannelPromise var2)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">ChannelPromise <span class="title">newPromise</span><span class="params">()</span></span>;   <span class="comment">//其他的暂时不提</span></span><br><span class="line">    <span class="function">ChannelProgressivePromise <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newSucceededFuture</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">newFailedFuture</span><span class="params">(Throwable var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelPromise <span class="title">voidPromise</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然它还实现了AttributeMap接口，其实有点类似于Session那种感觉，我们可以添加一些属性之类的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeMap</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">Attribute&lt;T&gt; <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们了解了Netty底层的Channel之后，我们接着来看ChannelHandler，既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前Reactor模式中的Handler，全靠它来处理读写操作。</p>
<p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，我们之后会介绍ChannelPipeline。</p>
<p>比如我们上面就是使用了ChannelInboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;  </span><br><span class="line">      	<span class="comment">//ctx是上下文，msg是收到的消息，以ByteBuf形式</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们先从顶层接口开始看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当ChannelHandler被添加到流水线中时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当ChannelHandler从流水线中移除时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> 已过时那咱就不管了 */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Sharable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶层接口的定义比较简单，就只有一些流水线相关的回调方法，我们接着来看下一级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandler用于处理入站相关事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//当Channel已经注册到自己的EventLoop上时调用，前面我们说了，一个Channel只会注册到一个EventLoop上，注册到EventLoop后，这样才会在发生对应事件时被通知。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//从EventLoop上取消注册时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当Channel已经处于活跃状态时被调用，此时Channel已经连接/绑定，并且已经就绪</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//跟上面相反，不再活跃了，并且不在连接它的远程节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当从Channel读取数据时被调用，可以看到数据被自动包装成了一个Object（默认是ByteBuf）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//上一个读取操作完成后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//暂时不介绍</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//当Channel的可写状态发生改变时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">		<span class="comment">//出现异常时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们上面用到的ChannelInboundHandlerAdapter实际上就是对这些方法实现的抽象类，相比直接用接口，我们可以只重写我们需要的方法，没有重写的方法会默认向流水线下一个ChannelHandler发送。</p>
<p>我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">        ByteBuf back = ctx.alloc().buffer();</span><br><span class="line">        back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(back);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userEventTriggered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelWritabilityChanged&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">      			<span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//将我们自定义的ChannelHandler添加到流水线</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> TestChannelHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器，让客户端来连接并发送一下数据试试看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231vpff1tj21j60900tp.jpg" alt="image-20220510092703319"></p>
<p>可以看到ChannelInboundHandler的整个生命周期，首先是Channel注册成功，然后才会变成可用状态，接着就差不多可以等待客户端来数据了，当客户端主动断开连接时，会再次触发一次<code>channelReadComplete</code>，然后不可用，最后取消注册。</p>
<p>我们来测试一下出现异常的情况呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">    ByteBuf back = ctx.alloc().buffer();</span><br><span class="line">    back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    ctx.writeAndFlush(back);</span><br><span class="line">    System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是自定义异常1&quot;</span>);  <span class="comment">//弄点异常上去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是自定义异常2&quot;</span>);   <span class="comment">//弄点异常上去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到发生异常时，会接着调用<code>exceptionCaught</code>方法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2329bmho8j21g407y75e.jpg" alt="image-20220510094007913"></p>
<p>与ChannelInboundHandler对应的还有ChannelOutboundHandler用于处理出站相关的操作，这里就不进行演示了。</p>
<p>我们接着来看看ChannelPipeline，每一个Channel都对应一个ChannelPipeline（在Channel初始化时就被创建了）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hpuq1sej219i08wgms.jpg" alt="image-20220511152035030"></p>
<p>它就像是一条流水线一样，整条流水线上可能会有很多个Handler（包括入站和出站），整条流水线上的两端还有两个默认的处理器（用于一些预置操作和后续操作，比如释放资源等），我们只需要关心如何安排这些自定义的Handler即可，比如我们现在希望创建两个入站ChannelHandler，一个用于接收请求并处理，还有一个用于处理当前接收请求过程中出现的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler，注意顺序</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//第一个用于处理消息接收</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;我是异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   <span class="comment">//第二个用于处理异常</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;我是异常处理：&quot;</span>+cause);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么它是如何运作的呢？实际上如果我们不在ChannelInboundHandlerAdapter中重写对应的方法，它会默认传播到流水线的下一个ChannelInboundHandlerAdapter进行处理，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);   <span class="comment">//通过ChannelHandlerContext来向下传递，ChannelHandlerContext是在Handler添加进Pipeline中时就被自动创建的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要将一个消息在两个Handler中进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);   <span class="comment">//通过ChannelHandlerContext</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看出站相关操作，我们可以使用ChannelOutboundHandlerAdapter来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;   </span><br><span class="line">              <span class="comment">//注意出栈站操作应该在入站操作的前面，当我们使用ChannelHandlerContext的write方法时，是从流水线的当前位置倒着往前找下一个ChannelOutboundHandlerAdapter，而我们之前使用的ChannelInboundHandlerAdapter是从前往后找下一个，如果我们使用的是Channel的write方法，那么会从整个流水线的最后开始倒着往前找ChannelOutboundHandlerAdapter，一定要注意顺序。</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;  <span class="comment">//当执行write操作时，会</span></span><br><span class="line">                    System.out.println(msg);   <span class="comment">//write的是啥，这里就是是啥</span></span><br><span class="line">                  	<span class="comment">//我们将其转换为ByteBuf，这样才能发送回客户端</span></span><br><span class="line">                    ctx.writeAndFlush(Unpooled.wrappedBuffer(msg.toString().getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.writeAndFlush(<span class="string">&quot;不会吧不会吧，不会还有人都看到这里了还没三连吧&quot;</span>);   <span class="comment">//这里可以write任何对象</span></span><br><span class="line">                  	<span class="comment">//ctx.channel().writeAndFlush(&quot;啊对对对&quot;); 或是通过Channel进行write也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来试试看，搞两个出站的Handler，验证一下是不是上面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.channel().writeAndFlush(<span class="string">&quot;伞兵一号卢本伟&quot;</span>);  <span class="comment">//这里我们使用channel的write</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1号出站：&quot;</span>+msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2号出站：&quot;</span>+msg);</span><br><span class="line">                    ctx.write(msg);  <span class="comment">//继续write给其他的出站Handler，不然到这里就断了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，出站操作在流水线上是反着来的，整个流水线操作大概流程如下:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2381nnw6kj21ey0bitam.jpg" alt="image-20220510130021714"></p>
<p>有关Channel及其处理相关操作，就先讲到这里。</p>
<h3 id="EventLoop和任务调度"><a href="#EventLoop和任务调度" class="headerlink" title="EventLoop和任务调度"></a>EventLoop和任务调度</h3><p>前面我们讲解了Channel，那么在EventLoop中具体是如何进行调度的呢？实际上我们之前在编写NIO的时候，就是一个while循环在源源不断地等待新的事件，而EventLoop也正是这种思想，它本质就是一个事件等待/处理线程。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2390nmv60j21es0awta1.jpg" alt="image-20220510133359757"></p>
<p>我们上面使用的就是EventLoopGroup，包含很多个EventLoop，我们每创建一个连接，就需要绑定到一个EventLoop上，之后EventLoop就会开始监听这个连接（只要连接不关闭，一直都是这个EventLoop负责此Channel），而一个EventLoop可以同时监听很多个Channel，实际上就是我们之前学习的Selector罢了。</p>
<p>当然，EventLoop并不只是用于网络操作的，我们前面所说的EventLoop其实都是NioEventLoop，它是专用于网络通信的，除了网络通信之外，我们也可以使用普通的EventLoop来处理一些其他的事件。</p>
<p>比如我们现在编写的服务端，虽然结构上和主从Reactor多线程模型差不多，但是我们发现，Handler似乎是和读写操作在一起进行的，而我们之前所说的模型中，Handler是在读写之外的单独线程中进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    Thread.sleep(<span class="number">10000</span>);   <span class="comment">//这里我们直接卡10秒假装在处理任务</span></span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果在这里卡住了，那么就没办法处理EventLoop绑定的其他Channel了，所以我们这里就创建一个普通的EventLoop来专门处理读写之外的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    EventLoopGroup handlerGroup = <span class="keyword">new</span> DefaultEventLoopGroup();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                  	System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    handlerGroup.submit(() -&gt; &#123;   </span><br><span class="line">                                <span class="comment">//由于继承自ScheduledExecutorService，我们直接提交任务就行了，是不是感觉贼方便</span></span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以写成一条流水线：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(), workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    EventLoopGroup handlerGroup = <span class="keyword">new</span> DefaultEventLoopGroup();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).addLast(handlerGroup, <span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;  <span class="comment">//在添加时，可以直接指定使用哪个EventLoopGroup</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就进一步地将EventLoop利用起来了。</p>
<p>按照前面服务端的方式，我们来把Netty版本的客户端也给写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();   <span class="comment">//客户端也是使用Bootstrap来启动</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())   <span class="comment">//客户端就没那么麻烦了，直接一个EventLoop就行，用于处理发回来的数据</span></span><br><span class="line">            .channel(NioSocketChannel.class)   <span class="comment">//客户端肯定就是使用SocketChannel了</span></span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//这里的数据处理方式和服务端是一样的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;   </span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();  <span class="comment">//连接后拿到对应的Channel对象</span></span><br><span class="line">  	<span class="comment">//注意上面连接操作是异步的，调用之后会继续往下走，下面我们就正式编写客户端的数据发送代码了</span></span><br><span class="line">    <span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;    <span class="comment">//还是和之前一样，扫了就发</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));  <span class="comment">//通过Channel对象发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h23b2raotjj21a607u3zd.jpg" alt="image-20220510144513303"></p>
<h3 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h3><p>我们接着来看ChannelFuture，前面我们提到，Netty中Channel的相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果，如果需要得到结果，那么我们就必须要利用到Future。</p>
<p>我们先来看看ChannelFutuer接口怎么定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;    <span class="comment">//我们可以直接获取此任务的Channel</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;  <span class="comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;   <span class="comment">//在当前线程同步等待异步任务完成，任务失败会抛出异常</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;   <span class="comment">//同上，但是无法响应中断</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  <span class="comment">//同上，但是任务中断不会抛出异常，需要手动判断</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;    <span class="comment">//不用我说了吧？</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isVoid</span><span class="params">()</span></span>;   <span class="comment">//返回类型是否为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口是继承自Netty中的Future接口的（不是JDK的那个）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;   <span class="comment">//再往上才是JDK的Future</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;    <span class="comment">//用于判断任务是否执行成功的</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;    <span class="comment">//获取导致任务失败的异常</span></span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">    </span><br><span class="line">    <span class="function">V <span class="title">getNow</span><span class="params">()</span></span>;  <span class="comment">//立即获取结果，如果还未产生结果，得到null，不过ChannelFuture定义V为Void，就算完成了获取也是null</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;    <span class="comment">//取消任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel的很多操作都是异步完成的，直接返回一个ChannelFuture，比如Channel的write操作，返回的就是一个ChannelFuture对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        ChannelFuture future = ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        System.out.println(<span class="string">&quot;任务完成状态：&quot;</span>+future.isDone());   <span class="comment">//通过ChannelFuture来获取相关信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>包括我们的服务端启动也是返回的ChannelFuture：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">								&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端的启动就比较慢了，所以在一开始直接获取状态会返回<code>false</code>，但是这个时候我们又需要等到服务端启动完成之后做一些事情，这个时候该怎么办呢？现在我们就有两种方案了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    future.sync();   <span class="comment">//让当前线程同步等待任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方案是直接让当前线程同步等待异步任务完成，我们可以使用<code>sync()</code>方法，这样当前线程会一直阻塞直到任务结束。第二种方案是添加一个监听器，等待任务完成时通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">		<span class="comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span></span><br><span class="line">    future.addListener(f -&gt; System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括客户端的关闭，也是异步进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        String text = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(text.equals(<span class="string">&quot;exit&quot;</span>)) &#123;   <span class="comment">//输入exit就退出</span></span><br><span class="line">            ChannelFuture future = channel.close();</span><br><span class="line">            future.sync();    <span class="comment">//等待Channel完全关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully();   <span class="comment">//优雅退出EventLoop，其实就是把还没发送的数据之类的事情做完，当然也可以shutdownNow立即关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看Promise接口，它支持手动设定成功和失败的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此接口也是继承自Netty中的Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V var1)</span></span>;    <span class="comment">//手动设定成功</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable var1)</span></span>;  <span class="comment">//手动设定失败</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//这些就和之前的Future是一样的了</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... var1)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop());</span><br><span class="line">    System.out.println(promise.isSuccess());    <span class="comment">//在一开始肯定不是成功的</span></span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);    <span class="comment">//设定成功</span></span><br><span class="line">    System.out.println(promise.isSuccess());   <span class="comment">//再次获取，可以发现确实成功了</span></span><br><span class="line">    System.out.println(promise.get());    <span class="comment">//获取结果，就是我们刚刚给进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们可以手动指定成功状态，包括ChannelOutboundInvoker中的一些基本操作，都是支持ChannelPromise的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+text);</span><br><span class="line">        ChannelPromise promise = <span class="keyword">new</span> DefaultChannelPromise(channel);</span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()), promise);</span><br><span class="line">        promise.sync();  <span class="comment">//同步等待一下</span></span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后结果就是我们想要的了，当然我们也可以像Future那样添加监听器，当成功时自动通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop()); </span><br><span class="line">    promise.addListener(f -&gt; System.out.println(promise.get()));   <span class="comment">//注意是在上面的DefaultEventLoop执行的</span></span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关Future和Promise就暂时讲解到这里。</p>
<h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>前面我们已经了解了Netty的大部分基础内容，我们接着来看看Netty内置的一些编码器和解码器。</p>
<p>在前面的学习中，我们的数据发送和接收都是需要以ByteBuf形式传输，但是这样是不是有点太不方便了，咱们能不能参考一下JavaWeb那种搞个Filter，在我们开始处理数据之前，过过滤一次，并在过滤的途中将数据转换成我们想要的类型，也可以将发出的数据进行转换，这就要用到编码解码器了。</p>
<p>我们先来看看最简的，字符串，如果我们要直接在客户端或是服务端处理字符串，可以直接添加一个字符串解码器到我们的流水线中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> StringDecoder())   <span class="comment">//当客户端发送来的数据只是简单的字符串转换的ByteBuf时，我们直接使用内置的StringDecoder即可转换</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//经过StringDecoder转换后，msg直接就是一个字符串，所以打印就行了</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用起来还是非常方便的，我们只需要将其添加到流水线即可，实际上器本质就是一个ChannelInboundHandlerAdapter：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24d0v15dkj21zs0k6ad5.jpg" alt="image-20220511123807650"></p>
<p>我们看到它是继承自MessageToMessageDecoder，用于将传入的Message转换为另一种类型，我们也可以自行编写一个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们也来搞一个自定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);   <span class="comment">//解码后需要将解析后的数据丢进List中，如果丢进去多个数据，相当于数据被分成了多个，后面的Handler就需要每个都处理一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，可以看到：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24db102gqj214o02qq2x.jpg" alt="image-20220511124755974"></p>
<p>当然如果我们在List里面丢很多个数据的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        String text = buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);</span><br><span class="line">        list.add(text+<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(text+<span class="string">&#x27;3&#x27;</span>);   <span class="comment">//一条消息被解码成三条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dcpcdxoj215e04eq2z.jpg" alt="image-20220511124933026"></p>
<p>可以看到，后面的Handler会依次对三条数据都进行处理，当然，除了MessageToMessageDecoder之外，还有其他类型的解码器，比如ByteToMessageDecoder等，这里就不一一介绍了，Netty内置了很多的解码器实现来方便我们开发，比如HTTP（下一节介绍），SMTP、MQTT等，以及我们常用的Redis、Memcached、JSON等数据包。</p>
<p>当然，有了解码器处理发来的数据，那发出去的数据肯定也是需要被处理的，所以编码器就出现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());  <span class="comment">//使用内置的StringEncoder可以直接将出站的字符串数据编码成ByteBuf</span></span><br></pre></td></tr></table></figure>

<p>和上面的StringDecoder一样，StringEncoder本质上就是一个ChannelOutboundHandlerAdapter：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24domthrqj21qe0i8mzp.jpg" alt="image-20220511130100984"></p>
<p>是不是感觉前面学习的Handler和Pipeline突然就变得有用了，直接一条线把数据处理安排得明明白白啊。</p>
<p>现在我们把客户端也改成使用编码、解码器的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioSocketChannel.class)</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> StringDecoder())  <span class="comment">//解码器安排</span></span><br><span class="line">                            .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);  <span class="comment">//直接接收字符串</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .addLast(<span class="keyword">new</span> StringEncoder());  <span class="comment">//编码器安排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();</span><br><span class="line">    <span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            String text = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(text);  <span class="comment">//直接发送字符串就行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的代码量又蹭蹭的减少了很多：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dtwy88pj214y04ojrv.jpg" alt="image-20220511130605337"></p>
<p>当然，除了编码器和解码器之外，还有编解码器。？？缝合怪？？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24dxlf02nj21qu0fyn0h.jpg" alt="image-20220511130937624"></p>
<p>可以看到它是既继承了ChannelInboundHandlerAdapter也实现了ChannelOutboundHandler接口，又能处理出站也能处理入站请求，实际上就是将之前的给组合到一起了，比如我们也可以实现一个缝合在一起的StringCodec类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要指定两个泛型，第一个是入站的消息类型，还有一个是出站的消息类型，出站是String类型，我们要转成ByteBuf</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCodec</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理出站数据...&quot;</span>);</span><br><span class="line">        list.add(Unpooled.wrappedBuffer(buf.getBytes()));   <span class="comment">//同样的，添加的数量就是出站的消息数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理入站数据...&quot;</span>);</span><br><span class="line">        list.add(buf.toString(StandardCharsets.UTF_8));  <span class="comment">//和之前一样，直接一行解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上就是需要我们同时去实现编码和解码方法，继承MessageToMessageCodec类即可。</p>
<p>当然，如果整条流水线上有很多个解码器或是编码器，那么也可以多次进行编码或是解码，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是预处理编码器，就要皮这一下。&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;[已处理] &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder())    <span class="comment">//最后再转成ByteBuf</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringToStringEncoder());  <span class="comment">//先从我们自定义的开始</span></span><br></pre></td></tr></table></figure>

<p>可以看到，数据在流水线上一层一层处理最后再回到的客户端：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24ej8u6cqj219m04cq3f.jpg" alt="image-20220511133025492"></p>
<p>我们在一开始提到的粘包/拆包问题，也可以使用一个解码器解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">10</span>))  </span><br><span class="line">        <span class="comment">//第一种解决方案，使用定长数据包，每个数据包都要是指定长度</span></span><br><span class="line">  			...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, Unpooled.wrappedBuffer(<span class="string">&quot;!&quot;</span>.getBytes())))</span><br><span class="line">        <span class="comment">//第二种，就是指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span></span><br><span class="line">  			<span class="comment">//在收到分隔符之前的所有数据，都作为同一个数据包的内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment">//第三种方案，就是在头部添加长度信息，来确定当前发送的数据包具体长度是多少</span></span><br><span class="line">        <span class="comment">//offset是从哪里开始，length是长度信息占多少字节，这里是从0开始读4个字节表示数据包长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>))   <span class="comment">//客户端在发送时也需要将长度拼到前面去</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure>

<p>有关编码器和解码器的内容就先介绍到这里。</p>
<h3 id="实现HTTP协议通信"><a href="#实现HTTP协议通信" class="headerlink" title="实现HTTP协议通信"></a>实现HTTP协议通信</h3><p>前面我们介绍了Netty为我们提供的编码器和解码器，这里我们就来使用一下支持HTTP协议的编码器和解码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  <span class="comment">//看看是个啥类型</span></span><br><span class="line">              	<span class="comment">//收到浏览器请求后，我们需要给一个响应回去</span></span><br><span class="line">                FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);  <span class="comment">//HTTP版本为1.1，状态码就OK（200）即可</span></span><br><span class="line">              	<span class="comment">//直接向响应内容中写入数据</span></span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);   <span class="comment">//发送响应</span></span><br><span class="line">                ctx.channel().close();   <span class="comment">//HTTP请求是一次性的，所以记得关闭</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());   <span class="comment">//响应记得也要编码后发送哦</span></span><br></pre></td></tr></table></figure>

<p>现在我们用浏览器访问一下我们的服务器吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24fzjztiyj22ac0k2gox.jpg" alt="image-20220511142040941"></p>
<p>可以看到浏览器成功接收到服务器响应，然后控制台打印了以下类型：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24g08odmrj21e604kmyh.jpg" alt="image-20220511142121619"></p>
<p>可以看到一次请求是一个DefaultHttpRequest+LastHttpContent$1，这里有两组是因为浏览器请求了一个地址之后紧接着请求了我们网站的favicon图标。</p>
<p>这样把数据分开处理肯定是不行的，要是直接整合成一个多好，安排：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                FullHttpRequest request = (FullHttpRequest) msg;</span><br><span class="line">                System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">                FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br></pre></td></tr></table></figure>

<p>再次访问，我们发现可以正常读取请求路径了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gcntjzbj210c02e74b.jpg" alt="image-20220511143318500"></p>
<p>我们来试试看搞个静态页面代理玩玩，拿出我们的陈年老模板：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24gjzm12aj214i0k842b.jpg" alt="image-20220511144020424"></p>
<p>全部放进Resource文件夹，一会根据浏览器的请求路径，我们就可以返回对应的页面了，先安排一个解析器，用于解析路径然后将静态页面的内容返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResolver</span> </span>&#123;</span><br><span class="line">		<span class="comment">//直接单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PageResolver INSTANCE = <span class="keyword">new</span> PageResolver();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PageResolver</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageResolver <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FullHttpResponse <span class="title">resolveResource</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;/&quot;</span>))  &#123;  <span class="comment">//判断一下是不是正常的路径请求</span></span><br><span class="line">            path = path.equals(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;index.html&quot;</span> : path.substring(<span class="number">1</span>);    <span class="comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span></span><br><span class="line">            <span class="keyword">try</span>(InputStream stream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stream != <span class="keyword">null</span>) &#123;   <span class="comment">//拿到文件输入流之后，才可以返回页面</span></span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                    stream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.packet(HttpResponseStatus.OK, bytes);  <span class="comment">//数据先读出来，然后交给下面的方法打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//其他情况一律返回404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.packet(HttpResponseStatus.NOT_FOUND, <span class="string">&quot;404 Not Found!&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//包装成FullHttpResponse，把状态码和数据写进去</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FullHttpResponse <span class="title">packet</span><span class="params">(HttpResponseStatus status, <span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status);</span><br><span class="line">        response.content().writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的静态资源解析就写好了，接着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                FullHttpRequest request = (FullHttpRequest) msg;</span><br><span class="line">              	<span class="comment">//请求进来了直接走解析</span></span><br><span class="line">                PageResolver resolver = PageResolver.getInstance();</span><br><span class="line">                ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器来试试看吧：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24hbzfrozj21dy0u0jw2.jpg" alt="image-20220511150714100"></p>
<p>可以看到页面可以正常展示了，是不是有Tomcat哪味了。</p>
<h3 id="其他内置Handler介绍"><a href="#其他内置Handler介绍" class="headerlink" title="其他内置Handler介绍"></a>其他内置Handler介绍</h3><p>Netty也为我们内置了一些其他比较好用的Handler，比如我们要打印日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))   <span class="comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>日志级别我们选择INFO，现在我们用浏览器访问一下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25j8p1xc2j22ig0sutk2.jpg" alt="image-20220512125851248"></p>
<p>可以看到每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p>
<p>我们也可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpRequestDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> RuleBasedIpFilter(<span class="keyword">new</span> IpFilterRule() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="string">&quot;127.0.0.1&quot;</span>);  </span><br><span class="line">              	<span class="comment">//进行匹配，返回false表示匹配失败</span></span><br><span class="line">              	<span class="comment">//如果匹配失败，那么会根据下面的类型决定该干什么，比如我们这里判断是不是本地访问的，如果是那就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> IpFilterRuleType <span class="title">ruleType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> IpFilterRuleType.REJECT;   <span class="comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>现在我们浏览器访问一下看看：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jjq53pvj21r40m8abh.jpg" alt="image-20220512130926968"></p>
<p>我们也可以对那些长期处于空闲的进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>))  <span class="comment">//IdleStateHandler能够侦测连接空闲状态</span></span><br><span class="line">        <span class="comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，第三个是读写操作都算，0表示禁用</span></span><br><span class="line">        <span class="comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//没想到吧，这个方法原来是在这个时候用的</span></span><br><span class="line">                <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                    IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">                    <span class="keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;好久都没写了，看视频的你真的有认真在跟着敲吗&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经很久很久没有读事件发生了，好寂寞&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> StringEncoder());</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们超过一段时间不发送数据时，就会这样：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h25jteal4rj21eo07qabh.jpg" alt="image-20220512131845296"></p>
<p>通过这种机制，我们就可以直接关掉那些占着茅坑不拉屎的连接。</p>
<h3 id="启动流程源码解读"><a href="#启动流程源码解读" class="headerlink" title="启动流程源码解读"></a>启动流程源码解读</h3><p>前面我们完成了对Netty基本功能的讲解，我们最后就来看一下，Netty到底是如何启动以及进行数据处理的。</p>
<p>首先我们知道，整个服务端是在bind之后启动的，那么我们就从这里开始下手，不多BB直接上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(<span class="keyword">new</span> InetSocketAddress(inetPort));   <span class="comment">//转换成InetSocketAddress对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进来之后发现是调用的其他绑定方法，继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.validate();   <span class="comment">//再次验证一下，看看EventLoopGroup和Channel指定了没</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister();   <span class="comment">//上来第一句初始化然后注册</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看是怎么注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = <span class="keyword">this</span>.channelFactory.newChannel();    <span class="comment">//通过channelFactory创建新的Channel，实际上就是我们在一开始设定的NioServerSocketChannel</span></span><br><span class="line">        <span class="keyword">this</span>.init(channel);    <span class="comment">//接着对创建好的NioServerSocketChannel进行初始化</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel); <span class="comment">//将通道注册到bossGroup中的一个EventLoop中</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看是如何对创建好的ServerSocketChannel进行初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, <span class="keyword">this</span>.newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, <span class="keyword">this</span>.newAttributesArray());</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在流水线上添加一个Handler，在Handler初始化的时候向EventLoop中提交一个任务，将ServerBootstrapAcceptor添加到流水线上</span></span><br><span class="line">    <span class="comment">//这样我们的ServerSocketChannel在客户端连接时就能Accept了</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  	<span class="comment">//这里提交一个任务，将ServerBootstrapAcceptor添加到ServerSocketChannel的pipeline中</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下，ServerBootstrapAcceptor怎么处理的，直接看到它的<code>channelRead</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当底层NIO的ServerSocketChannel的Selector有OP_ACCEPT事件到达时，NioEventLoop会接收客户端连接，创建SocketChannel，并触发channelRead回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//此时msg就是Accept连接创建之后的Channel对象</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel)msg;</span><br><span class="line">  	<span class="comment">//这里直接将我们之前编写的childHandler添加到新创建的客户端连接的流水线中（是不是感觉突然就通了）</span></span><br><span class="line">    child.pipeline().addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">this</span>.childHandler&#125;);</span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, <span class="keyword">this</span>.childOptions, ServerBootstrap.logger);</span><br><span class="line">    AbstractBootstrap.setAttributes(child, <span class="keyword">this</span>.childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//直接向workGroup中的一个EventLoop注册新创建好的客户端连接Channel，等待读写事件</span></span><br><span class="line">        <span class="keyword">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          	<span class="comment">//异步操作完成后，如果没有注册成功，就强制关闭这个Channel</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                	...</span><br></pre></td></tr></table></figure>

<p>所以，实际上就是我们之前讲解的主从Reactor多线程模型，只要前面理解了，这里其实很好推断。</p>
<p>初始化完成之后，我们来看看注册，在之前NIO阶段我们也是需要将Channel注册到对应的Selector才可以开始选择：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));  <span class="comment">//转换成ChannelPromise继续</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);   <span class="comment">//调用Channel的Unsafe接口实现进行注册</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续向下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.register0(promise);    <span class="comment">//这里是继续调用register0方法在进行注册</span></span><br><span class="line">        &#125;</span><br><span class="line">  	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = <span class="keyword">this</span>.neverRegistered;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doRegister();    <span class="comment">//这里开始执行AbstractNioChannel中的doRegister方法进行注册</span></span><br><span class="line">      	AbstractChannel.<span class="keyword">this</span>.registered = <span class="keyword">true</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="keyword">this</span>.safeSetSuccess(promise);</span><br><span class="line">      	<span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelActive();   <span class="comment">//这里是关键</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.config().isAutoRead()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到最后一级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//可以看到在这里终于是真正的进行了注册，javaChannel()得到NIO的Channel对象，然后调用register方法</span></span><br><span class="line">          	<span class="comment">//这里就和我们之前NIO一样了，将Channel注册到Selector中，可以看到Selector也是EventLoop中的</span></span><br><span class="line">          	<span class="comment">//但是注意，这里的ops参数是0，也就是不监听任何事件</span></span><br><span class="line">            <span class="keyword">this</span>.selectionKey = <span class="keyword">this</span>.javaChannel().register(<span class="keyword">this</span>.eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到上一级，在doRegister完成之后，会拿到selectionKey，但是注意这时还没有监听任何事件，我们接着看到下面的fireChannelActive方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(<span class="keyword">this</span>.head);   <span class="comment">//传的是流水线上的默认头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();   <span class="comment">//继续向下</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler)<span class="keyword">this</span>.handler()).channelActive(<span class="keyword">this</span>);   <span class="comment">//依然是调用的头结点的channelActive方法进行处理</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeExceptionCaught(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;   <span class="comment">//这里是头结点的</span></span><br><span class="line">    ctx.fireChannelActive();    </span><br><span class="line">    <span class="keyword">this</span>.readIfIsAutoRead();   <span class="comment">//继续向下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DefaultChannelPipeline.<span class="keyword">this</span>.channel.config().isAutoRead()) &#123;</span><br><span class="line">        DefaultChannelPipeline.<span class="keyword">this</span>.channel.read();    <span class="comment">//继续不断向下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.unsafe.beginRead();   <span class="comment">//最后这里会调用beginRead方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doBeginRead();    <span class="comment">//这里就是调用AbstractNioChannel的doBeginRead方法了</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception var2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireExceptionCaught(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;    <span class="comment">//先拿到之前注册好的selectionKey</span></span><br><span class="line">    <span class="keyword">if</span> (selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.readPending = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> interestOps = selectionKey.interestOps();   <span class="comment">//把监听的操作取出来</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; <span class="keyword">this</span>.readInterestOp) == <span class="number">0</span>) &#123;    <span class="comment">//如果没有监听任何操作</span></span><br><span class="line">            selectionKey.interestOps(interestOps | <span class="keyword">this</span>.readInterestOp);   <span class="comment">//那就把readInterestOp事件进行监听，这里的readInterestOp实际上就是OP_ACCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，Channel在初始化完成之后也完成了底层的注册，已经可以开始等待事件了。</p>
<p>我们现在回到之前的<code>doBind</code>方法的注册位置，现在注册完成之后，基本上整个主从Reactor结构就已经出来了，我们来看看还要做些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister();  <span class="comment">//目前初始化和注册都已经成功了</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();    <span class="comment">//由于是异步操作，我们通过ChannelFuture拿到对应的ServerSocketChannel对象</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;   <span class="comment">//如果说初始化已经完成了</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);   <span class="comment">//直接开始进行进一步的绑定</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//如果还没搞完，那就创Promis继续等待任务完成</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后都会走到<code>doBind0</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(<span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//最后会向Channel已经注册到的EventLoop中提交一个新的任务</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">              	<span class="comment">//这里才是真正调用Channel底层进行绑定操作</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，服务端的启动流程结束。我们前面还提到了NIO的空轮询问题，这里我们来看看Netty是如何解决的，我们直接定位到NioEventLoop中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于代码太多，这里省略大部分代码</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> var34;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	...</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasTasks()) &#123;</span><br><span class="line">                                strategy = <span class="keyword">this</span>.select(curDeadlineNanos);   <span class="comment">//首先会在这里进行Selector.select()操作，跟NIO是一样的</span></span><br><span class="line">                            &#125;</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">            ++selectCnt;    <span class="comment">//每次唤醒都会让selectCnt自增</span></span><br><span class="line">            <span class="keyword">this</span>.cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">          	...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ranTasks &amp;&amp; strategy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.unexpectedSelectorWakeup(selectCnt)) &#123;   <span class="comment">//这里会进行判断是否出现空轮询BUG</span></span><br><span class="line">           	...</span><br></pre></td></tr></table></figure>

<p>我们来看看是怎么进行判断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unexpectedSelectorWakeup</span><span class="params">(<span class="keyword">int</span> selectCnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Selector.select() returned prematurely because Thread.currentThread().interrupt() was called. Use NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果selectCnt大于等于SELECTOR_AUTO_REBUILD_THRESHOLD（默认为512）那么会直接重建Selector</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, <span class="keyword">this</span>.selector);</span><br><span class="line">        <span class="keyword">this</span>.rebuildSelector();   <span class="comment">//当前的Selector出现BUG了，得重建一个Selector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，当每次空轮询发生时会有专门的计数器+1，如果空轮询的次数超过了512次，就认为其触发了空轮询bug，触发bug后，Netty直接重建一个Selector，将原来的Channel重新注册到新的 Selector上，将旧的 Selector关掉，这样就防止了无限循环。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 网络编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/1197.html" rel="prev" title="并发编程学习">
      <i class="fa fa-chevron-left"></i> 并发编程学习
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/d776.html" rel="next" title="jvm虚拟机">
      jvm虚拟机 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0"><span class="nav-text">网络编程学习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO%E5%9F%BA%E7%A1%80"><span class="nav-text">NIO基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">Buffer类及其实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-text">缓冲区写操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-text">缓冲区读操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="nav-text">缓冲区其他操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%AF%94%E8%BE%83"><span class="nav-text">缓冲区比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">只读缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBuffer%E5%92%8CCharBuffer"><span class="nav-text">ByteBuffer和CharBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">直接缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-text">通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A5%E5%8F%A3%E5%B1%82%E6%AC%A1"><span class="nav-text">通道接口层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93FileChannel"><span class="nav-text">文件传输FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81FileLock"><span class="nav-text">文件锁FileLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-text">多路复用网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9EI-O%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-text">传统阻塞I&#x2F;O网络通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">选择器与I&#x2F;O多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Reactor%E6%A8%A1%E5%BC%8F"><span class="nav-text">实现Reactor模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty%E6%A1%86%E6%9E%B6"><span class="nav-text">Netty框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO%E6%A1%86%E6%9E%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">NIO框架存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A9%BA%E8%BD%AE%E8%AF%A2"><span class="nav-text">客户端关闭导致服务端空轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">粘包&#x2F;拆包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%B0%E8%BF%9BNetty%E6%A1%86%E6%9E%B6"><span class="nav-text">走进Netty框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBuf%E4%BB%8B%E7%BB%8D"><span class="nav-text">ByteBuf介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%AE%80%E4%BB%8B"><span class="nav-text">零拷贝简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">Netty工作模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E8%AF%A6%E8%A7%A3"><span class="nav-text">Channel详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop%E5%92%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-text">EventLoop和任务调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future%E5%92%8CPromise"><span class="nav-text">Future和Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">编码器和解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0HTTP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1"><span class="nav-text">实现HTTP协议通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AEHandler%E4%BB%8B%E7%BB%8D"><span class="nav-text">其他内置Handler介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-text">启动流程源码解读</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuumiy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yuumiy</p>
  <div class="site-description" itemprop="description">coding就是生产力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuumiy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuumiy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:115274737@qq.com" title="E-Mail → mailto:115274737@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://yuumiy.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;yuumiy.blog.csdn.net" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuumiy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">322k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:52</span>
</div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("08/10/2021 12:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
</script>

<script async src="/js/busuanzi.pure.mini.js"></script>
<span><br></span>	

<span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
</span>
<span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
    <span class="post-meta-divider">|</span>
<span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
</span>
    <span>总访问量&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/js/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'PuhblTYT44STCX6Edvpd76zF-gzGzoHsz',
      appKey     : '43DKcrM2QNBca1Ww68fepMOV',
      placeholder: "填写邮箱作者能够及时反馈，欢迎评论哦(๑•̀ㅂ•́)و✧",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
