<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="NmvL2aBrGRwi3CzraBejtkwEbHmmH-7u73OJj3FMOoc">
  <meta name="msvalidate.01" content="5DB1ECD7406CD70A251CF96C939178B9">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuumiy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="jdk8新特性学习的使用方法总结笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK8新特性使用方法总结">
<meta property="og:url" content="https://yuumiy.github.io/posts/caff.html">
<meta property="og:site_name" content="岛田悠米">
<meta property="og:description" content="jdk8新特性学习的使用方法总结笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-11T04:22:06.000Z">
<meta property="article:modified_time" content="2023-08-11T04:22:06.000Z">
<meta property="article:author" content="Yuumiy">
<meta property="article:tag" content="jdk新特性">
<meta property="article:tag" content="jdk8">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yuumiy.github.io/posts/caff.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JDK8新特性使用方法总结 | 岛田悠米</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="岛田悠米" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛田悠米</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心中有梦 不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuumiy.github.io/posts/caff.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yuumiy">
      <meta itemprop="description" content="coding就是生产力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛田悠米">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JDK8新特性使用方法总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-11 12:22:06" itemprop="dateCreated datePublished" datetime="2023-08-11T12:22:06+08:00">2023-08-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span id="/posts/caff.html" class="post-meta-item leancloud_visitors" data-flag-title="JDK8新特性使用方法总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/posts/caff.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/caff.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer" />

<blockquote>
<p>jdk8新特性学习的使用方法总结笔记</p>
</blockquote>
<span id="more"></span>



<h1 id="JDK8新特性使用方法总结"><a href="#JDK8新特性使用方法总结" class="headerlink" title="JDK8新特性使用方法总结"></a>JDK8新特性使用方法总结</h1><h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><h3 id="1、匿名内部类"><a href="#1、匿名内部类" class="headerlink" title="1、匿名内部类"></a>1、匿名内部类</h3><ol>
<li><p>定义：没有名字的内部类</p>
</li>
<li><p>使用场景：<code>简化书写</code>；<code>某个局部类你只需要使用一次</code>，就可以使用匿名内部类</p>
</li>
<li><p>前提：必须存在继承或实现关系时才能使用</p>
</li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类的写法</span></span><br><span class="line">        <span class="keyword">new</span> Animal()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正常的写法</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        d.eat();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小狗吃肉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>本质：在编译时生成一个Class 文件。XXXXX$1.class </p>
</li>
</ol>
<h3 id="2、需求分析"><a href="#2、需求分析" class="headerlink" title="2、需求分析"></a>2、需求分析</h3><p>创建一个新的线程，指定线程要执行的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambdaDemo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新线程中执行的代码 : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程中的代码：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了匿名内部类，传入一个实现类，实现了run方法</p>
<h3 id="3、Lambda表达式初体验"><a href="#3、Lambda表达式初体验" class="headerlink" title="3、Lambda表达式初体验"></a>3、Lambda表达式初体验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新线程中执行的代码 : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新线程中执行的代码 : &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure>

<p>优点：<code>简化了匿名内部类的使用</code></p>
<h3 id="4、Lambda的语法规则"><a href="#4、Lambda的语法规则" class="headerlink" title="4、Lambda的语法规则"></a>4、Lambda的语法规则</h3><p>Lambda省去了面向对象的条条框框，Lambda的标准格式由3个部分组成：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123;</span><br><span class="line">	代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>(参数类型 参数名称)：<code>参数列表</code></li>
<li>{代码体;} ：<code>方法体</code></li>
<li>-&gt; ：<code>箭头</code>，分割参数列表和方法体</li>
</ul>
<h4 id="4-1-Lambda练习1"><a href="#4-1-Lambda练习1" class="headerlink" title="4.1 Lambda练习1"></a>4.1 Lambda练习1</h4><p>​    练习无参无返回值的Lambda</p>
<p>定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建主方法使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        goShow(<span class="keyword">new</span> UserService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;show 方法执行了...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        goShow(() -&gt; &#123; System.out.println(<span class="string">&quot;Lambda show 方法执行了...&quot;</span>); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goShow</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">    userService.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-Lambda练习2"><a href="#4-2-Lambda练习2" class="headerlink" title="4.2 Lambda练习2"></a>4.2 Lambda练习2</h4><p>​    练习有参有返回值的Lambda</p>
<p>创建一个Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在List集合中保存多个Person对象，然后对这些对象做根据age排序操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;周杰伦&quot;</span>,<span class="number">33</span>,<span class="number">175</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;刘德华&quot;</span>,<span class="number">43</span>,<span class="number">185</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;周星驰&quot;</span>,<span class="number">38</span>,<span class="number">177</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;郭富城&quot;</span>,<span class="number">23</span>,<span class="number">170</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Collections.sort(list, new Comparator&lt;Person&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Person o1, Person o2) &#123;</span></span><br><span class="line"><span class="comment">//                return o1.getAge()-o2.getAge();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        Collections.sort(list,(Person o1, Person o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在sort方法的第二个参数是一个Comparator接口的匿名内部类，且执行的方法有参数和返回值，那么我们可以改写为Lambda表达式</p>
<h3 id="5、Lambda表达式的省略写法"><a href="#5、Lambda表达式的省略写法" class="headerlink" title="5、Lambda表达式的省略写法"></a>5、Lambda表达式的省略写法</h3><p>在lambda表达式的标准写法基础上，可以使用省略写法的规则为：</p>
<ol>
<li> 小括号内的参数类型可以省略</li>
<li> 如果小括号内有且仅有一个参数，则小括号可以省略</li>
<li> 如果大括号内有且仅有一个语句，可以同时省略大括号，return 关键字及语句分号</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        goStudent((String name,Integer age)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> name + age + <span class="string">&quot; 6666 ...&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略写法</span></span><br><span class="line">        goStudent((name,age)-&gt; name + age + <span class="string">&quot; 6666 ...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        goOrder((String name)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---&gt;&quot;</span> + name);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略写法</span></span><br><span class="line">        goOrder(name -&gt; <span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goStudent</span><span class="params">(StudentService studentService)</span></span>&#123;</span><br><span class="line">        studentService.show(<span class="string">&quot;张三&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goOrder</span><span class="params">(OrderService orderService)</span></span>&#123;</span><br><span class="line">        orderService.show(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Lambda表达式的使用前提"><a href="#6、Lambda表达式的使用前提" class="headerlink" title="6、Lambda表达式的使用前提"></a>6、Lambda表达式的使用前提</h3><ol>
<li>方法的参数必须为接口才能使用Lambda</li>
<li>接口中有且仅有一个抽象方法</li>
</ol>
<h3 id="7、Lambda和匿名内部类的比较"><a href="#7、Lambda和匿名内部类的比较" class="headerlink" title="7、Lambda和匿名内部类的比较"></a>7、Lambda和匿名内部类的比较</h3><ol>
<li>所需类型不一样<ul>
<li>匿名内部类的类型可以是 类，抽象类，接口</li>
<li>Lambda表达式需要的类型必须是接口</li>
</ul>
</li>
<li>抽象方法的数量不一样<ul>
<li>匿名内部类所需的接口中的抽象方法的数量是随意的</li>
<li>Lambda表达式所需的接口中只能有一个抽象方法</li>
</ul>
</li>
<li>实现原理不一样<ul>
<li>匿名内部类是在编译后形成一个class</li>
<li>Lambda表达式是在程序运行的时候动态生成class</li>
</ul>
</li>
</ol>
<h2 id="二、接口中新增的方法"><a href="#二、接口中新增的方法" class="headerlink" title="二、接口中新增的方法"></a>二、接口中新增的方法</h2><h3 id="1、JDK8中接口的新增"><a href="#1、JDK8中接口的新增" class="headerlink" title="1、JDK8中接口的新增"></a>1、JDK8中接口的新增</h3><p>JDK8之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    静态常量;   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">    抽象方法;   <span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK8之后对接口做了增加，接口中可以有默认方法和静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    静态常量;   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">    抽象方法;   <span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">    默认方法;   <span class="keyword">public</span> <span class="keyword">default</span></span><br><span class="line">    静态方法;   <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、默认方法"><a href="#2、默认方法" class="headerlink" title="2、默认方法"></a>2、默认方法</h3><h4 id="2-1-为什么要增加默认方法"><a href="#2-1-为什么要增加默认方法" class="headerlink" title="2.1 为什么要增加默认方法"></a>2.1 为什么要增加默认方法</h4><p>在JDK8以前接口中只能有抽象方法和静态常量，会存在以下的问题：<br>    如果接口中新增抽象方法，那么实现类都必须要抽象这个抽象方法，非常不利于接口的扩展的</p>
<h4 id="2-2-默认方法的使用"><a href="#2-2-默认方法的使用" class="headerlink" title="2.2 默认方法的使用"></a>2.2 默认方法的使用</h4><p>默认方法可以被继承，实现类可以直接调用接口默认方法，也可以重写接口默认方法</p>
<h3 id="3、静态方法"><a href="#3、静态方法" class="headerlink" title="3、静态方法"></a>3、静态方法</h3><p>JDK8中为接口新增了静态方法，作用也是为了接口的扩展</p>
<p>使用：接口中的静态方法在实现类中是不能被重写的，调用的话只能通过: 接口名.静态方法名</p>
<h3 id="4、两者的区别"><a href="#4、两者的区别" class="headerlink" title="4、两者的区别"></a>4、两者的区别</h3><ol>
<li>默认方法通过实例调用，静态方法通过接口名调用</li>
<li>默认方法可以被继承，实现类可以直接调用接口默认方法，也可以重写接口默认方法</li>
<li>静态方法不能被继承，实现类不能重写接口的静态方法，只能使用接口名调用</li>
</ol>
<h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><h3 id="1、函数式接口的由来"><a href="#1、函数式接口的由来" class="headerlink" title="1、函数式接口的由来"></a>1、函数式接口的由来</h3><p>​    Lambda表达式的使用前提是要有函数式接口，而Lambda表达式使用时不关心接口名、抽象方法名。只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda表达式更加方便，JDK8中提供了大量常用的函数式接口</p>
<h3 id="2、函数式接口介绍"><a href="#2、函数式接口介绍" class="headerlink" title="2、函数式接口介绍"></a>2、函数式接口介绍</h3><p>​    JDK8提供的函数式接口，主要是在 java.util.function 包中</p>
<h4 id="2-1-Supplier"><a href="#2-1-Supplier" class="headerlink" title="2.1 Supplier"></a>2.1 Supplier</h4><p>​    无参有返回值的接口，对于的Lambda表达式需要提供一个返回数据的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">//标明为函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* Supplier 函数式接口的使用</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fun1(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> arr[] = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">44</span>,<span class="number">99</span>,<span class="number">10</span>&#125;;</span><br><span class="line">            <span class="comment">// 计算出数组中的最大值</span></span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            <span class="keyword">return</span> arr[arr.length-<span class="number">1</span>];</span><br><span class="line">    	&#125;);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="comment">// get() 是一个无参的有返回值的</span></span><br><span class="line">        Integer max = supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Consumer"><a href="#2-2-Consumer" class="headerlink" title="2.2 Consumer"></a>2.2 Consumer</h4><p>​    有参无返回值的接口，前面的Supplier接口是用来生产数据的，而Consumer接口是用来消费数据的，使用的时候需要输入数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：将输入的数据统一转换为小写输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">        	System.out.println(msg + <span class="string">&quot;-&gt; 转换为小写：&quot;</span> + msg.toLowerCase());</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;String&gt; consumer)</span></span>&#123;</span><br><span class="line">		consumer.accept(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Function"><a href="#2-3-Function" class="headerlink" title="2.3 Function"></a>2.3 Function</h4><p>​    有参有返回值的接口，Function接口是根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有参数有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：传递进入一个字符串返回一个数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(msg -&gt;&#123;</span><br><span class="line">        	return Integer.parseInt(msg);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void test(Function&lt;String,Integer&gt; function)&#123;</span><br><span class="line">        Integer apply = function.apply(&quot;666&quot;);</span><br><span class="line">        System.out.println(&quot;apply = &quot; + apply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-Predicate"><a href="#2-4-Predicate" class="headerlink" title="2.4 Predicate"></a>2.4 Predicate</h4><p>有参且返回值为Boolean的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(msg -&gt; &#123;</span><br><span class="line">        	<span class="keyword">return</span> msg.length() &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;,<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Predicate&lt;String&gt; predicate,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = predicate.test(msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><h3 id="1、为什么要用方法引用"><a href="#1、为什么要用方法引用" class="headerlink" title="1、为什么要用方法引用"></a>1、为什么要用方法引用</h3><h4 id="1-1-lambda表达式冗余"><a href="#1-1-lambda表达式冗余" class="headerlink" title="1.1 lambda表达式冗余"></a>1.1 lambda表达式冗余</h4><p>在使用Lambda表达式的时候，也会出现代码冗余的情况，比如：用Lambda表达式求一个数组的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionRefTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printMax(a -&gt; &#123;</span><br><span class="line">            <span class="comment">// Lambda表达式中的代码和getTotal中的代码冗余了</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125; </span><br><span class="line">           System.out.println(<span class="string">&quot;数组之和：&quot;</span> + sum);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    /</span><br><span class="line">    **</span><br><span class="line">    * 求数组中的所有元素的和</span><br><span class="line">    * <span class="meta">@param</span> a</span><br><span class="line">    */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotal</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;数组之和：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(Consumer&lt;<span class="keyword">int</span>[]&gt; consumer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a= &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;</span><br><span class="line">        consumer.accept(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h4><p>​    因为在Lambda表达式中要执行的代码和我们另一个方法中的代码是一样的，这时就没有必要重写一份逻辑了，这时我们就可以“引用”重复代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionRefTest02 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        // :: 方法引用是JDK8中的新语法</span><br><span class="line">        printMax(FunctionRefTest02::getTotal);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    /</span><br><span class="line">    **</span><br><span class="line">    * 求数组中的所有元素的和</span><br><span class="line">    * @param a</span><br><span class="line">    */</span><br><span class="line">    public static void getTotal(int a[])&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">        	sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(&quot;数组之和：&quot; + sum);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    private static void printMax(Consumer&lt;int[]&gt; consumer)&#123;</span><br><span class="line">        int[] a= &#123;10,20,30,40,50,60&#125;;</span><br><span class="line">        consumer.accept(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:: 方法引用是JDK8中的新语法</p>
<h3 id="2、方法引用的格式"><a href="#2、方法引用的格式" class="headerlink" title="2、方法引用的格式"></a>2、方法引用的格式</h3><p>符号表示： <code>::</code> </p>
<p>符号说明：双冒号为方法引用运算符</p>
<p>应用场景：如果Lambda表达式所要实现的方案，已经有其他方法存在相同的方案，那么则可以使用方法引用</p>
<p>常见的引用方式：</p>
<ol>
<li>instanceName::methodName 对象::方法名</li>
<li>ClassName::staticMethodName 类名::静态方法</li>
<li>ClassName::methodName 类名::普通方法</li>
<li>ClassName::new 类名::new 调用的构造器</li>
<li>TypeName[]::new String[]::new 调用数组的构造器</li>
</ol>
<h4 id="2-1-对象名-方法名"><a href="#2-1-对象名-方法名" class="headerlink" title="2.1 对象名::方法名"></a>2.1 对象名::方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date now = <span class="keyword">new</span> Date();</span><br><span class="line">    Supplier&lt;Long&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> now.getTime();&#125;;</span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line">    <span class="comment">// 然后我们通过 方法引用 的方式来处理</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier1 = now::getTime;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>被引用的方法，参数要和接口中的抽象方法的参数一样</li>
<li>当接口抽象方法有返回值时，被引用的方法也必须有返回值</li>
</ol>
<h4 id="2-2-类名-静态方法名"><a href="#2-2-类名-静态方法名" class="headerlink" title="2.2 类名::静态方法名"></a>2.2 类名::静态方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Long&gt; supplier1 = ()-&gt;&#123;</span><br><span class="line">    	<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 方法引用 来实现</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier2 = System::currentTimeMillis;</span><br><span class="line">    System.out.println(supplier2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-类名-引用实例方法"><a href="#2-3-类名-引用实例方法" class="headerlink" title="2.3 类名::引用实例方法"></a>2.3 类名::引用实例方法</h4><p>类名引用实例方法是有前提的，实际上是拿第一个参数作为方法的调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;String,Integer&gt; function = (s)-&gt;&#123;</span><br><span class="line">    	<span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过方法引用来实现</span></span><br><span class="line">    Function&lt;String,Integer&gt; function1 = String::length;</span><br><span class="line">    System.out.println(function1.apply(<span class="string">&quot;hahahaha&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    BiFunction&lt;String,Integer,String&gt; function2 = String::substring;</span><br><span class="line">    String msg = function2.apply(<span class="string">&quot;HelloWorld&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-类名-构造器"><a href="#2-4-类名-构造器" class="headerlink" title="2.4 类名::构造器"></a>2.4 类名::构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Person&gt; sup = ()-&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> Person();&#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过方法引用来实现</span></span><br><span class="line">    Supplier&lt;Person&gt; sup1 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-数组-构造器"><a href="#2-5-数组-构造器" class="headerlink" title="2.5 数组::构造器"></a>2.5 数组::构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer,String[]&gt; fun1 = (len)-&gt;&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> String[len];</span><br><span class="line">    &#125;;</span><br><span class="line">    String[] a1 = fun1.apply(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的长度是：&quot;</span> + a1.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过方法引用调用数组的构造器</span></span><br><span class="line">    Function&lt;Integer,String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] a2 = fun2.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的长度是：&quot;</span> + a2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：方法引用是对Lambda表达式符合特定情况下的一种缩写方式，它使得我们的Lambda表达式更加的精简，也可以理解为lambda表达式的缩写形式，不过要注意的是方法引用只能引用已经存在的方法</p>
<h2 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="五、Stream API"></a>五、Stream API</h2><h3 id="1、集合处理数据的弊端"><a href="#1、集合处理数据的弊端" class="headerlink" title="1、集合处理数据的弊端"></a>1、集合处理数据的弊端</h3><p>当我们在需要对集合中的元素进行操作的时候，除了必需的添加，删除，获取外，最典型的操作就是集合遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 定义一个List集合</span></span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;成龙&quot;</span>,<span class="string">&quot;周星驰&quot;</span>);</span><br><span class="line">       <span class="comment">// 1.获取所有姓张的信息</span></span><br><span class="line">       List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;张&quot;</span>))&#123;</span><br><span class="line">        	list1.add(s);</span><br><span class="line">    	  &#125;</span><br><span class="line">    	&#125; </span><br><span class="line">        <span class="comment">// 2.获取名称长度为3的用户</span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                list2.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 输出所有的用户信息</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list2) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码针对与我们不同的需求总是一次次的循环循环循环.这时我们希望有更加高效的处理方式，这时我们就可以通过JDK8中提供的Stream API来解决这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个List集合</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;成龙&quot;</span>,<span class="string">&quot;周星驰&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.获取所有姓张的信息</span></span><br><span class="line">        <span class="comment">// 2.获取名称长度为3的用户</span></span><br><span class="line">        <span class="comment">// 3. 输出所有的用户信息</span></span><br><span class="line">            list.stream()</span><br><span class="line">                .filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(s-&gt;s.length() == <span class="number">3</span>)</span><br><span class="line">                .forEach(s-&gt;&#123;</span><br><span class="line">                	System.out.println(s);</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">            .filter(s-&gt;s.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的SteamAPI代码的含义：获取流，过滤张，过滤长度，逐一打印。代码相比于上面的写法更加简洁直观</p>
<h3 id="2、Stream流的获取方式"><a href="#2、Stream流的获取方式" class="headerlink" title="2、Stream流的获取方式"></a>2、Stream流的获取方式</h3><h4 id="2-1-根据Collection获取"><a href="#2-1-根据Collection获取" class="headerlink" title="2.1 根据Collection获取"></a>2.1 根据Collection获取</h4><p>集合有两个父接口，Collection接口和Map接口</p>
<p>首先，java.util.Collection 接口中加入了default方法 stream，也就是说Collection接口下的所有的实现都可以通过steam方法来获取Stream流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.stream();</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.stream();</span><br><span class="line">    Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">    vector.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map接口没有实现 stream，这时我们可以通过Map的keySet()、values()、entrySet()来获取流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream = map.keySet().stream(); <span class="comment">// key</span></span><br><span class="line">    Stream&lt;Object&gt; stream1 = map.values().stream(); <span class="comment">// value</span></span><br><span class="line">    Stream&lt;Map.Entry&lt;String, Object&gt;&gt; stream2 = map.entrySet().stream(); <span class="comment">//key和value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-通过Stream的of方法"><a href="#2-2-通过Stream的of方法" class="headerlink" title="2.2 通过Stream的of方法"></a>2.2 通过Stream的of方法</h4><p>在实际开发中我们不可避免的会操作到数组中的数据，所以Stream接口中提供了静态方法of</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; a1 = Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>);</span><br><span class="line">        String[] arr1 = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; arr11 = Stream.of(arr1);</span><br><span class="line">        Integer[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; arr21 = Stream.of(arr2);</span><br><span class="line">        arr21.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：基本数据类型的数组取流无法正常打印</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Stream.of(arr3).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 结果:[I@28d25987</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、Stream常用方法介绍"><a href="#3、Stream常用方法介绍" class="headerlink" title="3、Stream常用方法介绍"></a>3、Stream常用方法介绍</h3><p>Stream流模型的操作可以被分为两种：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th>方法作用</th>
<th>返回值类型</th>
<th>方法种类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">forEach</td>
<td>逐一处理</td>
<td>void</td>
<td>终结</td>
</tr>
<tr>
<td align="left">count</td>
<td>统计个数</td>
<td>long</td>
<td>终结</td>
</tr>
<tr>
<td align="left">match</td>
<td>是否匹配指定的条件</td>
<td>boolean</td>
<td>终结</td>
</tr>
<tr>
<td align="left">find</td>
<td>找到某些数据</td>
<td>Optional</td>
<td>终结</td>
</tr>
<tr>
<td align="left">max、min</td>
<td>最大值、最小值</td>
<td>Optional</td>
<td>终结</td>
</tr>
<tr>
<td align="left">reduce</td>
<td>求和、最大值、统计次数</td>
<td>T</td>
<td>终结</td>
</tr>
<tr>
<td align="left">filter</td>
<td>过滤</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">limit</td>
<td>取用前几个</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">skip</td>
<td>跳过前几个</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">map</td>
<td>映射</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">sorted</td>
<td>排序</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">distinct</td>
<td>去重</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
<tr>
<td align="left">concat</td>
<td>组合</td>
<td>Stream</td>
<td>函数拼接</td>
</tr>
</tbody></table>
<p><strong>终结方法：</strong>返回值类型不再是 Stream 类型的方法，不再支持链式调用</p>
<p><strong>非终结方法：</strong>返回值类型仍然是 Stream 类型的方法，支持链式调用</p>
<p><code>链式调用就是调用完一个函数后还能再继续调用其它函数，这样大大减少了代码量</code></p>
<h4 id="3-1-forEach"><a href="#3-1-forEach" class="headerlink" title="3.1 forEach"></a>3.1 forEach</h4><p>forEach用来遍历流中的数据的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法接收一个Consumer接口，会将每一个流元素交给函数处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-count"><a href="#3-2-count" class="headerlink" title="3.2 count"></a>3.2 count</h4><p>Stream流中的count方法用来统计其中的元素个数的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个long值，代表元素的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-filter"><a href="#3-3-filter" class="headerlink" title="3.3 filter"></a>3.3 filter</h4><p>可以通过filter方法将一个流转换成另一个子集流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该接口接收一个Predicate函数式接口参数作为筛选条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;dd&quot;</span>)</span><br><span class="line">    	.filter((s)-&gt;s.contains(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    	.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a2</span><br><span class="line">a3</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>

<h4 id="3-4-limit"><a href="#3-4-limit" class="headerlink" title="3.4 limit"></a>3.4 limit</h4><p>limit方法可以对流进行截取处理，截取前n个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数是一个long类型的数值，如果集合当前长度大于参数就进行截取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;dd&quot;</span>)</span><br><span class="line">       .limit(<span class="number">3</span>)</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a2</span><br><span class="line">a3</span><br></pre></td></tr></table></figure>

<h4 id="3-5-skip"><a href="#3-5-skip" class="headerlink" title="3.5 skip"></a>3.5 skip</h4><p>如果希望跳过前面几个元素，可以使用skip方法获取一个截取之后的新流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;dd&quot;</span>)</span><br><span class="line">    	.skip(<span class="number">3</span>)</span><br><span class="line">    	.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">aa</span><br><span class="line">dd</span><br></pre></td></tr></table></figure>

<h4 id="3-6-map"><a href="#3-6-map" class="headerlink" title="3.6 map"></a>3.6 map</h4><p>如果我们需要将流中的元素映射到另一个流中，可以使用map方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>)</span><br><span class="line">       .map(Integer::parseInt)</span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-sorted"><a href="#3-7-sorted" class="headerlink" title="3.7 sorted"></a>3.7 sorted</h4><p>如果需要将数据排序，可以使用sorted方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在使用时可以指定对应的排序规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;7&quot;</span>)</span><br><span class="line">       .map(Integer::parseInt)</span><br><span class="line">       .sorted((o1,o2)-&gt;o2-o1) <span class="comment">// 根据比较强指定排序规则，从大到小</span></span><br><span class="line">       .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-distinct"><a href="#3-8-distinct" class="headerlink" title="3.8 distinct"></a>3.8 distinct</h4><p>如果要去掉重复数据，可以使用distinct方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;,&quot;4&quot;,&quot;0&quot;,&quot;1&quot;,&quot;7&quot;)</span><br><span class="line">        .map(Integer::parseInt)</span><br><span class="line">        .sorted((o1,o2)-&gt;o2-o1) // 根据比较强指定排序规则，从大到小</span><br><span class="line">        .distinct() // 去掉重复的记录</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">	System.out.println(&quot;--------&quot;);</span><br><span class="line">	</span><br><span class="line">    Stream.of(</span><br><span class="line">            new Person(&quot;张三&quot;,18)</span><br><span class="line">            ,new Person(&quot;李四&quot;,22)</span><br><span class="line">            ,new Person(&quot;张三&quot;,18)</span><br><span class="line">        ).distinct()</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream流中的distinct方法对于基本数据类型是可以直接出重的，但是对于自定义类型，我们是需要重hashCode和equals方法来移除重复元素</p>
<h4 id="3-9-match"><a href="#3-9-match" class="headerlink" title="3.9 match"></a>3.9 match</h4><p>如果需要判断数据是否匹配指定的条件，可以使用match相关的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>; <span class="comment">// 元素是否有任意一个满足条件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>; <span class="comment">// 元素是否都满足条件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>; <span class="comment">// 元素是否都不满足条件</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">                .map(Integer::parseInt)</span><br><span class="line">                <span class="comment">//.allMatch(s -&gt; s &gt; 0)</span></span><br><span class="line">                <span class="comment">//.anyMatch(s -&gt; s &gt;4)</span></span><br><span class="line">                .noneMatch(s -&gt; s &gt; <span class="number">4</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-find"><a href="#3-10-find" class="headerlink" title="3.10 find"></a>3.10 find</h4><p>如果我们需要找到某些数据，可以使用find方法来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;   <span class="comment">//返回第一个元素</span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;    <span class="comment">//返回任意元素</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; first = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>,<span class="string">&quot;7&quot;</span>).findFirst();</span><br><span class="line">	 System.out.println(first.get());</span><br><span class="line">    </span><br><span class="line">	 Optional&lt;String&gt; any = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>,<span class="string">&quot;7&quot;</span>).findAny();</span><br><span class="line">	 System.out.println(any.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-11-max和min"><a href="#3-11-max和min" class="headerlink" title="3.11 max和min"></a>3.11 max和min</h4><p>如果我们想要获取最大值和最小值，那么可以使用max和min方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Optional&lt;Integer&gt; max = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">        .map(Integer::parseInt)</span><br><span class="line">        .max((o1,o2)-&gt;o1-o2);</span><br><span class="line">    System.out.println(max.get());</span><br><span class="line">    Optional&lt;Integer&gt; min = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">        .map(Integer::parseInt)</span><br><span class="line">        .min((o1,o2)-&gt;o1-o2);</span><br><span class="line">    System.out.println(min.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-12-reduce"><a href="#3-12-reduce" class="headerlink" title="3.12 reduce"></a>3.12 reduce</h4><p>如果需要将所有数据归纳得到一个数据，可以使用reduce方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// q</span></span><br><span class="line">    Integer sum = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取最大值</span></span><br><span class="line">    Integer max = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">        .reduce(<span class="number">0</span>, Math::max);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-13-map和reduce"><a href="#3-13-map和reduce" class="headerlink" title="3.13 map和reduce"></a>3.13 map和reduce</h4><p>​    在实际开发中我们经常会将map和reduce一块来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.求出所有年龄的总和</span></span><br><span class="line">    Integer sumAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).map(Person::getAge) <span class="comment">// 实现数据类型的转换，符合reduce对数据的要求</span></span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// reduce实现数据的处理</span></span><br><span class="line">    System.out.println(sumAge);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.求出所有年龄中的最大值</span></span><br><span class="line">    Integer maxAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).map(Person::getAge) </span><br><span class="line">        .reduce(<span class="number">0</span>, Math::max); </span><br><span class="line">	System.out.println(maxAge);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.统计字符 a 出现的次数</span></span><br><span class="line">    Integer count = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    	.map(ch -&gt; <span class="string">&quot;a&quot;</span>.equals(ch) ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    	.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">87</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="3-14-concat"><a href="#3-14-concat" class="headerlink" title="3.14 concat"></a>3.14 concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; stream2 = Stream.of(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过concat方法将两个流合并为一个新的流</span></span><br><span class="line">    Stream.concat(stream1,stream2).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-15-综合案例"><a href="#3-15-综合案例" class="headerlink" title="3.15 综合案例"></a>3.15 综合案例</h4><p>定义两个集合，然后在集合中存储多个用户名称。然后完成如下的操作：</p>
<ol>
<li>第一个队伍只保留姓名长度为3的成员</li>
<li>第一个队伍筛选之后只要前3个人</li>
<li>第二个队伍只要姓张的成员</li>
<li>第二个队伍筛选之后不要前两个人</li>
<li>将两个队伍合并为一个队伍</li>
<li>根据姓名创建Person对象</li>
<li>打印整个队伍的Person信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="string">&quot;宋远桥&quot;</span>, <span class="string">&quot;苏星河&quot;</span>, <span class="string">&quot;老子&quot;</span>,<span class="string">&quot;庄子&quot;</span>, <span class="string">&quot;孙子&quot;</span>, <span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;古力娜扎&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;赵丽颖&quot;</span>,<span class="string">&quot;张二狗&quot;</span>, <span class="string">&quot;张天爱&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 第一个队伍只保留姓名长度为3的成员</span></span><br><span class="line">    <span class="comment">// 2. 第一个队伍筛选之后只要前3个人</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = list1.stream().filter(s -&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 第二个队伍只要姓张的成员</span></span><br><span class="line">    <span class="comment">// 4. 第二个队伍筛选之后不要前两个人</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = list2.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 将两个队伍合并为一个队伍</span></span><br><span class="line">    <span class="comment">// 6. 根据姓名创建Person对象</span></span><br><span class="line">    <span class="comment">// 7. 打印整个队伍的Person信息</span></span><br><span class="line">    Stream.concat(stream1,stream2)</span><br><span class="line">        .map(Person::<span class="keyword">new</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;宋远桥&#x27;</span>, age=<span class="keyword">null</span>, height=<span class="keyword">null</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;苏星河&#x27;</span>, age=<span class="keyword">null</span>, height=<span class="keyword">null</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张二狗&#x27;</span>, age=<span class="keyword">null</span>, height=<span class="keyword">null</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张天爱&#x27;</span>, age=<span class="keyword">null</span>, height=<span class="keyword">null</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="keyword">null</span>, height=<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Stream结果收集"><a href="#4、Stream结果收集" class="headerlink" title="4、Stream结果收集"></a>4、Stream结果收集</h3><h4 id="4-1-结果收集到集合中"><a href="#4-1-结果收集到集合中" class="headerlink" title="4.1 结果收集到集合中"></a>4.1 结果收集到集合中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>,<span class="string">&quot;aa&quot;</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// 收集到Set集合中</span></span><br><span class="line">    Set&lt;String&gt; set = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要获取的类型为具体的集合，比如：ArrayList HashSet</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>)</span><br><span class="line">        .collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; hashSet = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>)</span><br><span class="line">        .collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-结果收集到数组中"><a href="#4-2-结果收集到数组中" class="headerlink" title="4.2 结果收集到数组中"></a>4.2 结果收集到数组中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] strings = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-对流中的数据做聚合计算"><a href="#4-3-对流中的数据做聚合计算" class="headerlink" title="4.3 对流中的数据做聚合计算"></a>4.3 对流中的数据做聚合计算</h4><p>​    当我们使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作，比如获得最大值，最小值，求和，平均值，统计数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取年龄的最大值</span></span><br><span class="line">    Optional&lt;Person&gt; maxAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).collect(Collectors.maxBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">    System.out.println(<span class="string">&quot;最大年龄：&quot;</span> + maxAge.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取年龄的最小值</span></span><br><span class="line">    Optional&lt;Person&gt; minAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge()));</span><br><span class="line">    System.out.println(<span class="string">&quot;最新年龄:&quot;</span> + minAge.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求所有人的年龄之和</span></span><br><span class="line">    Integer sumAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        )</span><br><span class="line">        .collect(Collectors.summingInt(Person::getAge));</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄总和：&quot;</span> + sumAge);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 年龄的平均值</span></span><br><span class="line">    Double avgAge = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).collect(Collectors.averagingInt(Person::getAge));</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄的平均值：&quot;</span> + avgAge);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计数量</span></span><br><span class="line">    Long count = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;王五&quot;</span>, <span class="number">15</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>)</span><br><span class="line">        ).filter(p -&gt; p.getAge() &gt; <span class="number">18</span>)</span><br><span class="line">        .collect(Collectors.counting());</span><br><span class="line">    System.out.println(<span class="string">&quot;满足条件的记录数:&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-对流中数据做分组操作"><a href="#4-4-对流中数据做分组操作" class="headerlink" title="4.4 对流中数据做分组操作"></a>4.4 对流中数据做分组操作</h4><p>​    当我们使用Stream流处理数据后，可以根据某个属性将数据分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 根据账号对数据进行分组</span></span><br><span class="line">    Map&lt;String, List&lt;Person&gt;&gt; map1 = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">175</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">177</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">14</span>, <span class="number">165</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">15</span>, <span class="number">166</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="number">182</span>)</span><br><span class="line">        ).collect(Collectors.groupingBy(Person::getName));</span><br><span class="line">    map1.forEach((k,v)-&gt; System.out.println( k + <span class="string">&quot;\t&quot;</span> + v));</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据年龄分组 如果大于等于18 成年否则未成年</span></span><br><span class="line">    Map&lt;String, List&lt;Person&gt;&gt; map2 = Stream.of(</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">175</span>)</span><br><span class="line">    , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">177</span>)</span><br><span class="line">    , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">14</span>, <span class="number">165</span>)</span><br><span class="line">    , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">15</span>, <span class="number">166</span>)</span><br><span class="line">    , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="number">182</span>)</span><br><span class="line">    ).collect(Collectors.groupingBy(p -&gt; p.getAge() &gt;= <span class="number">18</span> ? <span class="string">&quot;成年&quot;</span> : <span class="string">&quot;未成年&quot;</span>));</span><br><span class="line">    map2.forEach((k,v)-&gt; System.out.println(k +<span class="string">&quot; \t&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">李四 		[Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">22</span>, height=<span class="number">177</span>&#125;, Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">15</span>,height=<span class="number">166</span>&#125;]</span><br><span class="line">张三 		[Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>, height=<span class="number">175</span>&#125;, Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">14</span>,height=<span class="number">165</span>&#125;, Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">19</span>, height=<span class="number">182</span>&#125;]</span><br><span class="line">-----------</span><br><span class="line">未成年 	[Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">14</span>, height=<span class="number">165</span>&#125;, Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">15</span>,height=<span class="number">166</span>&#125;]</span><br><span class="line">成年 		[Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>, height=<span class="number">175</span>&#125;, Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">22</span>,height=<span class="number">177</span>&#125;, Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">19</span>, height=<span class="number">182</span>&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="4-5-对流中的数据做分区操作"><a href="#4-5-对流中的数据做分区操作" class="headerlink" title="4.5 对流中的数据做分区操作"></a>4.5 对流中的数据做分区操作</h4><p>​    Collectors.partitioningBy会根据值是否为true,把集合中的数据分割为两个列表，一个true列表，一个false列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;Boolean, List&lt;Person&gt;&gt; map = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">175</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">177</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">14</span>, <span class="number">165</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">15</span>, <span class="number">166</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="number">182</span>)</span><br><span class="line">        ).collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; <span class="number">18</span>));</span><br><span class="line">    map.forEach((k,v)-&gt; System.out.println(k + <span class="string">&quot;\t&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span> 	[Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>, height=<span class="number">175</span>&#125;, Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">14</span>,height=<span class="number">165</span>&#125;, Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">15</span>, height=<span class="number">166</span>&#125;]</span><br><span class="line"><span class="keyword">true</span> 	[Person&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">22</span>, height=<span class="number">177</span>&#125;, Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">19</span>,height=<span class="number">182</span>&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="4-6-对流中的数据做拼接"><a href="#4-6-对流中的数据做拼接" class="headerlink" title="4.6 对流中的数据做拼接"></a>4.6 对流中的数据做拼接</h4><p>​    Collectors.joining会根据指定的连接符，将所有的元素连接成一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">175</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">177</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">14</span>, <span class="number">165</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">15</span>, <span class="number">166</span>)</span><br><span class="line">        , <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="number">182</span>)</span><br><span class="line">        ).map(Person::getName)</span><br><span class="line">        .collect(Collectors.joining());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 张三李四张三李四张三</span></span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、并行的Stream流"><a href="#5、并行的Stream流" class="headerlink" title="5、并行的Stream流"></a>5、并行的Stream流</h3><h4 id="5-1-串行的Stream流"><a href="#5-1-串行的Stream流" class="headerlink" title="5.1 串行的Stream流"></a>5.1 串行的Stream流</h4><p>我们前面使用的Stream流都是串行，也就是在一个线程上面执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Stream.of(<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">        .filter(s-&gt;&#123;</span><br><span class="line">        	System.out.println(Thread.currentThread() + <span class="string">&quot;&quot;</span> + s);</span><br><span class="line">        	<span class="keyword">return</span> s &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;).count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">5</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">6</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">8</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">3</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">1</span></span><br><span class="line">Thread[main,<span class="number">5</span>,main]<span class="number">6</span></span><br><span class="line">count=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-并行流"><a href="#5-2-并行流" class="headerlink" title="5.2 并行流"></a>5.2 并行流</h4><p>parallelStream其实就是一个并行执行的流，它通过默认的ForkJoinPool，可以提高多线程任务的速度</p>
<h5 id="5-2-1-获取并行流"><a href="#5-2-1-获取并行流" class="headerlink" title="5.2.1 获取并行流"></a>5.2.1 获取并行流</h5><p>我们可以通过两种方式来获取并行流。</p>
<ol>
<li>通过Collection接口中的parallelStream方法来获取</li>
<li>通过已有的串行流转换为并行流(parallel)</li>
</ol>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 通过Collection集合接口直接获取并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; integerStream = list.parallelStream();</span><br><span class="line">    <span class="comment">// 将已有的串行流转换为并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; parallel = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-并行流操作"><a href="#5-2-2-并行流操作" class="headerlink" title="5.2.2 并行流操作"></a>5.2.2 并行流操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>)</span><br><span class="line">        .parallel() <span class="comment">// 将流转换为并发流，Stream处理的时候就会通过多线程处理</span></span><br><span class="line">        .filter(s-&gt;&#123;</span><br><span class="line">        	System.out.println(Thread.currentThread() + <span class="string">&quot; s=&quot;</span> +s);</span><br><span class="line">        	<span class="keyword">return</span> s &gt; <span class="number">2</span>;</span><br><span class="line">        &#125;).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main] s=<span class="number">1</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">2</span>,<span class="number">5</span>,main] s=<span class="number">9</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">6</span>,<span class="number">5</span>,main] s=<span class="number">6</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">13</span>,<span class="number">5</span>,main] s=<span class="number">2</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">9</span>,<span class="number">5</span>,main] s=<span class="number">4</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">4</span>,<span class="number">5</span>,main] s=<span class="number">5</span></span><br><span class="line">Thread[ForkJoinPool.commonPool-worker-<span class="number">11</span>,<span class="number">5</span>,main] s=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-并行流和串行流对比"><a href="#5-3-并行流和串行流对比" class="headerlink" title="5.3 并行流和串行流对比"></a>5.3 并行流和串行流对比</h4><p>我们通过for循环，串行Stream流，并行Stream流来对5亿个数字求和，来看消耗时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> times = <span class="number">500000000</span>;</span><br><span class="line"></span><br><span class="line">    /</span><br><span class="line">    **</span><br><span class="line">    * 普通<span class="keyword">for</span>循环 消耗时间：138ms</span><br><span class="line">    */</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通for循环:&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            	res += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">    /</span><br><span class="line">    **</span><br><span class="line">    * 串行流处理 消耗时间：203ms</span><br><span class="line">    */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;串行流：&quot;</span>);</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>,times)</span><br><span class="line">        	.reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /</span><br><span class="line">    **</span><br><span class="line">    * 并行流处理 消耗时间：84ms</span><br><span class="line">    */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;并行流：&quot;</span>);</span><br><span class="line">        LongStream.rangeClosed(<span class="number">0</span>,times)</span><br><span class="line">        	.parallel()</span><br><span class="line">        	.reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到parallelStream的效率是最高的。Stream并行处理的过程会分而治之，也就是将一个大的任务切分成了多个小任务，这表示每个任务都是一个线程操作</p>
<h4 id="5-4-线程安全问题"><a href="#5-4-线程安全问题" class="headerlink" title="5.4 线程安全问题"></a>5.4 线程安全问题</h4><p>在多线程的处理下，就有可能出现数据安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    	list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.parallelStream()</span><br><span class="line">    	.forEach(listNew::add);</span><br><span class="line">    System.out.println(listNew.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能报异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at</span><br><span class="line">sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorI</span><br><span class="line">mpl.java:62)</span><br><span class="line">	at</span><br><span class="line">sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorA</span><br><span class="line">ccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">    at</span><br><span class="line">java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:598)</span><br><span class="line">....</span><br><span class="line">Caused by: java.lang.ArrayIndexOutOfBoundsException: 366</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:463)</span><br></pre></td></tr></table></figure>

<p>针对这个问题，我们的解决方案有哪些呢？</p>
<ol>
<li>加同步锁</li>
<li>使用线程安全的容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加同步锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .forEach(i-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            	listNew.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    System.out.println(listNew.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用线程安全的容器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">        .parallel()</span><br><span class="line">        .forEach(i -&gt; v.add(i));</span><br><span class="line">    System.out.println(v.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Optional类"><a href="#六、Optional类" class="headerlink" title="六、Optional类"></a>六、Optional类</h2><p>Optional类是解决空指针的问题</p>
<h3 id="1、以前对null的处理"><a href="#1、以前对null的处理" class="headerlink" title="1、以前对null的处理"></a>1、以前对null的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* 根据Person对象 将name转换为大写并返回</span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">    	String name = person.getName();</span><br><span class="line">    	<span class="keyword">if</span>(name != <span class="keyword">null</span>)&#123;</span><br><span class="line">    		<span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Optional类"><a href="#2、Optional类" class="headerlink" title="2、Optional类"></a>2、Optional类</h3><p>Optional是一个没有子类的工具类，Optional是一个可以为null的容器对象，它的主要作用就是为了避免Null检查，防止NullpointerException</p>
<h3 id="3、Optional的基本使用"><a href="#3、Optional的基本使用" class="headerlink" title="3、Optional的基本使用"></a>3、Optional的基本使用</h3><p>Optional对象的创建方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一种方式 通过of方法 of方法是不支持null的</span></span><br><span class="line">    Optional&lt;String&gt; op1 = Optional.of(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="comment">//Optional&lt;Object&gt; op2 = Optional.of(null);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式通过 ofNullable方法 支持null</span></span><br><span class="line">    Optional&lt;String&gt; op3 = Optional.ofNullable(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    Optional&lt;Object&gt; op4 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 第三种方式 通过empty方法直接创建一个空的Optional对象</span></span><br><span class="line">    Optional&lt;Object&gt; op5 = Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Optional的常用方法"><a href="#4、Optional的常用方法" class="headerlink" title="4、Optional的常用方法"></a>4、Optional的常用方法</h3><ol>
<li>isPresent()：判断是否包含值，包含值返回true，不包含值返回false</li>
<li>get()：如果Optional有值则返回，否则会抛出NoSuchElementException异常。get()通常和isPresent方法一块使用</li>
<li>orElse(T t)：如果调用对象包含值，就返回该值，否则返回t</li>
<li>orElseGet(Supplier s)：如果调用对象包含值，就返回该值，否则返回 Lambda表达式的返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">**</span><br><span class="line">* 根据Person对象 将name转换为大写并返回</span><br><span class="line">* 通过Optional方式实现</span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameForOptional</span><span class="params">(Optional&lt;Person&gt; op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op.isPresent())&#123;</span><br><span class="line">       String msg = op.map(Person::getName)</span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .orElse(<span class="string">&quot;空值&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/</span><br><span class="line">**</span><br><span class="line">* 根据Person对象 将name转换为大写并返回</span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">    	String name = person.getName();</span><br><span class="line">    	<span class="keyword">if</span>(name != <span class="keyword">null</span>)&#123;</span><br><span class="line">    		<span class="keyword">return</span> name.toUpperCase();</span><br><span class="line">   		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   		&#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、新时间日期API"><a href="#七、新时间日期API" class="headerlink" title="七、新时间日期API"></a>七、新时间日期API</h2><h3 id="1、旧版日期时间的问题"><a href="#1、旧版日期时间的问题" class="headerlink" title="1、旧版日期时间的问题"></a>1、旧版日期时间的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1.设计不合理</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2021</span>,<span class="number">05</span>,<span class="number">05</span>);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.时间格式化和解析操作是线程不安全的</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(sdf.parse(<span class="string">&quot;2021-05-06&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设计不合理，在java.util和java.sql的包中都有日期类，java.util.Date同时包含日期和时间的，而java.sql.Date仅仅包含日期，此外用于格式化和解析的类在java.text包下</li>
<li>非线程安全，java.util.Date是非线程安全的，所有的日期类都是可变的，这是java日期类最大的问题之一</li>
<li>时区处理麻烦，日期类并不提供国际化，没有时区支持</li>
</ol>
<h3 id="2、新日期时间API介绍"><a href="#2、新日期时间API介绍" class="headerlink" title="2、新日期时间API介绍"></a>2、新日期时间API介绍</h3><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于<br>java.time 包中，下面是一些关键类：</p>
<ul>
<li>LocalDate：表示日期，包含年月日，格式为 2019-10-16</li>
<li>LocalTime：表示时间，包含时分秒，格式为 16:38:54.158549300</li>
<li>LocalDateTime：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</li>
<li>DateTimeFormatter：日期时间格式化类。</li>
<li>Instant：时间戳，表示一个特定的时间瞬间</li>
<li>Duration：用于计算2个时间(LocalTime，时分秒)的距离</li>
<li>Period：用于计算2个日期(LocalDate，年月日)的距离</li>
<li>ZonedDateTime：包含时区的时间</li>
</ul>
<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，<br>闰年是366天。此外Java 8还提供了4套其他历法，分别是：</p>
<ul>
<li>ThaiBuddhistDate：泰国佛教历</li>
<li>MinguoDate：中华民国历</li>
<li>JapaneseDate：日本历</li>
<li>HijrahDate：伊斯兰历  </li>
</ul>
<h4 id="2-1-日期时间的常见操作"><a href="#2-1-日期时间的常见操作" class="headerlink" title="2.1 日期时间的常见操作"></a>2.1 日期时间的常见操作</h4><p>​    LocalDate，LocalTime以及LocalDateTime的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建指定的日期</span></span><br><span class="line">    LocalDate date1 = LocalDate.of(<span class="number">2021</span>, <span class="number">05</span>, <span class="number">06</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;date1 = &quot;</span>+date1);</span><br><span class="line">    <span class="comment">// 2.得到当前的日期</span></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span>+now);</span><br><span class="line">    <span class="comment">// 3.根据LocalDate对象获取对应的日期信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年：&quot;</span> + now.getYear());</span><br><span class="line">    System.out.println(<span class="string">&quot;月：&quot;</span> + now.getMonth().getValue());</span><br><span class="line">    System.out.println(<span class="string">&quot;日：&quot;</span> + now.getDayOfMonth());</span><br><span class="line">    System.out.println(<span class="string">&quot;星期：&quot;</span> + now.getDayOfWeek().getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.得到指定的时间</span></span><br><span class="line">    LocalTime time = LocalTime.of(<span class="number">5</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">23145</span>);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="comment">// 2.获取当前的时间</span></span><br><span class="line">    LocalTime now = LocalTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="comment">// 3.获取时间信息</span></span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">    System.out.println(now.getMinute());</span><br><span class="line">    System.out.println(now.getSecond());</span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-日期时间的修改和比较"><a href="#2-2-日期时间的修改和比较" class="headerlink" title="2.2 日期时间的修改和比较"></a>2.2 日期时间的修改和比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span>+now);</span><br><span class="line">    <span class="comment">// 对日期时间的修改，对已存在的LocalDate对象，并不会修改原来的信息</span></span><br><span class="line">    LocalDateTime localDateTime = now.withYear(<span class="number">1998</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;now :&quot;</span>+now);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后的：&quot;</span> + localDateTime);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;月份：&quot;</span> + now.withMonth(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;天：&quot;</span> + now.withDayOfMonth(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;小时：&quot;</span> + now.withHour(<span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;分钟:&quot;</span> + now.withMinute(<span class="number">15</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在当前日期时间的基础上 加上或者减去指定的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;两天后:&quot;</span> + now.plusDays(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;10年后:&quot;</span>+now.plusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;6个月后 = &quot;</span> + now.plusMonths(<span class="number">6</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;10年前 = &quot;</span> + now.minusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;半年前 = &quot;</span> + now.minusMonths(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;一周前 = &quot;</span> + now.minusDays(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    LocalDate date = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在JDK8中要实现日期的比较 isAfter isBefore isEqual 通过这几个方法来直接比较</span></span><br><span class="line">    System.out.println(now.isAfter(date)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(now.isBefore(date)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(now.isEqual(date)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在进行日期时间修改的时候，原来的 LocalDate 对象是不会被修改，每次操作都是返回了一个新的LocalDate对象，所以在多线程场景下是数据安全的</p>
<h4 id="2-3-格式化和解析操作"><a href="#2-3-格式化和解析操作" class="headerlink" title="2.3 格式化和解析操作"></a>2.3 格式化和解析操作</h4><p>在JDK8中我们可以通过 <code>java.time.format.DateTimeFormatter</code> 类可以进行日期的解析和格式化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 指定格式 使用系统默认的格式 2021-05-27T16:16:38.139</span></span><br><span class="line">    DateTimeFormatter isoLocalDateTime =</span><br><span class="line">    DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">// 将日期时间转换为字符串</span></span><br><span class="line">    String format = now.format(isoLocalDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 ofPattern 方法来指定特定的格式</span></span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String format1 = now.format(dateTimeFormatter);</span><br><span class="line">    <span class="comment">// 2021-05-27 16:16:38</span></span><br><span class="line">    System.out.println(<span class="string">&quot;format1 = &quot;</span> + format1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字符串解析为一个日期时间类型</span></span><br><span class="line">    LocalDateTime parse = LocalDateTime.parse(<span class="string">&quot;1997-05-06 22:45:16&quot;</span>,dateTimeFormatter);</span><br><span class="line">    <span class="comment">// parse = 1997-05-06T22:45:16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-计算日期时间差"><a href="#2-4-计算日期时间差" class="headerlink" title="2.4 计算日期时间差"></a>2.4 计算日期时间差</h4><p>JDK8中提供了两个工具类Duration/Period：计算日期时间差</p>
<ol>
<li>Duration：用来计算两个时间差(LocalTime)</li>
<li>Period:用来计算两个日期差(LocalDate)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算时间差</span></span><br><span class="line">    LocalTime now = LocalTime.now();</span><br><span class="line">    LocalTime time = LocalTime.of(<span class="number">22</span>, <span class="number">48</span>, <span class="number">59</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    <span class="comment">// 通过Duration来计算时间差</span></span><br><span class="line">    Duration duration = Duration.between(now, time);</span><br><span class="line">    System.out.println(duration.toDays()); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(duration.toHours()); <span class="comment">// 6</span></span><br><span class="line">    System.out.println(duration.toMinutes()); <span class="comment">// 368</span></span><br><span class="line">    System.out.println(duration.toMillis()); <span class="comment">// 22124240</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算日期差</span></span><br><span class="line">    LocalDate nowDate = LocalDate.now();</span><br><span class="line">    LocalDate date = LocalDate.of(<span class="number">1997</span>, <span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line">    Period period = Period.between(date, nowDate);</span><br><span class="line">    System.out.println(period.getYears()); <span class="comment">// 23</span></span><br><span class="line">    System.out.println(period.getMonths()); <span class="comment">// 5</span></span><br><span class="line">    System.out.println(period.getDays()); <span class="comment">// 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-日期时间的地区"><a href="#2-5-日期时间的地区" class="headerlink" title="2.5 日期时间的地区"></a>2.5 日期时间的地区</h4><p>Java8 中加入了对时区的支持，LocalDate、LocalTime、LocalDateTime是不带时区的，带时区的日期时间类分别为：ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，ID的格式为 “区域/城市” 。例如 ：Asia/Shanghai 等<br>ZoneId：该类中包含了所有的时区信息  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间，中国使用东八区，比标准时间早8小时</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now); <span class="comment">// 2021-05-27T17:17:06.951</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取国际标准时间</span></span><br><span class="line">    ZonedDateTime bz = ZonedDateTime.now(Clock.systemUTC());</span><br><span class="line">    System.out.println(<span class="string">&quot;bz = &quot;</span> + bz); <span class="comment">// 2021-05-27T09:17:06.952Z</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取纽约时间</span></span><br><span class="line">    ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;now2 = &quot;</span> + now2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK新的日期和时间的优势：</p>
<ol>
<li>新版日期时间API中，日期和时间对象是不可变，操作日期不会影响原来的值，而是生成一个新的<br>实例</li>
<li>线程安全</li>
<li>加入对时区的支持</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/jdk%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag"><i class="fa fa-tag"></i> jdk新特性</a>
              <a href="/tags/jdk8/" rel="tag"><i class="fa fa-tag"></i> jdk8</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/437.html" rel="prev" title="操作系统">
      <i class="fa fa-chevron-left"></i> 操作系统
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/cacd.html" rel="next" title="计算机组成原理">
      计算机组成原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">JDK8新特性使用方法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">一、Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">1、匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-text">2、需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="nav-text">3、Lambda表达式初体验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Lambda%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-text">4、Lambda的语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-Lambda%E7%BB%83%E4%B9%A01"><span class="nav-text">4.1 Lambda练习1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Lambda%E7%BB%83%E4%B9%A02"><span class="nav-text">4.2 Lambda练习2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95"><span class="nav-text">5、Lambda表达式的省略写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="nav-text">6、Lambda表达式的使用前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81Lambda%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">7、Lambda和匿名内部类的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">二、接口中新增的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81JDK8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B0%E5%A2%9E"><span class="nav-text">1、JDK8中接口的新增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-text">2、默认方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A2%9E%E5%8A%A0%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-text">2.1 为什么要增加默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.2 默认方法的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">3、静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">4、两者的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">三、函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="nav-text">1、函数式接口的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="nav-text">2、函数式接口介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Supplier"><span class="nav-text">2.1 Supplier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Consumer"><span class="nav-text">2.2 Consumer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Function"><span class="nav-text">2.3 Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-Predicate"><span class="nav-text">2.4 Predicate</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-text">四、方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-text">1、为什么要用方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%97%E4%BD%99"><span class="nav-text">1.1 lambda表达式冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2 解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">2、方法引用的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%AF%B9%E8%B1%A1%E5%90%8D-%E6%96%B9%E6%B3%95%E5%90%8D"><span class="nav-text">2.1 对象名::方法名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E7%B1%BB%E5%90%8D-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%90%8D"><span class="nav-text">2.2 类名::静态方法名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E7%B1%BB%E5%90%8D-%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">2.3 类名::引用实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E7%B1%BB%E5%90%8D-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">2.4 类名::构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%95%B0%E7%BB%84-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">2.5 数组::构造器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81Stream-API"><span class="nav-text">五、Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-text">1、集合处理数据的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Stream%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-text">2、Stream流的获取方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A0%B9%E6%8D%AECollection%E8%8E%B7%E5%8F%96"><span class="nav-text">2.1 根据Collection获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E9%80%9A%E8%BF%87Stream%E7%9A%84of%E6%96%B9%E6%B3%95"><span class="nav-text">2.2 通过Stream的of方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Stream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">3、Stream常用方法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-forEach"><span class="nav-text">3.1 forEach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-count"><span class="nav-text">3.2 count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-filter"><span class="nav-text">3.3 filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-limit"><span class="nav-text">3.4 limit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-skip"><span class="nav-text">3.5 skip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-map"><span class="nav-text">3.6 map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-sorted"><span class="nav-text">3.7 sorted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-distinct"><span class="nav-text">3.8 distinct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-match"><span class="nav-text">3.9 match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-find"><span class="nav-text">3.10 find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-11-max%E5%92%8Cmin"><span class="nav-text">3.11 max和min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-reduce"><span class="nav-text">3.12 reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-13-map%E5%92%8Creduce"><span class="nav-text">3.13 map和reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-14-concat"><span class="nav-text">3.14 concat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-15-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="nav-text">3.15 综合案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Stream%E7%BB%93%E6%9E%9C%E6%94%B6%E9%9B%86"><span class="nav-text">4、Stream结果收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E7%BB%93%E6%9E%9C%E6%94%B6%E9%9B%86%E5%88%B0%E9%9B%86%E5%90%88%E4%B8%AD"><span class="nav-text">4.1 结果收集到集合中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E7%BB%93%E6%9E%9C%E6%94%B6%E9%9B%86%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="nav-text">4.2 结果收集到数组中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%81%9A%E8%81%9A%E5%90%88%E8%AE%A1%E7%AE%97"><span class="nav-text">4.3 对流中的数据做聚合计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E5%AF%B9%E6%B5%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%81%9A%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="nav-text">4.4 对流中数据做分组操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%81%9A%E5%88%86%E5%8C%BA%E6%93%8D%E4%BD%9C"><span class="nav-text">4.5 对流中的数据做分区操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%81%9A%E6%8B%BC%E6%8E%A5"><span class="nav-text">4.6 对流中的数据做拼接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%B9%B6%E8%A1%8C%E7%9A%84Stream%E6%B5%81"><span class="nav-text">5、并行的Stream流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E4%B8%B2%E8%A1%8C%E7%9A%84Stream%E6%B5%81"><span class="nav-text">5.1 串行的Stream流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="nav-text">5.2 并行流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="nav-text">5.2.1 获取并行流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="nav-text">5.2.2 并行流操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%92%8C%E4%B8%B2%E8%A1%8C%E6%B5%81%E5%AF%B9%E6%AF%94"><span class="nav-text">5.3 并行流和串行流对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">5.4 线程安全问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81Optional%E7%B1%BB"><span class="nav-text">六、Optional类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%A5%E5%89%8D%E5%AF%B9null%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">1、以前对null的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Optional%E7%B1%BB"><span class="nav-text">2、Optional类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Optional%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">3、Optional的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Optional%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">4、Optional的常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%96%B0%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI"><span class="nav-text">七、新时间日期API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%97%A7%E7%89%88%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">1、旧版日期时间的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%E4%BB%8B%E7%BB%8D"><span class="nav-text">2、新日期时间API介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="nav-text">2.1 日期时间的常见操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%AF%94%E8%BE%83"><span class="nav-text">2.2 日期时间的修改和比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90%E6%93%8D%E4%BD%9C"><span class="nav-text">2.3 格式化和解析操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="nav-text">2.4 计算日期时间差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E5%9C%B0%E5%8C%BA"><span class="nav-text">2.5 日期时间的地区</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuumiy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yuumiy</p>
  <div class="site-description" itemprop="description">coding就是生产力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuumiy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuumiy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:115274737@qq.com" title="E-Mail → mailto:115274737@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://yuumiy.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;yuumiy.blog.csdn.net" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuumiy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">376k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:42</span>
</div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("08/10/2021 12:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
</script>

<script async src="/js/busuanzi.pure.mini.js"></script>
<span><br></span>	

<span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
</span>
<span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
    <span class="post-meta-divider">|</span>
<span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
</span>
    <span>总访问量&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/js/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'PuhblTYT44STCX6Edvpd76zF-gzGzoHsz',
      appKey     : '43DKcrM2QNBca1Ww68fepMOV',
      placeholder: "填写邮箱作者能够及时反馈，欢迎评论哦(๑•̀ㅂ•́)و✧",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
