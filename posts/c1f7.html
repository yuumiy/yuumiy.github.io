<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="NmvL2aBrGRwi3CzraBejtkwEbHmmH-7u73OJj3FMOoc">
  <meta name="msvalidate.01" content="5DB1ECD7406CD70A251CF96C939178B9">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuumiy.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java新特性介绍Java 8是Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java并没有就此止步，而是继续不断发展壮大，几乎每隔6个月，就会冒出一个新版本，最新的版本已经快要迭代到Java 20了，与Java 8相差了足足十来个版本，但是由于Java 8的稳定和生态完善（目前仍是LTS长期维护版本），依然有很多公司在坚持使用Java 8，不过随">
<meta property="og:type" content="article">
<meta property="og:title" content="jdk9-17 新特性">
<meta property="og:url" content="https://yuumiy.github.io/posts/c1f7.html">
<meta property="og:site_name" content="岛田悠米">
<meta property="og:description" content="Java新特性介绍Java 8是Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java并没有就此止步，而是继续不断发展壮大，几乎每隔6个月，就会冒出一个新版本，最新的版本已经快要迭代到Java 20了，与Java 8相差了足足十来个版本，但是由于Java 8的稳定和生态完善（目前仍是LTS长期维护版本），依然有很多公司在坚持使用Java 8，不过随">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pm4fpasnj21e202qdgc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofan3qvxj21b409qjs3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofcn7rt7j219009y3za.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofzqina8j21lo0bymyz.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2og24c18zj216o07gwf7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogarnv3hj21oi0bewgd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogb52z1fj214203ejrl.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ohbps200j22l008qgpe.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ois6anujj21mu09075b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2oj4ivmi3j21kw08ujsm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2njtdxyj21gu09iabi.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2pvizv2j21cu0b275z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2widxrbj22l608cwip.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p3zb45vqj225w0qowlb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p44huvl1j21tk0bcmzz.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p46lqnndj21au0fu0ug.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p8zzjlfdj20v204yaaf.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p91l5635j212609qt8z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p949kt5nj20ze06sdg8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p986jzkdj215608074z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p998buwcj217m0a4t9r.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9cn6p6qj20wy042t8s.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9dlqiucj20rw03274b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9ymylq6j21k00ggact.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe3mpaw5j210u054jrw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pdwq4g2aj218e0b4jsh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe66iavlj216y0963z1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppu61uu4j211w05m3z0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppvf70n0j213g05m3yu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9pg4bvdj22920jcq83.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9qp1af0j220s0loaf5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9uh6barj21k40b40w3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9vgs183j22b60esdmg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qacy37g6j22bs0psjwj.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qawt5acvj21ci0u0tcg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qsvu3u7dj21zw0nawhc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtu8ym7pj218008w3z2.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtvm8z1wj21e008kdgm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qufj2gt9j21da0bowg5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qukskyh6j21a602mgm0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qunhkgrcj21lc042my7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qve5yx6tj219u086ab5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qvfdhp6oj219001s3yo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5p7u49j216i05074q.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5zg837j2130050jrz.jpg">
<meta property="article:published_time" content="2022-09-15T15:43:49.000Z">
<meta property="article:modified_time" content="2022-09-15T15:43:49.000Z">
<meta property="article:author" content="Yuumiy">
<meta property="article:tag" content="jdk新特性">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pm4fpasnj21e202qdgc.jpg">

<link rel="canonical" href="https://yuumiy.github.io/posts/c1f7.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>jdk9-17 新特性 | 岛田悠米</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="岛田悠米" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">岛田悠米</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心中有梦 不负韶华</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuumiy.github.io/posts/c1f7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yuumiy">
      <meta itemprop="description" content="coding就是生产力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岛田悠米">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jdk9-17 新特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-15 23:43:49" itemprop="dateCreated datePublished" datetime="2022-09-15T23:43:49+08:00">2022-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          
            <span id="/posts/c1f7.html" class="post-meta-item leancloud_visitors" data-flag-title="jdk9-17 新特性" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/posts/c1f7.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/c1f7.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer" />

<h1 id="Java新特性介绍"><a href="#Java新特性介绍" class="headerlink" title="Java新特性介绍"></a>Java新特性介绍</h1><p>Java 8是Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java并没有就此止步，而是继续不断发展壮大，几乎每隔6个月，就会冒出一个新版本，最新的版本已经快要迭代到Java 20了，与Java 8相差了足足十来个版本，但是由于Java 8的稳定和生态完善（目前仍是LTS长期维护版本），依然有很多公司在坚持使用Java 8，不过随着SpringBoot 3.0的到来，现在强制要求使用Java 17版本（同样也是LTS长期维护版本），下一个Java版本的时代，或许已经临近了。</p>
<p>​<span id="more"></span></p>
<h2 id="Java-8-关键特性回顾"><a href="#Java-8-关键特性回顾" class="headerlink" title="Java 8 关键特性回顾"></a>Java 8 关键特性回顾</h2><p>在开始之前，我们先来回顾一下Java 8中学习的Lambda表达式和Optional类，有关Stream API请各位小伙伴回顾一下Java SE篇视频教程，这里不再进行介绍。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Java 8之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来搞事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;   <span class="comment">//创建一个实现Runnable的匿名内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">//具体的实现逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Thread时，我们需要传入一个Runnable接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在<code>run()</code>方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p>
<p>在Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减，实际上我们进行观察会发现，真正有用的那一部分代码，实际上就是我们对<code>run()</code>方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，那么我们能否针对于这种情况进行优化呢？我们现在只需要一个简短的lambda表达式即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//只需留下我们需要具体实现的方法体</span></span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于<code>() ‐&gt; &#123; 代码语句 &#125;</code>的形式进行替换即可。是不是感觉瞬间代码清爽了N倍？</p>
<p>当然这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p>
<blockquote>
<p>但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过<code>invokedynamic</code>指令实现的，不难发现，匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在我们想新建一个线程来做事情</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();   <span class="comment">//这里我们拋个异常看看</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pm4fpasnj21e202qdgc.jpg" alt="image-20220529214948350"></p>
<p>可以看到，实际上是Main类中的<code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如Runnable接口需要一个方法体对它的<code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p>
</blockquote>
<p>我们来看一下Lambda表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<p>比如我们之前使用的Runable类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>   <span class="comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;   <span class="comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Runable的的匿名内部类实现，就可以简写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;    &#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以写一个玩玩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;   <span class="comment">//接口类型</span></span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;    <span class="comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的Lambda表达式的实现就可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test = (Integer i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;  <span class="comment">//这里我们就简单将i转换为字符串形式</span></span><br></pre></td></tr></table></figure>

<p>不过还可以进行优化，首先方法参数类型是可以省略的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test = (i) -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test = i -&gt; &#123; <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test test = i -&gt; i+<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，相比我们之前直接去编写一个匿名内部类，是不是简介了很多很多。当然，除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">test</span><span class="params">(Integer i)</span></span>;   <span class="comment">//接口中的定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;   <span class="comment">//现在有一个静态方法，刚好匹配接口中抽象方法的返回值和参数列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们可以直接将此方法，作为lambda表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来，这也是为什么前面说<code>是我们为所需要的接口提供了一个方法作为它的实现</code>，是不是越来越体会到这句话的精髓了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = Main::impl;    <span class="comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">impl</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要对一个数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;   <span class="comment">//来个数组</span></span><br><span class="line">    Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;   <span class="comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(array));   <span class="comment">//按从小到大的顺序排列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，Integer类中有一个叫做<code>compare</code>的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是一个静态方法，但是它却和<code>Comparator</code>需要实现的方法返回值和参数定义一模一样，所以，懂的都懂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compare);   <span class="comment">//直接指定一手，效果和上面是一模一样</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么要是不是静态方法而是普通的成员方法呢？我们注意到Comparator要求我们实现的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1 - o2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中o1和o2都是Integer类型的，我们发现Integer类中有一个<code>compareTo</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只不过这个方法并不是静态的，而是对象所有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);   <span class="comment">//这样进行比较也行，和上面效果依然是一样的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<p>但是此时我们会发现，IDEA提示我们可以缩写，这是为什么呢？实际上，当我们使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数，也就是说，此时，<code>o1</code>作为目标对象，<code>o2</code>作为参数，正好匹配了<code>compareTo</code>方法，所以，直接缩写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, Integer::compareTo);  <span class="comment">//注意这里调用的不是静态方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Main mainObject = <span class="keyword">new</span> Main();</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(array, mainObject::reserve);  <span class="comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reserve</span><span class="params">(Integer a, Integer b)</span></span>&#123;  <span class="comment">//现在Main类中有一个刚好匹配的方法</span></span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，类的构造方法同样可以作为方法引用传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(String str)</span></span>;   <span class="comment">//现在我们需要一个参数为String返回值为String的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，String类中刚好有一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;   <span class="comment">//由于String类的构造方法返回的肯定是一个String类型的对象，且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span></span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = original.coder;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是乎：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test test = String::<span class="keyword">new</span>;   <span class="comment">//没错，构造方法直接使用new关键字就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以，还请各位小伙伴自行探索了。Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体请回顾一下JavaSE篇视频教程。</p>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。我们先来看看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;   <span class="comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span></span><br><span class="line">    System.out.println(str.toLowerCase());  <span class="comment">//那太简单了吧，直接转换打印一气呵成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样实现的话，我们少考虑了一个问题，万一给进来的<code>str</code>是<code>null</code>呢？如果是<code>null</code>的话，在调用<code>toLowerCase</code>方法时岂不是直接空指针异常了？所以我们还得判空一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决，这时，Optional来了，我们可以将任何的变量包装进Optional类中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(s -&gt; &#123;   <span class="comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span></span><br><span class="line">                System.out.println(s);   </span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里只有一句打印，所以我们来优化一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(System.out::println);  </span><br><span class="line">  	<span class="comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p>
<p>除了在不为空时执行的操作外，还可以直接从Optional中获取被包装的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).get());</span><br></pre></td></tr></table></figure>

<p>不过此时当被包装的对象为null时会直接抛出异常，当然，我们还可以指定如果get的对象为null的替代方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Optional.ofNullable(str).orElse(<span class="string">&quot;VVV&quot;</span>));   <span class="comment">//orElse表示如果为空就返回里面的内容</span></span><br></pre></td></tr></table></figure>

<p>其他操作还请回顾JavaSE篇视频教程。</p>
<h2 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h2><p>这一部分，我们将介绍Java 9为我们带来的新特性，Java 9的主要特性有，全新的模块机制、接口的private方法等。</p>
<h3 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h3><p>在我们之前的开发中，不知道各位有没有发现一个问题，就是当我们导入一个<code>jar</code>包作为依赖时（包括JDK官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库，实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。</p>
<p>于是，Java 9引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofan3qvxj21b409qjs3.jpg" alt="image-20220528210803658"></p>
<p>而在引入模块机制之后：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofcn7rt7j219009y3za.jpg" alt="image-20220528210958964"></p>
<p>可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。这里我们创建一个新的项目，并在<code>src</code>目录下，新建<code>module-info.java</code>文件表示此项目采用模块管理机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来创建一个主类：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ofzqina8j21lo0bymyz.jpg" alt="image-20220528213210752"></p>
<p>程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK为我们提供的某些框架不见了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2og24c18zj216o07gwf7.jpg" alt="image-20220528213428296"></p>
<p>Java为我们提供的<code>logging</code>相关日志库呢？我们发现现在居然不见了？实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NewHelloWorld &#123;  <span class="comment">//模块名称随便起一个就可以</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库</span></span><br><span class="line">  	<span class="comment">//当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se;  即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们导入java.logging相关模块后，就可以正常使用Logger了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogarnv3hj21oi0bewgd.jpg" alt="image-20220528214247006"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ogb52z1fj214203ejrl.jpg" alt="image-20220528214308194"></p>
<p>是不是瞬间感觉编写代码时清爽了许多，全新的模块化机制提供了另一个级别的Java代码可见性、可访问性的控制，不过，你以为仅仅是做了包的分离吗？我们可以来尝试通过反射获取JDK提供的类中的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java17版本的String类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>,</span></span><br><span class="line"><span class="class">               <span class="title">Constable</span>, <span class="title">ConstantDesc</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;  <span class="comment">//自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">    Field field = stringClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);   <span class="comment">//这里我们通过反射来获取String类中的value字段</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//由于是private访问权限，所以我们修改一下</span></span><br><span class="line">    System.out.println(field.get(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们发现，在程序运行之后，修改操作被阻止了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ohbps200j22l008qgpe.jpg" alt="image-20220528221817482"></p>
<p>反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的，看来Unsafe类是玩不成了。</p>
<p>我们现在就来细嗦一下这个模块机制，首先模块具有四种类型：</p>
<ul>
<li><strong>系统模块：</strong>来自JDK和JRE的模块（官方提供的模块，比如我们上面用的），我们也可以直接使用<code>java --list-modules</code>命令来列出所有的模块，不同的模块会导出不同的包供我们使用。</li>
<li><strong>应用程序模块：</strong>我们自己写的Java模块项目。</li>
<li><strong>自动模块：</strong>可能有些库并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。</li>
<li><strong>未命名模块：</strong>我们自己创建的一个Java项目，如果没有创建<code>module-info.java</code>，那么会按照未命名模块进行处理，未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。不过，由于没有使用Java 9的模块新特性，未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导包就行）</li>
</ul>
<p>这里我们就来创建两个项目，看看如何使用模块机制，首先我们在项目A中，添加一个User类，一会项目B需要用到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (&quot;</span>+age+<span class="string">&quot;岁)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们编写一下项目A的模块设置：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ois6anujj21mu09075b.jpg" alt="image-20220528230842617"></p>
<p>这里我们将<code>com.test</code>包下所有内容都暴露出去，默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用。</p>
<p>接着我们现在想要在项目B中使用项目A的User类，我们需要进行导入：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2oj4ivmi3j21kw08ujsm.jpg" alt="image-20220528232033318"></p>
<p>现在我们就可以在Main类中使用模块<code>module.a</code>中暴露出来的包内容了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.User;   <span class="comment">//如果模块module.a不暴露，那么将无法导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;lbw&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了普通的<code>exports</code>进行包的暴露之外，我们也可以直接指定将包暴露给指定的模块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过现在还有一个问题，如果模块<code>module.a</code>依赖于其他模块，那么会不会传递给依赖于模块<code>module.a</code>的模块呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;   <span class="comment">//这里添加一个模块的依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2njtdxyj21gu09iabi.jpg" alt="image-20220529103614788"></p>
<p>可以看到，在模块<code>module.b</code>中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用，但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;   <span class="comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span></span><br><span class="line">    <span class="keyword">requires</span> transitive java.logging;   <span class="comment">//使用transitive来向其他模块传递此依赖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以使用了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2pvizv2j21cu0b275z.jpg" alt="image-20220529103828560"></p>
<p>还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    Class&lt;User&gt; userClass = User.class;</span><br><span class="line">    Field field = userClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//尝试修改访问权限</span></span><br><span class="line">    System.out.println(field.get(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p2widxrbj22l608cwip.jpg" alt="image-20220529104451040"></p>
<p>那么怎么样才可以使用反射呢？我们可以为其他模块开放某些运行使用反射的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;   <span class="comment">//直接添加open关键字开放整个模块的反射权限</span></span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    opens com.test;   <span class="comment">//通过使用opens关键字来为其他模块开放反射权限</span></span><br><span class="line">  	<span class="comment">//也可以指定目标开放反射 opens com.test to module.b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以指定模块需要使用的抽象类或是接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open <span class="keyword">module</span> <span class="keyword">module</span>.a &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.test to <span class="keyword">module</span>.b;</span><br><span class="line">    uses com.test.Test;  <span class="comment">//使用uses指定，Test是一个接口（比如需要的服务等），模块需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在模块B中去实现一下，然后声明我们提供了实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestImpl</span> <span class="keyword">implements</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.b &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.a;   <span class="comment">//导入项目A的模块，此模块暴露了com.test包</span></span><br><span class="line">    provides com.test.Test with com.main.TestImpl;  <span class="comment">//声明此模块提供了Test的实现类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的Maven项目：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p3zb45vqj225w0qowlb.jpg" alt="image-20220529112208486"></p>
<p>然后我们导入了lombok框架的依赖，如果我们不创建<code>module-info.java</code>文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.java.Log;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//使用lombok提供的注解，可以正常运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好<code>module-info.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，直接报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p44huvl1j21tk0bcmzz.jpg" alt="image-20220529112707958"></p>
<p>明明导入了lombok依赖，却无法使用，这是因为我们还需要去依赖对应的模块才行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.test &#123;</span><br><span class="line">    <span class="keyword">requires</span> lombok;   <span class="comment">//lombok模块</span></span><br><span class="line">    <span class="keyword">requires</span> java.logging;    <span class="comment">//JUL日志模块，也需要使用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2p46lqnndj21au0fu0ug.jpg" alt="image-20220529112909452"></p>
<p>这样我们就可以正常使用了，之后为了教程演示方便，咱们还是不用模块。</p>
<h3 id="JShell交互式编程"><a href="#JShell交互式编程" class="headerlink" title="JShell交互式编程"></a>JShell交互式编程</h3><p>Java 9为我们通过了一种交互式编程工具JShell，你还别说，真有Python那味。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p8zzjlfdj20v204yaaf.jpg" alt="image-20220529141547082"></p>
<p>环境配置完成后，我们只需要输入<code>jshell</code>命令即可开启交互式编程了，它支持我们一条一条命令进行操作。</p>
<p>比如我们来做一个简单的计算：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p91l5635j212609qt8z.jpg" alt="image-20220529141719363"></p>
<p>我们一次输入一行（可以不加分号），先定义一个a=10和b=10，然后定义c并得到a+b的结果，可以看到还是非常方便的，但是注意语法还是和Java是一样的。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p949kt5nj20ze06sdg8.jpg" alt="image-20220529141954494"></p>
<p>我们也可以快速创建一个方法供后续的调用。当我们按下Tab键还可以进行自动补全：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p986jzkdj215608074z.jpg" alt="image-20220529142340030"></p>
<p>除了直接运行我们写进去的代码之外，它还支持使用命令，输入<code>help</code>来查看命令列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p998buwcj217m0a4t9r.jpg" alt="image-20220529142440584"></p>
<p>比如我们可以使用<code>/vars</code>命令来展示当前定义的变量列表：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9cn6p6qj20wy042t8s.jpg" alt="image-20220529142757286"></p>
<p>当我们不想使用jshell时，直接输入<code>/exit</code>退出即可：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9dlqiucj20rw03274b.jpg" alt="image-20220529142852920"></p>
<h3 id="接口中的private方法"><a href="#接口中的private方法" class="headerlink" title="接口中的private方法"></a>接口中的private方法</h3><p>在Java 8中，接口中 的方法支持添加<code>default</code>关键字来添加默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9中，接口再次得到强化，现在接口中可以存在私有方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是test方法默认实现&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是接口中的私有方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。</p>
<h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>在之前，如果我们想要快速创建一个Map只能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">//要快速使用Map，需要先创建一个Map对象，然后再添加数据</span></span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Java 9之后，我们可以直接通过<code>of</code>方法来快速创建了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">18</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">20</span>);  <span class="comment">//直接一句搞定</span></span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉非常方便，of方法还被重载了很多次，分别适用于快速创建包含0~10对键值对的Map：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2p9ymylq6j21k00ggact.jpg" alt="image-20220529144905646"></p>
<p>但是注意，通过这种方式创建的Map和通过Arrays创建的List比较类似，也是无法进行修改的。</p>
<p>当然，除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;AAA&quot;</span>);  <span class="comment">//注意Set中元素顺序并不一定你的添加顺序</span></span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;BBB&quot;</span>);   <span class="comment">//好耶，再也不用Arrays了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h3><p>还记得我们之前在JavaSE中学习的Stream流吗？当然这里不是指进行IO操作的流，而是JDK1.8新增的Stream API，通过它大大方便了我们的编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//这里我们可以直接将一些元素封装到Stream中</span></span><br><span class="line">            .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">            .distinct()   <span class="comment">//去重</span></span><br><span class="line">            .forEach(System.out::println);   <span class="comment">//最后打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自从有了Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在Stream中一气呵成（具体的详细操作请回顾JavaSE篇）</p>
<p>如此方便的框架，在Java 9得到了进一步的增强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .of(<span class="keyword">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream</span><br><span class="line">            .ofNullable(<span class="keyword">null</span>) <span class="comment">//使用新增的ofNullable方法，这样就不会了，不过这样的话流里面就没东西了</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有，我们可以通过迭代快速生成一组数据（实际上Java 8就有了，这里新增的是允许结束迭代的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)   <span class="comment">//Java8只能像这样生成无限的流，第一个参数是种子，就是后面的UnaryOperator的参数i一开始的值，最后会返回一个值作为i的新值，每一轮都会执行UnaryOperator并生成一个新值到流中，这个是源源不断的，如果不加limit()进行限制的话，将无限生成下去。</span></span><br><span class="line">      			.limit(<span class="number">20</span>)   <span class="comment">//这里限制生成20个</span></span><br><span class="line">            .forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            <span class="comment">//不知道怎么写？参考一下：for (int i = 0;i &lt; 20;i++)</span></span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream还新增了对数据的截断操作，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .takeWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//当i小于10时正常通过，一旦大于等于10直接截断</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream</span><br><span class="line">            .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(<span class="number">20</span>)</span><br><span class="line">            .dropWhile(i -&gt; i &lt; <span class="number">10</span>)   <span class="comment">//和上面相反，上来就是截断状态，只有当满足条件时再开始通过</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他小型变动"><a href="#其他小型变动" class="headerlink" title="其他小型变动"></a>其他小型变动</h3><p>Try-with-resource语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = Files.newInputStream(Paths.get(<span class="string">&quot;pom.xml&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> (inputStream) &#123;   <span class="comment">//单独丢进try中，效果是一样的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) inputStream.read());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 8中引入了Optional类，它很好的解决了判空问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    test(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//比如现在我们想执行 System.out.println(str.toLowerCase())</span></span><br><span class="line">    <span class="comment">//但是由于我们不清楚给进来的str到底是不是null，如果是null的话会引起空指针异常</span></span><br><span class="line">    <span class="comment">//但是去单独进行一次null判断写起来又不太简洁，这时我们可以考虑使用Optional进行包装</span></span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(s)</span><br><span class="line">            .ifPresent(str -&gt; System.out.println(str.toLowerCase()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就有点像Kotlin或是JS中的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(str : <span class="type">String</span>?)</span></span>&#123;   <span class="comment">//传入的String对象可能为null，这里类型写为String?</span></span><br><span class="line">    println(str?.lowercase())   <span class="comment">// ?.表示只有不为空才进行调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 9新增了一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str).ifPresentOrElse(s -&gt; &#123;  <span class="comment">//通过使用ifPresentOrElse，我们同时处理两种情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为：&quot;</span>+s);     <span class="comment">//第一种情况和ifPresent是一样的</span></span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被包装的元素为null&quot;</span>);   <span class="comment">//第二种情况是如果为null的情况</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>or()</code>方法快速替换为另一个Optional类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    Optional.ofNullable(str)</span><br><span class="line">      .or(() -&gt; Optional.of(<span class="string">&quot;AAA&quot;</span>))   <span class="comment">//如果当前被包装的类不是null，依然返回自己，但是如果是null，那就返回Supplier提供的另一个Optional包装</span></span><br><span class="line">      .ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还支持直接转换为Stream，这里就不多说了。</p>
<p>在Java 8及之前，匿名内部类是没办法使用钻石运算符进行自动类型推断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">//这里我们写一个泛型类</span></span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Test&lt;String&gt; test = <span class="keyword">new</span> Test&lt;&gt;(<span class="string">&quot;AAA&quot;</span>) &#123;   <span class="comment">//在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是String类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢</span></span><br><span class="line">      <span class="comment">//在Java 9之后，这样的写法终于可以编译通过了</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了以上的特性之外还有Java 9的多版本JAR包支持、CompletableFuture API的改进等，因为不太常用，这里就不做介绍了。</p>
<h2 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h2><p>Java 10主要带来的是一些内部更新，相比Java 9带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了。</p>
<h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>在Java中，我们可以使用自动类型推断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   之前我们定义变量必须指定类型</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在我们使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是注意，<code>var</code>关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe3mpaw5j210u054jrw.jpg" alt="image-20220529171216795"></p>
<p>我们来看看是不是类型也能正常获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(a.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然是有了var关键字进行自动类型推断，但是最终还是会变成String类型，得到的Class也是String类型。但是Java终究不像JS那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pdwq4g2aj218e0b4jsh.jpg" alt="image-20220529170538383"></p>
<p>并且<code>var</code>关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2pe66iavlj216y0963z1.jpg" alt="image-20220529171444062"></p>
<p>有关Java 10新增的一些其他改进，这里就不提了。</p>
<h2 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h2><p>Java 11 是继Java 8之后的又一个TLS长期维护版本，在Java 17出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于Lambda的形参局部变量语法。</p>
<h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 10我们认识了<code>var</code>关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在lambda中使用：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppu61uu4j211w05m3z0.jpg" alt="image-20220529235822891"></p>
<p>但是实际上这里是完全可以进行类型推断的，所以在Java 11，终于是支持了，这样编写就不会报错了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2ppvf70n0j213g05m3yu.jpg" alt="image-20220529235935071"></p>
<h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;AB\nC\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str</span><br><span class="line">            .lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>repeat()</code>方法来让字符串重复拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;ABCD&quot;</span>;   <span class="comment">//比如现在我们有一个ABCD，但是现在我们想要一个ABCDABCD这样的基于原本字符串的重复字符串</span></span><br><span class="line">    System.out.println(str.repeat(<span class="number">2</span>));  <span class="comment">//一个repeat就搞定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以快速地进行空格去除操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全新的HttpClient使用"><a href="#全新的HttpClient使用" class="headerlink" title="全新的HttpClient使用"></a>全新的HttpClient使用</h3><p>在Java 9的时候其实就已经引入了全新的Http Client API，用于取代之前比较老旧的HttpURLConnection类，新的API支持最新的HTTP2和WebSocket协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();   <span class="comment">//直接创建一个新的HttpClient</span></span><br><span class="line">  	<span class="comment">//现在我们只需要构造一个Http请求实体，就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似）</span></span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://www.baidu.com&quot;</span>)).build();</span><br><span class="line">  	<span class="comment">//现在我们就可以把请求发送出去了，注意send方法后面还需要一个响应体处理器（内置了很多）这里我们选择ofString直接吧响应实体转换为String字符串</span></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">  	<span class="comment">//来看看响应实体是什么吧</span></span><br><span class="line">    System.out.println(response.body());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用全新的客户端，我们甚至可以轻松地做一个爬虫（仅供学习使用，别去做违法的事情，爬虫玩得好，牢饭吃到饱），比如现在我们想去批量下载某个网站的壁纸：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9pg4bvdj22920jcq83.jpg" alt="image-20220530112549225"></p>
<p>网站地址：<a target="_blank" rel="noopener" href="https://pic.netbian.com/4kmeinv/">https://pic.netbian.com/4kmeinv/</a></p>
<p>我们随便点击一张壁纸，发现网站的URL格式为：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9qp1af0j220s0loaf5.jpg" alt="image-20220530112701156"></p>
<p>并且不同的壁纸似乎都是这样：<a target="_blank" rel="noopener" href="https://pic.netbian.com/tupian/%E6%95%B0%E5%AD%97.html%EF%BC%8C%E5%A5%BD%E4%BA%86%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%95%B4%E6%B4%BB%E4%BA%86%EF%BC%9A">https://pic.netbian.com/tupian/数字.html，好了差不多可以开始整活了：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//先不要一次性获取太多，先来10个</span></span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com/tupian/&quot;</span>+(<span class="number">29327</span> + i)+<span class="string">&quot;.html&quot;</span>)).build();  <span class="comment">//这里我们按照规律，批量获取</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());  <span class="comment">//这里打印一下看看网页</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后控制台成功获取到这些图片的网站页面了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9uh6barj21k40b40w3.jpg" alt="image-20220530113039571"></p>
<p>接着我们需要来观察一下网站的HTML具体怎么写的，把图片的地址提取出来：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2q9vgs183j22b60esdmg.jpg" alt="image-20220530113136156"></p>
<p>好了，知道图片在哪里就好办了，直接字符串截取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        String html = response.body();</span><br><span class="line">        </span><br><span class="line">        String prefix = <span class="string">&quot;&lt;a href=\&quot;\&quot; id=\&quot;img\&quot;&gt;&lt;img src=\&quot;&quot;</span>;  <span class="comment">//先找好我们要截取的前面一段，作为前缀去匹配位置</span></span><br><span class="line">        String suffix = <span class="string">&quot;\&quot; data-pic=&quot;</span>;   <span class="comment">//再找好我们要截取的屁股后面紧接着的位置，作为后缀去匹配位置</span></span><br><span class="line">      	<span class="comment">//直接定位，然后前后截取，得到最终的图片地址</span></span><br><span class="line">        html = html.substring(html.indexOf(prefix) + prefix.length());</span><br><span class="line">        html = html.substring(<span class="number">0</span>, html.indexOf(suffix));</span><br><span class="line">        System.out.println(html);  <span class="comment">//最终的图片地址就有了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">				<span class="comment">//创建请求，把图片取到</span></span><br><span class="line">        HttpRequest imageRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">&quot;https://pic.netbian.com&quot;</span>+html)).build();</span><br><span class="line">      	<span class="comment">//这里以输入流的方式获取，不过貌似可以直接下载文件，各位小伙伴可以单独试试看</span></span><br><span class="line">        HttpResponse&lt;InputStream&gt; imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream());</span><br><span class="line">      	<span class="comment">//拿到输入流和文件输出流</span></span><br><span class="line">        InputStream imageInput = imageResponse.body();</span><br><span class="line">        FileOutputStream stream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;images/&quot;</span>+i+<span class="string">&quot;.jpg&quot;</span>); <span class="comment">//一会要保存的格式</span></span><br><span class="line">        <span class="keyword">try</span> (stream;imageInput)&#123;  <span class="comment">//直接把要close的变量放进来就行，简洁一些了</span></span><br><span class="line">            <span class="keyword">int</span> size;   <span class="comment">//下面具体保存过程的不用我多说了吧</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">            <span class="keyword">while</span> ((size = imageInput.read(data)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                stream.write(data, <span class="number">0</span>, size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在来看看效果吧，美女的图片已经成功保存到本地了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qacy37g6j22bs0psjwj.jpg" alt="image-20220530114824605"></p>
<p>当然，这仅仅是比较简单的爬虫，不过我们的最终目的还是希望各位能够学会使用新的HttpClient API。</p>
<h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12-16 新特性"></a>Java 12-16 新特性</h2><p>由于Java版本的更新迭代速度自Java 9开始为半年更新一次（Java 8到Java 9隔了整整三年），所以各个版本之间的更新内容比较少，剩余的6个版本，我们就多个版本放在一起进行讲解了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qawt5acvj21ci0u0tcg.jpg" alt="image-20220530120729757"></p>
<p>Java12-16这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能，12/13版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用，其实就是体验服的那种感觉。</p>
<h3 id="新的switch语法"><a href="#新的switch语法" class="headerlink" title="新的switch语法"></a>新的switch语法</h3><p>在Java 12引入全新的switch语法，让我们使用switch语句更加的灵活，比如我们想要编写一个根据成绩得到等级的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入分数（范围 0 - 100）返回对应的等级：</span></span><br><span class="line"><span class="comment"> *      100-90：优秀</span></span><br><span class="line"><span class="comment"> *      70-80：良好</span></span><br><span class="line"><span class="comment"> *      60-70：及格</span></span><br><span class="line"><span class="comment"> *      0-60：寄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> score 分数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想要使用switch来实现这个功能（不会吧不会吧，不会有人要想半天怎么用switch实现吧），之前的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">  	String res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//不同的分数段就可以返回不同的等级了</span></span><br><span class="line">        		<span class="keyword">break</span>;   <span class="comment">//别忘了break，不然会贯穿到后面</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在我们可以使用新的特性了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">grade</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">    score /= <span class="number">10</span>;  <span class="comment">//既然分数段都是整数，那就直接整除10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//语法那是相当的简洁，而且也不需要我们自己考虑break或是return来结束switch了（有时候就容易忘记，这样的话就算忘记也没事了）</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过最后编译出来的样子，貌似还是和之前是一样的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qsvu3u7dj21zw0nawhc.jpg" alt="image-20220530222918174"></p>
<p>这种全新的switch语法称为<code>switch表达式</code>，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;   <span class="comment">//case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</span></span><br><span class="line">    <span class="keyword">case</span> ...   <span class="comment">//根据不同的分支，可以存在多个case</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;   <span class="comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (obj) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//我们可以使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//... 我是其他要做的事情</span></span><br><span class="line">        yield  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后需要返回最终结果，但是这样并不是使用return，而是yield关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">switch</span> (args.length) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...]:</span><br><span class="line">        yield <span class="string">&quot;AAA&quot;</span>;   <span class="comment">//传统的:写法，通过yield指定返回结果，同样不需要break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    		System.out.println(<span class="string">&quot;默认情况&quot;</span>);</span><br><span class="line">        yield <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。</p>
<p><strong>注意：</strong>switch表达式在Java 14才正式开放使用，所以我们项目的代码级别需要调整到14以上。</p>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>如果你学习过Python，一定知道三引号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span></span><br><span class="line">multi_line =  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                nice to meet you!</span></span><br><span class="line"><span class="string">                  nice to meet you!</span></span><br><span class="line"><span class="string">                      nice to meet you!</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> multi_line</span><br></pre></td></tr></table></figure>

<p>没错，Java13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtu8ym7pj218008w3z2.jpg" alt="image-20220530230225037"></p>
<p>可以看到，Java中也可以使用这样的三引号来表示字符串了，并且我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qtvm8z1wj21e008kdgm.jpg" alt="image-20220530230343933"></p>
<p>仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？</p>
<p><strong>注意：</strong>文本块表达式在Java 15才正式开放使用，所以我们项目的代码级别需要调整到15以上。</p>
<h3 id="新的instanceof语法"><a href="#新的instanceof语法" class="headerlink" title="新的instanceof语法"></a>新的instanceof语法</h3><p>在Java 14，instanceof迎来了一波小更新（哈哈，这版本instanceof又加强了，版本强势语法）</p>
<p>比如我们之前要重写一个类的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//首先判断是否为Student类型</span></span><br><span class="line">            Student student = (Student) obj;  <span class="comment">//如果是，那么就类型转换</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//最后比对属性是否一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本instanceof加强之后，我们就不需要了，我们可以直接将student替换为模式变量：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qufj2gt9j21da0bowg5.jpg" alt="image-20220530232252253"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;   <span class="comment">//在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的</span></span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="keyword">this</span>.name);  <span class="comment">//下面直接用，是不是贼方便</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用<code>instanceof</code>判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤。</p>
<p><strong>注意：</strong>新的instanceof语法在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h3 id="空指针异常的改进"><a href="#空指针异常的改进" class="headerlink" title="空指针异常的改进"></a>空指针异常的改进</h3><p>相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = a.length() + b.length();   <span class="comment">//可能给进来的a或是b为null</span></span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为空时，就会直接：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qukskyh6j21a602mgm0.jpg" alt="image-20220530232755797"></p>
<p>但是由于我们这里a和b都调用了<code>length()</code>方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是a为null还是b为null呢？我们是没办法直接得到的（遇到过这种问题的扣个1吧，只能调试，就很头疼）</p>
<p>但是当我们在Java 14或更高版本运行时：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qunhkgrcj21lc042my7.jpg" alt="image-20220530233031005"></p>
<p>这里会明确指出是哪一个变量调用出现了空指针，是不是感觉特别人性化。</p>
<h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><p>继类、接口、枚举、注解之后的又一新类型来了，它的名字叫”记录”，在Java 14中首次出场，这一出场，Lombok的噩梦来了。</p>
<p>在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据，比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;   <span class="comment">//使用Lombok，一个注解就搞定了</span></span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lombok可以说是简化代码的神器了，他能在编译时自动生成getter和setter、构造方法、toString()方法等实现，在编写这些实体类时，简直不要太好用，而这一波，官方也是看不下去了，于是自己也搞了一个记录类型。</p>
<p>记录类型本质上也是一个普通的类，不过是final类型且继承自java.lang.Record抽象类的，它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，好家伙，这是要逼死Lombok啊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> </span>&#123;  <span class="comment">//直接把字段写在括号中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也是非常方便，自动生成了构造方法和成员字段的公共get方法：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qve5yx6tj219u086ab5.jpg" alt="image-20220530235609885"></p>
<p>并且toString也是被重写了的：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qvfdhp6oj219001s3yo.jpg" alt="image-20220530235719341"></p>
<p><code>equals()</code>方法仅做成员字段之间的值比较，也是帮助我们实现好了的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account account0 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">Account account1 = <span class="keyword">new</span> Account(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);   <span class="comment">//两个属性都是一模一样的</span></span><br><span class="line">System.out.println(account0.equals(account1));  <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>

<p>是不是感觉这种类型就是专门为这种实体类而生的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Account</span><span class="params">(String username, String password)</span> implements Runnable </span>&#123;  <span class="comment">//支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>记录类型在Java 16才正式开放使用，所以我们项目的代码级别需要调整到16以上。</p>
<h2 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h2><p>Java 17作为新的LTS长期维护版本，我们来看看都更新了什么（不包含预览特性，包括switch第二次增强，哈哈，果然还是强度不够，都连续加强两个版本了）</p>
<h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>密封类型可以说是Java 17正式推出的又一重磅类型，它在Java 15首次提出并测试了两个版本。</p>
<p>在Java中，我们可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p>
<p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;   <span class="comment">//添加final关键字后，不允许对此类继承</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。</p>
<p>但是现在我们可以使用密封类型来实现这个功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>密封类型有以下要求：</p>
<ul>
<li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li>
<li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li>
<li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li>
<li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li>
</ul>
<p>标准的声明格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed [<span class="keyword">abstract</span>] [<span class="class"><span class="keyword">class</span>/<span class="title">interface</span>] 类名 [<span class="keyword">extends</span> 父类] [<span class="keyword">implements</span> 接口, ...] <span class="title">permits</span> [子类, ...]</span>&#123;</span><br><span class="line">		<span class="comment">//里面的该咋写咋写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意子类格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/sealed/non-sealed] <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line">			<span class="comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span></span><br><span class="line">  		<span class="comment">//sealed类型：同父类，需要指定由哪些类继承。</span></span><br><span class="line">  		<span class="comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在我们写了这些类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="title">permits</span> <span class="title">B</span></span>&#123;   <span class="comment">//指定B继承A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;   <span class="comment">//在子类final，彻底封死</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到其他的类无论是继承A还是继承B都无法通过编译：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5p7u49j216i05074q.jpg" alt="image-20220531090136485"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rb5zg837j2130050jrz.jpg" alt="image-20220531090152743"></p>
<p>但是如果此时我们主动将B设定为<code>non-sealed</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> non-sealed <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正常继承了，因为B指定了<code>non-sealed</code>主动放弃了密封特性，这样就显得非常灵活了。</p>
<p>当然我们也可以通过反射来获取类是否为密封类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());   <span class="comment">//是否为密封</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Java 9 - 17的主要新特性就讲解完毕了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/jdk%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag"><i class="fa fa-tag"></i> jdk新特性</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/7f37.html" rel="prev" title="谷粒商城学习总结">
      <i class="fa fa-chevron-left"></i> 谷粒商城学习总结
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/1141.html" rel="next" title="设计模式学习">
      设计模式学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-text">Java新特性介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-8-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%9B%9E%E9%A1%BE"><span class="nav-text">Java 8 关键特性回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional%E7%B1%BB"><span class="nav-text">Optional类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 9 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><span class="nav-text">模块机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JShell%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-text">JShell交互式编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84private%E6%96%B9%E6%B3%95"><span class="nav-text">接口中的private方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E6%96%B0%E5%A2%9E%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-text">集合类新增工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84-Stream-API"><span class="nav-text">改进的 Stream API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B0%8F%E5%9E%8B%E5%8F%98%E5%8A%A8"><span class="nav-text">其他小型变动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 10 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">局部变量类型推断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8ELambda%E7%9A%84%E5%BD%A2%E5%8F%82%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">用于Lambda的形参局部变量语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8EString%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA"><span class="nav-text">针对于String类的方法增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%B0%E7%9A%84HttpClient%E4%BD%BF%E7%94%A8"><span class="nav-text">全新的HttpClient使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-12-16-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 12-16 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84switch%E8%AF%AD%E6%B3%95"><span class="nav-text">新的switch语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84instanceof%E8%AF%AD%E6%B3%95"><span class="nav-text">新的instanceof语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-text">空指针异常的改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">记录类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 17 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">密封类型</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuumiy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yuumiy</p>
  <div class="site-description" itemprop="description">coding就是生产力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuumiy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuumiy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:115274737@qq.com" title="E-Mail → mailto:115274737@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://yuumiy.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;yuumiy.blog.csdn.net" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuumiy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">321k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:52</span>
</div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("08/10/2021 12:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()",250);
</script>

<script async src="/js/busuanzi.pure.mini.js"></script>
<span><br></span>	

<span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
</span>
<span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
    <span class="post-meta-divider">|</span>
<span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
</span>
    <span>总访问量&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/js/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'PuhblTYT44STCX6Edvpd76zF-gzGzoHsz',
      appKey     : '43DKcrM2QNBca1Ww68fepMOV',
      placeholder: "填写邮箱作者能够及时反馈，欢迎评论哦(๑•̀ㅂ•́)و✧",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
